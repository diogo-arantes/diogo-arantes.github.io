<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0">
    <title>Viagem amaldiÃ§oada</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', monospace;
            color: #8a0303;
        }

        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
        }

        canvas {
            display: block;
            background: linear-gradient(to bottom, #0a0a0a, #1a0707);
        }

        #game-container {
            position: absolute;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #bars-container {
            position: absolute;
            top: 20px;
            left: 100px;
            display: flex;
            gap: 10px;
        }

        #mana-bar-container, #armor-bar-container {
            width: 120px;
            height: 15px;
            background: rgb(34, 0, 0);
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid rgb(83, 0, 0);
        }

        #mana-bar {
            width: 100%;
            height: 100%;
            background: rgb(255, 9, 9);
            transition: width 0.2s;
        }

        #armor-bar {
            width: 0%;
            height: 100%;
            background: rgb(75, 9, 255);
            transition: width 0.2s;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        h1 {
            color: #8a0303;
            font-size: 1.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000; }
            50% { text-shadow: 0 0 15px #ff0000, 0 0 30px #ff0000; }
            100% { text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000; }
        }

        button {
            padding: 15px 30px;
            font-size: 1em;
            border: 2px solid #8a0303;
            background-color: #1a0707;
            color: #8a0303;
            cursor: pointer;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }

        button:hover {
            background-color: #8a0303;
            color: #000;
            transform: scale(1.05);
        }

        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1em;
            z-index: 5;
        }

        #game-over-score {
            font-size: 2em;
            margin: 20px 0;
        }

        @media (max-width: 768px) {
            #mana-bar-container, #armor-bar-container {
                width: 60px;
                height: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="score">Score: 0</div>
        <div id="inventory" style="
            position: absolute;
            top: 30px;
            left: 10px;
            font-size: .8em;
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;">
        </div>
        <div id="lives" style="
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: .8em;
            color: white;
            z-index: 5;">
        </div>
        <div id="bars-container">
            <div id="mana-bar-container">
                <div id="mana-bar"></div>
            </div>
            <div id="armor-bar-container">
                <div id="armor-bar"></div>
            </div>
        </div>

        <div id="start-screen">
            <h1>VIAGEM AMALDIÃ‡OADA</h1>
            <button id="start-button">PREPARE-SE PARA PERDER</button>
        </div>

        <div id="game-over-screen" style="display: none;">
            <h1>GAME OVER</h1>
            <div id="game-over-score"></div>
            <button id="restart-button">VAI TENTAR NEH</button>
        </div>
    </div>

    <script>
        // ðŸŽ® Game Elements (DOM)
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const gameOverScoreDisplay = document.getElementById('game-over-score');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');

        // ðŸ“Œ Set Canvas Size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // ðŸ“± Device Detection
        const isMobile = /iPhone|iPad|Android|Mobile/i.test(navigator.userAgent);

        // ðŸš€ Game State
        let gameStarted = false;
        let gameOver = false;
        let gameTime = 0;
        let score = 0;
        let lastObstacleTime = 0;
        let lastCollectibleTime = 0;

        // â¤ï¸ Player State
        let lives = 3;
        let isHit = false;
        let hitTimer = 0;
        let isExploding = false;
        let shipFlicker = false;
        let flickerCount = 0;

        // ðŸ›  Ship Properties
        const shipWidth = 80, shipHeight = 40;
        let shipX = canvas.width * 0.2, shipY = canvas.height / 2;
        let shipVelocity = 0, shipXVelocity = 0;
        const shipAcceleration = 0.3, shipFriction = 0.9;
        const fastSpeedThreshold = 3;

        // âš¡ Power-ups & Energy
        let maxMana = 100, mana = maxMana;
        let maxArmor = 100, armor = 0;
        let invincible = false, invincibleTimer = 0;
        let canShoot = false, laserActive = false, laserBeam = null;
        let bullets = [], laserCooldown = false, shootTimer = 0;
        const bulletSpeed = 10;
        const bulletSize = 8;

        // ðŸŽ¯ Speed & Difficulty
        const mobileSpeedFactor = isMobile ? 0.5 : 1.0;
        let backgroundSpeed = 5 * mobileSpeedFactor;
        let obstacleSpeed = 1 * mobileSpeedFactor;
        let collectibleSpeed = 1 * mobileSpeedFactor;
        let normalAcceleration = 0.3, slowAcceleration = 0.1;
        let currentAcceleration = normalAcceleration;
        let slowMovementTimer = 0;

        // ðŸŒŽ Environment
        let groundLevel = canvas.height * 0.9;
        let ceilingLevel = canvas.height * 0.1;
        const normalGravity = 0.3, mobileGravity = 0.15;
        let gravity = isMobile ? mobileGravity : normalGravity;

        // ðŸ”„ Objects & Obstacles
        let obstacles = [];
        let stalactites = [];
        let nextStalactiteTime = gameTime + Math.floor(Math.random() * 1000) + 500;

        // ðŸŽ¨ Graphics & Effects
        const bgLayers = [];
        const numLayers = 3;
        let bgReady = false;
        const shipGlow = { radius: 20, opacity: 0.5, color: '#8a0303' };

        let obstaclesPassed = 0;
        let bossActive = false;
        let currentBoss = null;
        let bossHits = 0;
        let bossAngle = 0;
        let bossRadius = 100;
        let bossIndex = 0;
        let bossRays = []; // Store boss rays
        let bossShootInterval = 100; // Adjust time between shots
        let lastBossShotTime = 0;

        const bosses = [
            { emoji: "ðŸ", name: 'still', hits: 5, size: 100 },
            { emoji: "ðŸ§Œ", name: 'still', hits: 7, size: 100 },
            { emoji: "ðŸ§Ÿâ€â™€ï¸", name: 'circular', hits: 9, size: 100 },
            { emoji: "ðŸ¦¹ðŸ½â€â™‚ï¸", name: 'still', hits: 9, size: 100 },
            { emoji: "â˜£ï¸", name: 'circular', hits: 9, size: 100 },
        ];

        // ðŸ† Collectibles & Inventory
        let activeCollectibles = [];
        let inventory = { "ðŸ’€": 0, "ðŸ’©": 0, "ðŸ”«": 0, "ðŸŒ": 0, "â˜¢ï¸": 0 };
        const collectibles = [
            { emoji: "ðŸ’€", name: "skull", points: 5, spawnRate: 0.6 },
            { emoji: "ðŸ’©", name: "ring", points: 10, spawnRate: 0.4 },
            { emoji: "ðŸ”«", name: "coconut", points: 15, spawnRate: 0.9 },
            { emoji: "ðŸŒ", name: "time", points: 10, spawnRate: 0.7 },
            { emoji: "â˜¢ï¸", name: "radiation", points: 10, spawnRate: 0.3 },
            { emoji: "ðŸŒª", name: "speedup", points: 0, spawnRate: 0.3 },
            { emoji: "ðŸ”‹", name: "battery", points: 100, spawnRate: 0.3 },
        ];


        // âš ï¸ Obstacle Patterns
        const emojiShapes = [
            {
                type: "triangle",
                pattern: [
                    ["",  "",  "ðŸ’¥", "",  "" ],
                    ["",  "ðŸ’¥", "ðŸ’¥", "ðŸ’¥", "" ],
                    ["ðŸ’¥", "ðŸ’¥", "ðŸ’¥", "ðŸ’¥", "ðŸ’¥"],
                    ["",  "ðŸ’¥", "ðŸ’¥", "ðŸ’¥", "" ],
                    ["",  "",  "ðŸ’¥", "",  "" ]
                ]
            },
            {
                type: "square",
                pattern: [
                    ["ðŸ‘¾", "",  "ðŸ‘¾"],
                    ["ðŸ‘¾", "", "ðŸ‘¾"],
                    ["ðŸ‘¾", "ðŸ‘¾", "ðŸ‘¾"],
                    ["ðŸ‘¾", "", "ðŸ‘¾"],
                    ["ðŸ‘¾", "",  "ðŸ‘¾"]
                ]
            },
            {
                type: "diamond",
                pattern: [
                    ["",  "",  "ðŸ‘½", "",  "" ],
                    ["",  "ðŸ‘½", "ðŸ‘½", "ðŸ‘½", "" ],
                    ["ðŸ‘½", "ðŸ‘½", "ðŸ‘½", "ðŸ‘½", "ðŸ‘½"],
                    ["",  "ðŸ‘½", "ðŸ‘½", "ðŸ‘½", "" ],
                    ["",  "",  "ðŸ‘½", "",  "" ]
                ]
            },
            {
                type: "eyes",
                pattern: [
                    ["", "", "", "ðŸ‘€"],
                    ["", "ðŸ‘€", "ðŸ‘€", ""],
                    ["ðŸ‘€", "ðŸ‘€", "ðŸ‘€", ""],
                    ["", "ðŸ‘€", "ðŸ‘€", ""],
                    ["", "", "",  "ðŸ‘€"]
                ]
            },
            {
                type: "bar",
                pattern: [
                    ["",  "",  "",  "",  "" ],
                    ["",  "",  "",  "",  "" ],
                    ["ðŸŸ¥", "ðŸŸ¥", "ðŸŸ¥", "ðŸŸ¥", "ðŸŸ¥"],
                    ["",  "",  "",  "",  "" ],
                    ["",  "",  "",  "",  "" ]
                ]
            },
            {
                type: "moon",
                pattern: [
                    ["",  "ðŸŒ‘", " ",  "" ],
                    ["",  "",  "ðŸŒ‘", "" ],
                    ["",  "",  "",  "ðŸŒ‘"],
                    ["",  "",  "",  "ðŸŒ‘"],
                    ["",  "",  "ðŸŒ‘", "" ],
                    ["",  "ðŸŒ‘", "",  "" ]
                ]
            },
            {
                type: "eggs",
                pattern: [
                    ["",  "",  "ðŸ"],
                    ["",  "ðŸ", "" ],
                    ["ðŸ", "ðŸ", "" ],
                    ["ðŸ", "ðŸ", "" ],
                    ["",  "ðŸ", "" ],
                    ["",  "",  "ðŸ"]
                ]
            },
            {
                type: "bones",
                pattern: [
                    ["ðŸ¦´", "ðŸ¦´", "ðŸ¦´", ""],
                    ["", "ðŸ¦´", "ðŸ¦´", "ðŸ¦´"],
                    ["",  "",  "ðŸ¦´", "ðŸ¦´"],
                    ["",  "",  "ðŸ¦´", "ðŸ¦´"],
                    ["",  "",  "ðŸ¦´", "ðŸ¦´"],
                    ["", "ðŸ¦´", "ðŸ¦´", "ðŸ¦´"],
                    ["ðŸ¦´", "ðŸ¦´", "ðŸ¦´", ""]
                ]
            },
            {
                type: "square",
                pattern: [
                    ["ðŸŸ¨", "ðŸŸ¨", "ðŸŸ¨", "ðŸŸ¨"],
                    ["", "", "ðŸŸ¨", ""],
                    ["",  "",  "ðŸŸ¨", "ðŸŸ¨", "ðŸŸ¨", "ðŸŸ¨"],
                    ["", "", "ðŸŸ¨", ""],
                    ["ðŸŸ¨", "ðŸŸ¨", "ðŸŸ¨", "ðŸŸ¨"]
                ]
            },
            {
                type: "you",
                pattern: [
                    ["", "ðŸ«µðŸ¼","", ""],
                    ["ðŸ«µðŸ¼", "ðŸ«µðŸ¼", "ðŸ«µðŸ¼","",],
                    ["ðŸ«µðŸ¼", "ðŸ«µðŸ¼", "ðŸ«µðŸ¼",""],
                    ["ðŸ«µðŸ¼", "ðŸ«µðŸ¼", "ðŸ«µðŸ¼","",],
                    ["", "ðŸ«µðŸ¼", "",""]
                ],
            }
        ];


        // ðŸ”Š Sound Effects & Music
        const sounds = {
            startup: new Audio("startup.mp3"),
            music1: new Audio("background-layer-0.mp3"),
            music2: new Audio("background-layer-1.mp3"),
            music3: new Audio("background-layer-2.mp3"),
            risada: new Audio("risada-do-mal.mp3"),
            ghost: new Audio("ghost.mp3"),
            shoot: new Audio("shoot.mp3"),
            laser: new Audio("laser.mp3"),
            explosion: new Audio("explosion.mp3"),
            explosionAll: new Audio("explosion-all.mp3"),
            collect: new Audio("collect.mp3"),
            shield: new Audio("shield.mp3"),
            life: new Audio("life.mp3"),
            loseLife: new Audio("lose-life.mp3"),
            scratching: new Audio("scratching.mp3"),
            gameover: new Audio("gameover.mp3")
        };

        // ðŸŽµ Configure Looping & Volume
        Object.values(sounds).forEach(sound => (sound.loop = false));
        sounds.music1.loop = sounds.music2.loop = sounds.music3.loop = true;
        sounds.music1.volume = 0.3;
        sounds.music2.volume = 0.2;
        sounds.music3.volume = 0.4;


        // ðŸš€ Play Background Music when the game starts
        function startMusic() {
            sounds.music2.play();
            sounds.music3.play();
        }

        // ðŸ”« Play Sound Effects
        function playSound(sound) {
            if (sounds[sound]) {
                sounds[sound].currentTime = 0; // Reset to allow rapid triggers
                sounds[sound].play();
            }
        }

        function updateManaBar() {
            let manaPercentage = (mana / maxMana) * 100;
            document.getElementById('mana-bar').style.width = `${manaPercentage}%`;

            // Se a mana acabou, o jogador perde uma vida
            if (mana <= 0) {
                loseLife();
                mana = maxMana; // Recupera a mana ao perder uma vida
            }
        }

        function updateArmorBar() {
            let armorPercentage = (armor / maxArmor) * 100;
            document.getElementById('armor-bar').style.width = `${armorPercentage}%`;
        }

        // Create a falling stalactite
        function createStalactite() {
            if (isMobile) return;
            let baseWidth = 40 + Math.random() * 30; // Wider base
            let height = 60 + Math.random() * 50; // Taller stalactite

            let stalactite = {
                x: Math.random() * (canvas.width - baseWidth) + baseWidth / 2, // Random horizontal position
                y: ceilingLevel, // Starts at ceiling
                width: baseWidth,
                height: height,
                speed: 2 + Math.random() * 2, // Falling speed
                active: true // Track if it's still in the game
            };
            stalactites.push(stalactite);
        }

        // Draw stalactites
        function drawStalactites() {
            ctx.fillStyle = "#553322"; // Darker rock color
            ctx.strokeStyle = "#8a0303"; // Red outline for visibility
            ctx.lineWidth = 2;

            stalactites.forEach(stalactite => {
                ctx.beginPath();
                ctx.moveTo(stalactite.x, stalactite.y); // Top middle
                let peakOffset = stalactite.width * 0.2;

                // Draw a jagged, uneven base (simulating rocky formation)
                ctx.lineTo(stalactite.x - stalactite.width / 2, stalactite.y + peakOffset);
                ctx.lineTo(stalactite.x - stalactite.width * 0.3, stalactite.y + stalactite.height * 0.5);
                ctx.lineTo(stalactite.x - stalactite.width * 0.1, stalactite.y + stalactite.height * 0.8);
                ctx.lineTo(stalactite.x, stalactite.y + stalactite.height);
                ctx.lineTo(stalactite.x + stalactite.width * 0.1, stalactite.y + stalactite.height * 0.8);
                ctx.lineTo(stalactite.x + stalactite.width * 0.3, stalactite.y + stalactite.height * 0.5);
                ctx.lineTo(stalactite.x + stalactite.width / 2, stalactite.y + peakOffset);
                ctx.closePath();

                ctx.fill();
                ctx.stroke(); // Outline for better visibility
            });
        }

        // ðŸ—ï¸ Update stalactites (falling effect)
        function updateStalactites() {
            if (isMobile) return;

            for (let i = stalactites.length - 1; i >= 0; i--) {
                let stalactite = stalactites[i];
                stalactite.y += stalactite.speed; // Move downward

                // Remove stalactites that go off the screen
                if (stalactite.y > canvas.height) {
                    stalactites.splice(i, 1);
                }

                // Check collision with the ship
                if (
                    shipX < stalactite.x + stalactite.width / 2 &&
                    shipX + shipWidth > stalactite.x - stalactite.width / 2 &&
                    shipY < stalactite.y + stalactite.height &&
                    shipY + shipHeight > stalactite.y
                ) {
                    loseLife();
                    stalactites.splice(i, 1);
                }
            }
        }

        // Shoot function
        function shoot() {
            if (armor <= 0) return

            if (inventory["ðŸ”«"] >= 3) {
                activateLaserMode();
            } else if (inventory["ðŸ”«"] > 0) {
                bullets.push({
                    x: shipX + shipWidth,
                    y: shipY + shipHeight / 2,
                    size: 8,
                    speed: 10
                });
                armor--;
                playSound("shoot");
            }
        }

        // Update bullets
        function updateShooting() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].x += bulletSpeed;

                // Remove bullet if it goes off-screen
                if (bullets[i].x > canvas.width) {
                    bullets.splice(i, 1);
                    continue;
                }

                if (bossActive && currentBoss) {
                    if (currentBoss.name === "circular") {
                        // Loop through 5 orbiting emojis
                        for (let j = 0; j < 5; j++) {
                            let angle = bossAngle + (j * (Math.PI * 2 / 5));
                            let bossX = currentBoss.x + Math.cos(angle) * bossRadius;
                            let bossY = currentBoss.y + Math.sin(angle) * bossRadius;

                            let bossSize = currentBoss.size * 0.7; // Adjust size for better hit detection

                            if (
                                bullets[i].x + bullets[i].size > bossX - bossSize / 2 &&
                                bullets[i].x < bossX + bossSize / 2 &&
                                bullets[i].y > bossY - bossSize / 2 &&
                                bullets[i].y < bossY + bossSize / 2
                            ) {
                                bullets.splice(i, 1); // Remove bullet upon hit
                                hitBoss();
                                return;
                            }
                        }
                    } else if (currentBoss.name === "still") {
                        // âœ… Collision detection for "still" boss
                        let bossSize = currentBoss.size * 3; // Boss is huge
                        let bossX = currentBoss.x;
                        let bossY = currentBoss.y;

                        if (
                            bullets[i].x + bullets[i].size > bossX - bossSize / 2 &&
                            bullets[i].x < bossX + bossSize / 2 &&
                            bullets[i].y > bossY - bossSize / 2 &&
                            bullets[i].y < bossY + bossSize / 2
                        ) {
                            bullets.splice(i, 1); // Remove bullet upon hit
                            hitBoss();
                            return;
                        }
                    }
                }

                // Check collision with obstacles
                for (let j = obstacles.length - 1; j >= 0; j--) {
                    let obstacle = obstacles[j];

                    if (obstacle.type === "emoji-block") {
                        for (let row = 0; row < obstacle.rows; row++) {
                            for (let col = 0; col < obstacle.pattern[row].length; col++) {
                                let emoji = obstacle.pattern[row][col];
                                if (emoji === "") continue;

                                let emojiX = obstacle.x + col * obstacle.blockSize;
                                let emojiY = obstacle.y + row * obstacle.blockSize;

                                if (
                                    bullets[i].x + bullets[i].size > emojiX &&
                                    bullets[i].x < emojiX + obstacle.blockSize &&
                                    bullets[i].y > emojiY &&
                                    bullets[i].y < emojiY + obstacle.blockSize
                                ) {
                                    obstacle.pattern[row][col] = ""; // Remove emoji
                                    bullets.splice(i, 1);
                                    score += 1;
                                    armor -= 1;
                                    updateArmorBar();
                                    return;
                                }
                            }
                        }
                    }
                }
            }

            if (laserBeam) {
                laserBeam.x += laserBeam.speed;
                if (laserBeam.x > canvas.width) laserBeam = null;

                if (bossActive && currentBoss) {
                    if (currentBoss.name === "circular") {
                        for (let j = 0; j < 5; j++) {
                            let angle = bossAngle + (j * (Math.PI * 2 / 5));
                            let bossX = currentBoss.x + Math.cos(angle) * bossRadius;
                            let bossY = currentBoss.y + Math.sin(angle) * bossRadius;
                            let bossSize = currentBoss.size * 0.7;

                            // Check if any part of the laser intersects the boss hitbox
                            if (
                                laserBeam.x + laserBeam.width > bossX - bossSize / 2 && // Right edge of laser
                                laserBeam.x < bossX + bossSize / 2 &&                  // Left edge of laser
                                laserBeam.y > bossY - bossSize / 2 &&
                                laserBeam.y < bossY + bossSize / 2
                            ) {
                                hitBoss();
                                createExplosion(bossX, bossY);
                                laserBeam = null; // Destroy laser on hit
                                return;
                            }
                        }
                    } else if (currentBoss.name === "still") {
                        let bossSize = currentBoss.size * 3;
                        let bossX = currentBoss.x;
                        let bossY = currentBoss.y;

                        // Check if any part of the laser intersects the boss hitbox
                        if (
                            laserBeam.x + laserBeam.width > bossX - bossSize / 2 &&
                            laserBeam.x < bossX + bossSize / 2 &&
                            laserBeam.y > bossY - bossSize / 2 &&
                            laserBeam.y < bossY + bossSize / 2
                        ) {
                            hitBoss();
                            createExplosion(bossX, bossY);
                            laserBeam = null;
                            return;
                        }
                    }
                }

                // Destroy obstacles with laser (unchanged)
                destroyObstaclesWithLaser();
            }
        }

        // Draw bullets
        function drawBullets() {
            ctx.fillStyle = "yellow";
            for (let bullet of bullets) {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function activateLaserMode() {
            if (laserCooldown || armor < 2) return;

            laserActive = true;
            laserCooldown = true;
            playSound("laser");

            armor -= 2;
            if (armor < 0) armor = 0;
            updateArmorBar();

            laserBeam = {
                x: shipX + shipWidth,
                y: shipY + shipHeight / 2,
                width: 900, // Consistent with collision detection
                speed: 5 // Reduced from 20 to 5 for visibility testing
            };

            console.log("Laser activated:", laserBeam); // Debug log

            setTimeout(() => {
                laserActive = false;
                laserBeam = null;
                console.log("Laser deactivated"); // Debug log
                setTimeout(() => {
                    laserCooldown = false;
                }, 100);
            }, 1000); // Increased to 1000ms for longer visibility
        }

        function drawLaser() {
            if (!laserBeam) return;

            let beamThickness = 8; // Core thickness
            let glowThickness = 18; // Glow thickness

            // **Core Laser Beam**
            ctx.globalAlpha = 0.9;
            ctx.strokeStyle = "rgba(0, 255, 255, 1)"; // Intense cyan core
            ctx.lineWidth = beamThickness;
            ctx.beginPath();
            ctx.moveTo(laserBeam.x, laserBeam.y);
            ctx.lineTo(laserBeam.x + laserBeam.width, laserBeam.y); // Use laserBeam.width
            ctx.stroke();

            // **Outer Glow**
            ctx.globalAlpha = 0.4;
            ctx.strokeStyle = "rgba(0, 255, 255, 0.6)";
            ctx.lineWidth = glowThickness;
            ctx.beginPath();
            ctx.moveTo(laserBeam.x, laserBeam.y);
            ctx.lineTo(laserBeam.x + laserBeam.width, laserBeam.y);
            ctx.stroke();

            // **Flickering Effect**
            if (Math.random() > 0.5) {
                ctx.globalAlpha = 0.2;
                ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
                ctx.lineWidth = glowThickness + 4;
                ctx.beginPath();
                ctx.moveTo(laserBeam.x, laserBeam.y);
                ctx.lineTo(laserBeam.x + laserBeam.width, laserBeam.y);
                ctx.stroke();
            }

            ctx.globalAlpha = 1; // Reset alpha
        }

        function destroyObstaclesWithLaser() {
            if (!laserBeam) return;
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obstacle = obstacles[i];
                if (
                    laserBeam.x + laserBeam.width > obstacle.x &&
                    laserBeam.x < obstacle.x + obstacle.width &&
                    laserBeam.y > obstacle.y &&
                    laserBeam.y < obstacle.y + obstacle.height
                ) {
                    createExplosion(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
                    obstacles.splice(i, 1);
                    armor -= 3;
                    if (armor < 0) armor = 0;
                    updateArmorBar();
                    laserBeam = null; // Destroy beam after hitting an obstacle
                    break;
                }
            }
        }

        function spawnBoss() {
            if (bossIndex >= bosses.length) {
                bossIndex = 0; // Loop back to the first boss if all are defeated
            }

            bossActive = true;
            backgroundSpeed = 0.4;
            obstacleSpeed = 0.4;
            currentBoss = { ...bosses[bossIndex], x: canvas.width / 2, y: canvas.height / 2, size: 100 };
            bossHits = currentBoss.hits;

            updateArmorBar(); // Update UI
        }

        function spawnBossRays() {
            if (!bossActive || !currentBoss) return;

            let numRays = 5; // Number of rays
            for (let i = 0; i < numRays; i++) {
                // Calculate base direction to the ship
                let dx = shipX - currentBoss.x;
                let dy = shipY - currentBoss.y;
                let baseAngle = Math.atan2(dy, dx); // Direction to the ship

                // Add randomness (chaotic effect)
                let randomOffset = (Math.random() - 0.5) * Math.PI / 3; // Adds up to Â±30Â° deviation
                let chaoticAngle = baseAngle + randomOffset;

                let speed = 3 + Math.random() * 3; // Speed between 3 and 6

                let newRay = {
                    x: currentBoss.x,
                    y: currentBoss.y,
                    angle: chaoticAngle,  // Now fires in a more chaotic way
                    speed: speed,
                    size: 6
                };

                bossRays.push(newRay);
            }
        }

        function drawBossRays() {
            for (let ray of bossRays) {
                ctx.beginPath();
                ctx.arc(ray.x, ray.y, ray.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, ${50 + Math.random() * 100}, 50, 1)`;  // Slight randomization in color
                ctx.shadowBlur = 15;
                ctx.shadowColor = "red";
                ctx.fill();
            }
        }

        function updateBossRays() {
            for (let i = bossRays.length - 1; i >= 0; i--) {
                let ray = bossRays[i];

                // Move in the direction of the chaotic angle
                ray.x += Math.cos(ray.angle) * ray.speed;
                ray.y += Math.sin(ray.angle) * ray.speed;

                // Remove rays if they go off-screen
                if (ray.x < -10 || ray.y < -10 || ray.x > canvas.width + 10 || ray.y > canvas.height + 10) {
                    bossRays.splice(i, 1);
                }
            }
        }

        function drawBoss() {
            if (!bossActive || !currentBoss) return;

            ctx.font = `${currentBoss.size*1.25}px Arial`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            if (currentBoss.name === "circular") {
                // Circular movement
                for (let i = 0; i < 5; i++) {
                    let angle = bossAngle + (i * (Math.PI * 2 / 5));
                    let bossX = currentBoss.x + Math.cos(angle) * bossRadius;
                    let bossY = currentBoss.y + Math.sin(angle) * bossRadius;
                    ctx.fillText(currentBoss.emoji, bossX, bossY);
                }
                bossAngle += 0.01; // Slower circular movement

            } else if (currentBoss.name === "still") {
                // One large emoji standing still
                ctx.font = `${currentBoss.size * 4}px Arial`; // Make it enormous
                ctx.fillText(currentBoss.emoji, currentBoss.x, currentBoss.y);
            }
        }

        function hitBoss() {
            if (bossActive && bossHits > 0) {
                bossHits--;
                playSound("explosion"); // Play hit sound
                createExplosion(currentBoss.x, currentBoss.y); // Show explosion effect

                // âœ… If boss is defeated, remove it and restore game speed
                if (bossHits <= 0) {
                    bossActive = false;
                    playSound("explosionAll"); // Big explosion sound when boss dies
                    backgroundSpeed = 5;
                    obstacleSpeed = 1;
                    createExplosion(currentBoss.x, currentBoss.y);
                    bossIndex++;
                }
            }
        }

        // Create background layers
        function createBackgroundLayers() {
            for (let i = 0; i < numLayers; i++) {
                const layer = {
                    x: 0,
                    speed: 0.3 + i * 0.3, // Different speeds for parallax effect
                    clouds: []
                };

                const numObjects = 5 + Math.floor(Math.random() * 20); // Random number of objects

                for (let j = 0; j < numObjects; j++) {
                    const type = Math.random() > 0.7 ? "planet" : "star"; // 30% chance for a planet
                    const depth = 0.1 + Math.random() * 0.3; // Depth factor between 0.3 and 1.0

                    layer.clouds.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        width: type === "planet" ? 60 + Math.random() * 140 : 4 + Math.random() * 6,
                        height: type === "planet" ? 60 + Math.random() * 140 : 4 + Math.random() * 6,
                        opacity: type === "star" ? (0.5 + Math.random() * 1) : .1,
                        color: type === "planet" ? ["#ffcc00", "#ff5500", "#0099ff", "#00ff66", "#ff66ff"][Math.floor(Math.random() * 5)] : "white",
                        type: type,
                        depth: depth // Assign depth for parallax effect
                    });
                }

                bgLayers.push(layer);
            }
            bgReady = true;
        }

        const explosionParticles = [];

        function createExplosion(x, y) {
            for (let i = 0; i < 50; i++) { // More particles for a stronger effect
                explosionParticles.push({
                    x: x,
                    y: y,
                    size: 5 + Math.random() * 12, // Bigger explosion
                    speedX: (Math.random() - 0.5) * 10,
                    speedY: (Math.random() - 0.5) * 10,
                    life: 50 + Math.random() * 30, // Lasts longer
                    color: `rgba(255, ${50 + Math.random() * 150}, 0, 1)`
                });
            }
        }

        function updateExplosion() {
            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                let p = explosionParticles[i];
                p.x += p.speedX;
                p.y += p.speedY;
                p.life--;
                if (p.life <= 0) explosionParticles.splice(i, 1); // Remove finished particles
            }
        }

        function drawExplosion() {
            for (const p of explosionParticles) {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }


        // Particles system for effects
        const particles = [];

        function createShipTrail() {
            particles.push({
                x: shipX,
                y: shipY + shipHeight / 2,
                size: 2 + Math.random() * 6,
                speedX: -1 - Math.random() * 2,
                speedY: (Math.random() - 0.5) * 2,
                life: 30 + Math.random() * 20,
                color: `rgba(${138 + Math.random() * 50}, ${3 + Math.random() * 20}, ${3 + Math.random() * 20}, ${0.3 + Math.random() * 0.5})`
            });
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.speedX;
                p.y += p.speedY;
                p.life--;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life / 50;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });
        }

        // Draw background layers
        function drawBackground() {
            if (!bgReady) return;

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (const layer of bgLayers) {
                layer.x -= backgroundSpeed * layer.speed; // Use `backgroundSpeed`
                if (layer.x < -canvas.width) {
                    layer.x = 0;
                }

                for (const obj of layer.clouds) {
                    obj.x -= backgroundSpeed * obj.depth; // Background scrolls separately
                    if (obj.x < -obj.width) {
                        obj.x = canvas.width + Math.random() * 100;
                        obj.y = Math.random() * canvas.height;
                    }

                    let adjustedOpacity = obj.opacity * obj.depth;

                    if (obj.type === "star") {
                        ctx.fillStyle = `rgba(255, 255, 255, ${adjustedOpacity})`;
                        ctx.beginPath();
                        ctx.arc(obj.x, obj.y, obj.width / 6, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (obj.type === "planet") {
                        ctx.fillStyle = obj.color;
                        ctx.globalAlpha = adjustedOpacity;
                        ctx.beginPath();
                        ctx.arc(obj.x, obj.y, obj.width / 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }
                }
            }
        }

        function drawCollectibles() {
            ctx.font = "25px Arial";  // Increased font size for visibility
            if (isMobile) ctx.font = "35px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            for (const item of activeCollectibles) {
                if (!item.collected) {
                    ctx.fillStyle = "white"; // Ensure high contrast for visibility
                    ctx.fillText(item.emoji, item.x, item.y);
                }
            }
        }

        // Draw the ship with a glow effect
        function drawShip() {
            if (isExploding) return;
            if (isHit && shipFlicker) {
                flickerCount++;
                if (flickerCount % 6 < 3) {
                    isHit = false;
                    return;
                }
            }

            // ðŸš€ **Define Armor Colors**
            let shipBaseColor = canShoot ? "#444" : "#8B0000"; // Gunmetal Gray when armed
            let armorBorderColor = canShoot ? "#AAA" : "#FF6347"; // Brighter outline
            let energyColor = canShoot ? "cyan" : "red"; // Blue glow when armed

            // ðŸŒŸ **Ship Glow Effect**
            ctx.beginPath();
            ctx.arc(shipX + shipWidth / 2, shipY + shipHeight / 2, shipGlow.radius, 0, Math.PI * 2);
            const glowGradient = ctx.createRadialGradient(
                shipX + shipWidth / 2, shipY + shipHeight / 2, 0,
                shipX + shipWidth / 2, shipY + shipHeight / 2, shipGlow.radius
            );
            glowGradient.addColorStop(0, `rgba(${canShoot ? '0,255,255' : '255,50,50'}, 0.8)`);
            glowGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
            ctx.fillStyle = glowGradient;
            ctx.fill();

            // ðŸš€ **Main Ship Body**
            ctx.fillStyle = shipBaseColor;
            ctx.strokeStyle = armorBorderColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(shipX, shipY + shipHeight / 2);
            ctx.lineTo(shipX + shipWidth * 0.3, shipY + shipHeight * 0.2);
            ctx.lineTo(shipX + shipWidth * 0.8, shipY + shipHeight * 0.2);
            ctx.lineTo(shipX + shipWidth, shipY + shipHeight / 2);
            ctx.lineTo(shipX + shipWidth * 0.8, shipY + shipHeight * 0.8);
            ctx.lineTo(shipX + shipWidth * 0.3, shipY + shipHeight * 0.8);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // ðŸ›¡ï¸ **Armor Plating (Metallic Highlights)**
            ctx.strokeStyle = "#DDD"; // Light metallic effect
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(shipX + shipWidth * 0.3, shipY + shipHeight * 0.2);
            ctx.lineTo(shipX + shipWidth * 0.3, shipY + shipHeight * 0.8);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(shipX + shipWidth * 0.6, shipY + shipHeight * 0.3);
            ctx.lineTo(shipX + shipWidth * 0.6, shipY + shipHeight * 0.7);
            ctx.stroke();

            // ðŸ”¥ **Energy Core (Glowing Center)**
            let coreGradient = ctx.createRadialGradient(
                shipX + shipWidth * 0.45, shipY + shipHeight * 0.5, 0,
                shipX + shipWidth * 0.45, shipY + shipHeight * 0.5, shipHeight * 0.15
            );
            coreGradient.addColorStop(0, "white");
            coreGradient.addColorStop(1, energyColor);
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(shipX + shipWidth * 0.45, shipY + shipHeight * 0.5, shipHeight * 0.15, 0, Math.PI * 2);
            ctx.fill();

            // ðŸŽ‡ **Invincible Mode Glow Effect**
            if (invincible) {
                let invincibleGlow = ctx.createRadialGradient(
                    shipX + shipWidth / 2, shipY + shipHeight / 2, 10,
                    shipX + shipWidth / 2, shipY + shipHeight / 2, 50
                );
                invincibleGlow.addColorStop(0, "rgba(255, 255, 255, 0.8)");
                invincibleGlow.addColorStop(1, "rgba(255, 255, 255, 0)");

                ctx.fillStyle = invincibleGlow;
                ctx.beginPath();
                ctx.arc(shipX + shipWidth / 2, shipY + shipHeight / 2, 40, 0, Math.PI * 2);
                ctx.fill();
            }

            // **EXTRA ARMOR (When Shooting is Enabled)**
            if (inventory['ðŸ”«'] < 4 && armor > 0) {
                ctx.fillStyle = "#666"; // Darker metallic armor
                ctx.strokeStyle = "#BBB";
                ctx.lineWidth = 2;

                // **Side Armor**
                ctx.fillRect(shipX + 5, shipY + 5, 15, shipHeight - 10);
                ctx.fillRect(shipX + shipWidth - 20, shipY + 5, 15, shipHeight - 10);

                // **Side Cannons**
                ctx.fillStyle = "#333";
                ctx.fillRect(shipX + shipWidth * 0.1, shipY + shipHeight * 0.2, 10, 20);
                ctx.fillRect(shipX + shipWidth * 0.1, shipY + shipHeight * 0.6, 10, 20);
                ctx.fillRect(shipX + shipWidth * 0.9 - 10, shipY + shipHeight * 0.2, 10, 20);
                ctx.fillRect(shipX + shipWidth * 0.9 - 10, shipY + shipHeight * 0.6, 10, 20);

                // **Glowing Vents & Weapon Ports**
                ctx.fillStyle = "rgba(0, 255, 255, 0.7)";
                ctx.fillRect(shipX + shipWidth * 0.35, shipY + shipHeight * 0.1, 8, 4);
                ctx.fillRect(shipX + shipWidth * 0.35, shipY + shipHeight * 0.85, 8, 4);
                ctx.fillRect(shipX + shipWidth * 0.6, shipY + shipHeight * 0.1, 8, 4);
                ctx.fillRect(shipX + shipWidth * 0.6, shipY + shipHeight * 0.85, 8, 4);
            }
            else if (inventory['ðŸ”«'] >= 4 && armor > 0) {
                ctx.strokeStyle = "cyan";
                ctx.lineWidth = 4;

                // **Energy Lines on Wings**
                ctx.beginPath();
                ctx.moveTo(shipX + shipWidth * 0.2, shipY + shipHeight * 0.1);
                ctx.lineTo(shipX + shipWidth * 0.8, shipY + shipHeight * 0.1);
                ctx.moveTo(shipX + shipWidth * 0.2, shipY + shipHeight * 0.9);
                ctx.lineTo(shipX + shipWidth * 0.8, shipY + shipHeight * 0.9);
                ctx.stroke();

                // **Outer Glow**
                let laserGlow = ctx.createRadialGradient(
                    shipX + shipWidth / 2, shipY + shipHeight / 2, 20,
                    shipX + shipWidth / 2, shipY + shipHeight / 2, 60
                );
                laserGlow.addColorStop(0, "rgba(0, 255, 255, 0.9)");
                laserGlow.addColorStop(1, "rgba(0, 0, 0, 0)");
                ctx.fillStyle = laserGlow;
                ctx.beginPath();
                ctx.arc(shipX + shipWidth / 2, shipY + shipHeight / 2, 50, 0, Math.PI * 2);
                ctx.fill();
            }
        }


        // Create obstacles: ground spikes and ceiling spikes
        function createObstacle() {
            const isEmojiBlock = Math.random() > 0.5; // 50% chance to generate emoji obstacles

            // Calculate possible spawn points to prevent overlap
            const numSections = 5; // Divide screen height into 5 sections
            const sectionHeight = (groundLevel - ceilingLevel) / numSections;
            let availableSections = Array.from({ length: numSections }, (_, i) => i);

            const sectionIndex = availableSections.splice(
                Math.floor(Math.random() * availableSections.length),
                1
            )[0];

            let newObstacle;

            if (isEmojiBlock) {
                const shape = emojiShapes[Math.floor(Math.random() * emojiShapes.length)];
                const blockSize = 30;
                const numRows = shape.pattern.length;
                const numCols = shape.pattern[0].length;

                // **Deep copy the pattern** to prevent modifying the original
                const copiedPattern = shape.pattern.map(row => [...row]);

                newObstacle = {
                    type: "emoji-block",
                    x: canvas.width,
                    width: numCols * blockSize,
                    height: numRows * blockSize,
                    pattern: copiedPattern,  // Use copied pattern instead of reference
                    blockSize: blockSize,
                    rows: numRows,
                    isGroundObstacle: Math.random() > 0.5,
                    passed: false
                };

                newObstacle.y = ceilingLevel + sectionIndex * sectionHeight + (sectionHeight - newObstacle.height) / 2;
            } else {
                // Traditional spike obstacle
                const width = 40 + Math.random() * 40;
                const height = 80 + Math.random() * 120;

                newObstacle = {
                    type: "spike",
                    x: canvas.width,
                    width,
                    height,
                    isGroundObstacle: Math.random() > 0.5,
                    passed: false
                };

                newObstacle.y = ceilingLevel + sectionIndex * sectionHeight + (sectionHeight - height) / 2;
            }

            // Prevent obstacles from spawning too close together
            if (obstacles.length > 0) {
                const lastObstacle = obstacles[obstacles.length - 1];
                if (newObstacle.x - lastObstacle.x < 150) {
                    return; // Avoid spawning too close
                }
            }

            obstacles.push(newObstacle);
        }

        function createCollectible() {
            if (Math.random() > 0.8) return; // General 20% chance to spawn any collectible

            // Filter only items that **pass the probability check**
            let availableItems = collectibles.filter(item => Math.random() < item.spawnRate);

            if (availableItems.length === 0) return; // If no items pass, don't spawn anything

            let item = availableItems[Math.floor(Math.random() * availableItems.length)];
            let size = 25;
            let yPos = Math.random() * (groundLevel - ceilingLevel - size) + ceilingLevel;

            activeCollectibles.push({
                emoji: item.emoji,
                name: item.name,
                points: item.points,
                x: canvas.width,
                y: yPos,
                size: size,
                collected: false
            });
        }

        // Draw ground and ceiling
        function drawGroundAndCeiling() {
            // Draw ceiling
            const ceilingGradient = ctx.createLinearGradient(0, 0, 0, ceilingLevel);
            ceilingGradient.addColorStop(0, '#0a0a0a');
            ceilingGradient.addColorStop(1, '#350101');
            ctx.fillStyle = ceilingGradient;
            ctx.fillRect(0, 0, canvas.width, ceilingLevel);

            // Ceiling details
            for (let i = 0; i < canvas.width; i += 40) {
                const height = 10 + Math.sin(i * 0.05 + gameTime * 0.01) * 5;
                ctx.fillStyle = '#8a0303';
                ctx.beginPath();
                ctx.moveTo(i, ceilingLevel);
                ctx.lineTo(i + 20, ceilingLevel);
                ctx.lineTo(i + 10, ceilingLevel + height);
                ctx.closePath();
                ctx.fill();
            }

            // Draw ground
            const groundGradient = ctx.createLinearGradient(0, groundLevel, 0, canvas.height);
            groundGradient.addColorStop(0, '#350101');
            groundGradient.addColorStop(1, '#0a0a0a');
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, groundLevel, canvas.width, canvas.height - groundLevel);

            // Ground details
            for (let i = 0; i < canvas.width; i += 40) {
                const height = 10 + Math.sin(i * 0.03 + gameTime * 0.01) * 5;
                ctx.fillStyle = '#8a0303';
                ctx.beginPath();
                ctx.moveTo(i, groundLevel);
                ctx.lineTo(i + 20, groundLevel);
                ctx.lineTo(i + 10, groundLevel - height);
                ctx.closePath();
                ctx.fill();
            }
        }

        // Draw obstacles
        function drawObstacles() {
            for (const obstacle of obstacles) {
                if (obstacle.type === "emoji-block") {
                    // Draw emoji obstacles
                    for (let row = 0; row < obstacle.rows; row++) {
                        for (let col = 0; col < obstacle.pattern[row].length; col++) {
                            const emoji = obstacle.pattern[row][col];
                            if (emoji === "") continue; // Skip empty spaces in pattern

                            const x = obstacle.x + col * obstacle.blockSize;
                            const y = obstacle.y + row * obstacle.blockSize;

                            ctx.font = `${obstacle.blockSize * 0.7}px Arial`;
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.fillStyle = "yellow";  // Brighter color
                            ctx.strokeStyle = "black"; // Outline for better visibility
                            ctx.lineWidth = 3;
                            ctx.strokeText(emoji, x + obstacle.blockSize / 2, y + obstacle.blockSize / 2);
                            ctx.fillText(emoji, x + obstacle.blockSize / 2, y + obstacle.blockSize / 2);

                        }
                    }
                }
            }
        }

        // Check for collisions
        function checkCollisions() {
            // ðŸš€ Adjusted hitbox: slightly smaller than the visible ship
            const shipHitbox = {
                left: shipX + 10,  // Offset for better accuracy
                right: shipX + shipWidth - 10,
                top: shipY + 5,
                bottom: shipY + shipHeight - 5
            };

            // âœ… Check collision with the Boss
            if (bossActive && currentBoss) {
                if (currentBoss.name === "circular") {
                    // Loop through 5 orbiting emojis
                    for (let i = 0; i < 5; i++) {
                        let angle = bossAngle + (i * (Math.PI * 2 / 5));
                        let bossX = currentBoss.x + Math.cos(angle) * bossRadius;
                        let bossY = currentBoss.y + Math.sin(angle) * bossRadius;
                        let bossSize = currentBoss.size * 0.7; // Adjust size for better collision

                        // âœ… Collision check
                        if (
                            shipHitbox.right > bossX - bossSize / 2 &&
                            shipHitbox.left < bossX + bossSize / 2 &&
                            shipHitbox.bottom > bossY - bossSize / 2 &&
                            shipHitbox.top < bossY + bossSize / 2
                        ) {
                            mana -= 0.5; // Lose mana upon collision
                            if (mana <= 0) {
                                loseLife(); // If mana runs out, lose a life
                            }
                            updateManaBar();
                            playSound('scratching'); // Add a sound effect for damage
                            return;
                        }
                    }
                } else if (currentBoss.name === "still") {
                    // Boss is one big emoji
                    let bossSize = currentBoss.size * 3;
                    let bossX = currentBoss.x;
                    let bossY = currentBoss.y;

                    // âœ… Collision check for still boss
                    if (
                        shipHitbox.right > bossX - bossSize / 2 &&
                        shipHitbox.left < bossX + bossSize / 2 &&
                        shipHitbox.bottom > bossY - bossSize / 2 &&
                        shipHitbox.top < bossY + bossSize / 2
                    ) {
                        mana -= 0.5; // Lose mana upon collision
                        if (mana <= 0) {
                            loseLife();
                        }
                        updateManaBar();
                        playSound('scratching');
                    }
                }
            }

            for (let i = bossRays.length - 1; i >= 0; i--) {
                let ray = bossRays[i];

                if (
                    ray.x > shipHitbox.left &&
                    ray.x < shipHitbox.right &&
                    ray.y > shipHitbox.top &&
                    ray.y < shipHitbox.bottom
                ) {
                    mana -= 2; // Lose mana
                    if (mana <= 0) {
                        loseLife();
                    }
                    updateManaBar();
                    playSound('scratching');
                    bossRays.splice(i, 1); // Remove the ray
                }
            }

            // âœ… **Check obstacle collisions**
            for (const obstacle of obstacles) {
                if (obstacle.type === "emoji-block") {
                    for (let row = 0; row < obstacle.rows; row++) {
                        for (let col = 0; col < obstacle.pattern[row].length; col++) {
                            const emoji = obstacle.pattern[row][col];
                            if (emoji === "") continue; // Skip empty spaces

                            // More precise obstacle hitbox
                            const emojiHitbox = {
                                left: obstacle.x + col * obstacle.blockSize + 5,  // Reduce width sensitivity
                                right: obstacle.x + (col + 1) * obstacle.blockSize - 5,
                                top: obstacle.y + row * obstacle.blockSize + 5,   // Reduce height sensitivity
                                bottom: obstacle.y + (row + 1) * obstacle.blockSize - 5
                            };

                            // **Collision detection (Fixed)**
                            if (
                                !invincible &&
                                shipHitbox.right > emojiHitbox.left &&
                                shipHitbox.left < emojiHitbox.right &&
                                shipHitbox.bottom > emojiHitbox.top &&
                                shipHitbox.top < emojiHitbox.bottom
                            ) {
                                mana -= .3;
                                if (mana > .3) {
                                    playSound('scratching')
                                }
                                updateManaBar();
                                shipFlicker = true;
                                return;
                            }
                        }
                    }
                }

                // âœ… **Check if obstacle has been passed (increase score)**
                if (!obstacle.passed && shipX > obstacle.x + obstacle.width) {
                    obstacle.passed = true;
                    score++;
                    obstacleSpeed += 0.04; // Gradual difficulty increase
                }
            }

            // âœ… **Check for collectible pickups**
            for (let i = activeCollectibles.length - 1; i >= 0; i--) {
                const item = activeCollectibles[i];

                // Define the hitbox for the collectible item
                const itemHitbox = {
                    left: item.x - item.size / 2,
                    right: item.x + item.size / 2,
                    top: item.y - item.size / 2,
                    bottom: item.y + item.size / 2
                };

                // **Collision detection with the ship**
                if (
                    shipHitbox.right > itemHitbox.left &&
                    shipHitbox.left < itemHitbox.right &&
                    shipHitbox.bottom > itemHitbox.top &&
                    shipHitbox.top < itemHitbox.bottom
                ) {
                    playSound("collect");
                    score += item.points;

                    inventory[item.emoji]++;
                    activeCollectibles.splice(i, 1); // Remove collected item
                    updateInventoryDisplay();
                    checkLifeGain(); // âœ… Check if an extra life should be given

                    // **Apply effects**
                    if (item.emoji === "ðŸ’€") {
                        invincible = true;
                        invincibleTimer = 2500;
                        playSound("shield");

                        // âœ¨ Boost the ship glow when collecting a drop
                        shipGlow.radius = 35; // Temporarily increase glow
                        setTimeout(() => { shipGlow.radius = 20; }, 500); // Reset after 500ms
                    }

                    if (item.emoji === "ðŸŒ") {
                        slowDownTime();
                    }

                    if (item.emoji === "ðŸŒª") {
                        speedUpTime();
                    }

                    if (item.emoji === "ðŸ”«") {
                        inventory["ðŸ”«"]++;
                        armor += 10; // Increase armor
                        updateArmorBar();
                        updateInventoryDisplay();
                    }

                    if (item.emoji === "ðŸ’©") {
                        currentAcceleration = slowAcceleration;
                        slowMovementTimer = 1500;
                    }

                    if (item.emoji === "ðŸ”‹") {
                        mana = Math.min(mana + 30, maxMana); // Recupera 30 de mana sem ultrapassar o mÃ¡ximo
                        updateManaBar();
                    }

                    if (item.emoji === "â˜¢ï¸") {
                        explodeAllObstacles();
                    }
                }
            }
        }

        function slowDownTime() {
            obstacleSpeed *= 0.5; // Slow down time (reduce speed by half)
            backgroundSpeed *= .5;

            // Restore speed after 5 seconds
            setTimeout(() => {
            }, 5000);
        }

        function speedUpTime() {
            obstacleSpeed *= 1.3; // Slow down time (reduce speed by half)
            backgroundSpeed *= 1.3;

            // Restore speed after 5 seconds
            setTimeout(() => {
            }, 5000);
        }

        function explodeAllObstacles() {
            if (obstacles.length === 0) return;

            playSound("explosionAll");

            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obstacle = obstacles[i];

                // Get obstacle position and size
                let explosionX = obstacle.x + obstacle.width / 2;
                let explosionY = obstacle.y + obstacle.height / 2;

                // Create explosion effect
                createExplosion(explosionX, explosionY);

                // Remove obstacle from game
                obstacles.splice(i, 1);
            }

        }

        function loseLife() {
            if (isHit) return; // Prevent multiple hits in a short time
            isHit = true;
            isExploding = true; // ðŸš¨ Set exploding state to keep rendering

            playSound("explosion");

            lives--; // Subtract 1 life

            createExplosion(shipX + shipWidth / 2, shipY + shipHeight / 2); // Generate explosion effect

            // **Stop ship movement, obstacles, but keep explosion running**
            shipVelocity = 0;
            shipXVelocity = 0;
            mana = 0;

            setTimeout(() => {
                isExploding = false; // Stop explosion effect after delay
                if (lives > 0) {
                    playSound("risada");
                    restartAfterHit();
                } else {
                    gameOver = true;
                    playSound("gameover");
                    gameOverScreen.style.display = 'flex';
                    gameOverScreen.style.fontSize = 40;
                    gameOverScoreDisplay.textContent = `${score}`;
                }

                mana = maxMana; // Reseta a mana ao perder uma vida
                armor = 0; // Reset armor
                inventory["ðŸ”«"] = 0;
                updateInventoryDisplay()
                updateArmorBar()
                updateManaBar();

            }, 2000); // 2-second delay before restarting
        }

        function restartAfterHit() {

            // Reset explosion state
            isHit = false;
            isExploding = false;

            // Reset ship position and movement
            shipY = canvas.height / 2;
            shipVelocity = 0;
            shipX = canvas.width * 0.2;
            shipXVelocity = 0;

            // Restore obstacle movement
            // obstacleSpeed = .4;

            // Temporary invincibility after hit
            invincible = true;
            invincibleTimer = 600;

            inventory['ðŸ”«'] = 0

            canShoot = false;
            shootTimer = 0;
        }

        // Handle keyboard input
        const keys = {};


        let touchStartX = null;
        let touchStartY = null;
        let touchStartTime = null;
        let isMoving = false; // Track if the user is swiping or tapping

        window.addEventListener("touchstart", (e) => {
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                touchStartTime = Date.now();
                isMoving = false; // Reset movement state
            }
        });

        window.addEventListener("touchmove", (e) => {
            if (touchStartX === null || touchStartY === null) return;

            let touchX = e.touches[0].clientX;
            let touchY = e.touches[0].clientY;
            let deltaX = touchX - touchStartX;
            let deltaY = touchY - touchStartY;

            let movementThreshold = 10; // Lower threshold for smoother control
            let adjustedTouchSensitivity = currentAcceleration * 20; // Adjust movement strength

            // **Detect swipe movement in both directions**
            if (Math.abs(deltaX) > movementThreshold || Math.abs(deltaY) > movementThreshold) {
                isMoving = true; // Mark as a movement (not a tap)

                // **Allow diagonal movement naturally**
                shipXVelocity += (deltaX * adjustedTouchSensitivity) * 0.02;
                shipVelocity += (deltaY * adjustedTouchSensitivity) * 0.08;

                // **Update last touch position for smoother movement**
                touchStartX = touchX;
                touchStartY = touchY;
            }
        });

        window.addEventListener("touchend", (e) => {
            if (touchStartX === null || touchStartY === null) return;

            let touchEndX = e.changedTouches[0].clientX;
            let touchEndY = e.changedTouches[0].clientY;
            let touchEndTime = Date.now();

            let deltaX = touchEndX - touchStartX;
            let deltaY = touchEndY - touchStartY;
            let timeDiff = touchEndTime - touchStartTime;

            let tapThreshold = 120; // Max time for a tap (milliseconds)
            let minMovement = 20; // Ignore very small accidental movements

            // **Detect a tap (not a swipe) â†’ SHOOT**
            if (!isMoving && timeDiff < tapThreshold && Math.abs(deltaX) < minMovement && Math.abs(deltaY) < minMovement) {
                shoot();
            }

            // Reset touch tracking
            touchStartX = null;
            touchStartY = null;
            touchStartTime = null;
        });


        window.addEventListener('keydown', e => {
            keys[e.key] = true;
        });
        window.addEventListener('keyup', e => {
            keys[e.key] = false;
        });
        window.addEventListener("keydown", (e) => {
            if (e.key === " " || e.code === "Space") {
                shoot();
            }
        });

        function handleInput() {
            if (keys['w'] || keys['W'] || keys['ArrowUp']) {
                shipVelocity -= currentAcceleration * 4;
            }
            if (keys['s'] || keys['S'] || keys['ArrowDown']) {
                shipVelocity += currentAcceleration * 2;
            }
            if (keys['a'] || keys['A'] || keys['ArrowLeft']) {
                shipXVelocity -= currentAcceleration * 1.2;
            }
            if (keys['d'] || keys['D'] || keys['ArrowRight']) {
                shipXVelocity += currentAcceleration;
            }
        }

        // Update game state
        let nextCollectibleTime = gameTime + Math.floor(Math.random() * 500) + 300; // Initial random delay

        function updateGame() {
            if (!gameStarted || gameOver || isHit) return;

            gameTime++;
            handleInput();

            if (invincible) {
                invincibleTimer--;
                if (invincibleTimer <= 0) {
                    invincible = false;
                }
            }

            let speedFactor = isMobile ? 0.5 : 1.0;

            // Move ship vertically
            shipVelocity += gravity;
            shipVelocity *= 0.6;
            shipY += shipVelocity;

            // Limit ship velocity
            if (shipVelocity > 10) shipVelocity = 10;
            if (shipVelocity < -10) shipVelocity = -10;

            // Apply friction to smooth horizontal movement
            shipXVelocity *= shipFriction;
            shipX += shipXVelocity;

            // Prevent out-of-bounds movement
            if (shipX < 0) shipX = 0;
            if (shipX > canvas.width - shipWidth) shipX = canvas.width - shipWidth;
            if (shipY < ceilingLevel) shipY = ceilingLevel;
            if (shipY > groundLevel - shipHeight) shipY = groundLevel - shipHeight;

            // Add ship trail particles
            if (gameTime % 2 === 0) {
                createShipTrail();
            }

            updateStalactites();

            if (gameTime >= nextStalactiteTime) {
                createStalactite();
                nextStalactiteTime = gameTime + Math.floor(Math.random() * 1000) + 800; // Next spawn in 800-1800 frames
            }

             // ðŸš€ **Check High Speed for Ghost Sound Effect**
            if (obstacleSpeed > fastSpeedThreshold) {
                playSound("ghost");
            }

            updateParticles();

            if (bossActive && gameTime - lastBossShotTime > bossShootInterval) {
                console.log("Boss atirando rays!"); // ðŸ” Verificar se estÃ¡ chamando
                spawnBossRays();
                lastBossShotTime = gameTime;
            }

            updateBossRays();

            // Move obstacles using `obstacleSpeed`
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].x -= obstacleSpeed;
                if (obstacles[i].x < -obstacles[i].width) {
                    obstacles.splice(i, 1);
                }
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].x -= obstacleSpeed;
                if (obstacles[i].x < -obstacles[i].width) {
                    obstacles.splice(i, 1);
                    obstaclesPassed++;
                    if (obstaclesPassed % 10 == 0) {
                        spawnBoss();
                    }
                }
            }

            // Move collectibles using `obstacleSpeed`
            for (let i = activeCollectibles.length - 1; i >= 0; i--) {
                activeCollectibles[i].x -= obstacleSpeed;
                if (activeCollectibles[i].x < -50) {
                    activeCollectibles.splice(i, 1);
                }
            }

            // Spawn collectibles occasionally
            if (gameTime >= nextCollectibleTime) {
                createCollectible();
                nextCollectibleTime = gameTime + Math.floor(Math.random() * 500) + 300; // Set next spawn
            }


            // Adjust the spawn frequency based on obstacle speed
            let obstacleSpawnRate = Math.max(80, 200 - obstacleSpeed * 20);
            // Faster speed = more frequent obstacles, but never less than 80 frames apart

            // Spawn obstacles dynamically
            if (gameTime - lastObstacleTime > obstacleSpawnRate) {
                createObstacle();
                lastObstacleTime = gameTime;
            }

            // Reduce shooting timer
            if (canShoot && shootTimer > 0) {
                shootTimer--;
                if (shootTimer <= 0) {
                    canShoot = false;
                }
            }

            if (slowMovementTimer > 0) {
                slowMovementTimer--;
                if (slowMovementTimer <= 0) {
                    currentAcceleration = normalAcceleration;
                }
            }

            checkCollisions();

            // Update UI
            scoreDisplay.innerHTML = `Score\n${score}`;
            document.getElementById('lives').innerHTML = `â¤ï¸ ${lives}`;
        }


        // Main draw function
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawBackground();   // Background first
            drawObstacles();    // Obstacles
            drawStalactites();
            drawParticles();    // Ship trail
            drawCollectibles();

            if (!isHit) drawShip();  // Ship unless hit
            drawBoss();
            drawBossRays();

            drawBullets();      // Bullets
            drawLaser();        // Laser after ship and obstacles
            drawExplosion();    // Explosions on top

            drawGroundAndCeiling(); // Ground and ceiling last
        }

        function updateInventoryDisplay() {
            const inventoryDisplay = document.getElementById('inventory');
            inventoryDisplay.innerHTML = `
                ðŸ’€ ${inventory["ðŸ’€"]}
                ðŸ’© ${inventory["ðŸ’©"]}
                ðŸ”« ${inventory["ðŸ”«"]}
                ðŸŒ ${inventory["ðŸŒ"]}
                â˜¢ï¸ ${inventory["â˜¢ï¸"]}`
        }

        function gameLoop() {
            if (!gameOver) {
                if (!isExploding) {
                    updateGame();
                    updateShooting();
                }
                updateExplosion();
            }

            draw(); // All drawing happens here

            requestAnimationFrame(gameLoop);
        }

        // Start the game
        startButton.addEventListener('click', () => {
            if (isMobile) requestFullScreen();
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none'; // Hide Game Over screen if visible
            gameStarted = true;
            startMusic();
            createBackgroundLayers();
            gameLoop();
        });

        // Restart the game
        restartButton.addEventListener('click', () => {

            // Stop any ongoing animations
            cancelAnimationFrame(gameLoop);

            // Hide game over screen
            gameOverScreen.style.display = 'none';

            // Reset game state
            gameStarted = true;
            gameOver = false;
            isExploding = false;  // Ensure ship is not "exploding"
            isHit = false;        // Prevent blinking effect
            flickerCount = 0;

            // Reset ship position and movement
            shipY = canvas.height / 2;
            shipX = canvas.width * 0.2;
            shipVelocity = 0;
            shipXVelocity = 0;

            backgroundSpeed = 5;
            obstacleSpeed = 1;

            // Reset obstacles, collectibles, and inventory
            obstacles = [];
            activeCollectibles = [];
            let inventory = { "ðŸ’€": 0, "ðŸ’©": 0, "ðŸ”«": 0, "ðŸŒ": 0, "â˜¢ï¸": 0 };

            // Reset timers and speeds
            lastObstacleTime = 0;
            gameTime = 0;
            lives = 5;
            invincible = false;
            invincibleTimer = 0;

            // Reset UI
            score = 0;
            scoreDisplay.textContent = `Score\n${score}`;
            document.getElementById('lives').innerHTML = `â¤ï¸ ${lives}`;
            updateInventoryDisplay();

            // Reset background and start fresh
            createBackgroundLayers();

            // Restart the game loop
            requestAnimationFrame(gameLoop);
        });

        function checkLifeGain() {
            let inventorySum = Object.values(inventory).reduce((sum, value) => sum + value, 0);

            if (inventorySum > 0 && inventorySum % 15 === 0) {
                lives++;
                playSound('life')
                document.getElementById('lives').innerHTML = `â¤ï¸ ${lives}`;
            }
        }

        // Handle game over
        function handleGameOver() {
            if (gameOver) {
                gameOverScreen.style.display = 'flex';
                gameOverScreen.style.fontSize = 40;
                gameOverScoreDisplay.textContent = score;
            }
        }

        window.addEventListener("load", () => {
            document.body.addEventListener("click", function playStartupSound() {
                playSound('music1')
                playSound('startup')
                document.body.removeEventListener("click", playStartupSound); // Remove listener after playing
            });
        });

        // Set up resize handler
        window.addEventListener('resize', () => {
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                groundLevel = canvas.height * 0.8;
                ceilingLevel = canvas.height * 0.2;

                if (/iPhone|iPad|Android|Mobile/i.test(navigator.userAgent)) {
                    groundLevel = canvas.height * 0.95;
                    ceilingLevel = canvas.height * 0.15;
                } else {
                    groundLevel = canvas.height * 0.9;
                    ceilingLevel = canvas.height * 0.1;
                }

                shipY = canvas.height / 2;
                gravity = /iPhone|iPad|Android|Mobile/i.test(navigator.userAgent) ? mobileGravity : normalGravity;
            }

            // Resize once on load & listen for screen changes
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            groundLevel = canvas.height * 0.8;
            ceilingLevel = canvas.height * 0.2;
            shipY = canvas.height / 2;
        });

        // ðŸ“± Function to enable Fullscreen on mobile
        function requestFullScreen() {
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
            } else if (document.documentElement.mozRequestFullScreen) {
                document.documentElement.mozRequestFullScreen();
            } else if (document.documentElement.webkitRequestFullscreen) {
                document.documentElement.webkitRequestFullscreen();
            } else if (document.documentElement.msRequestFullscreen) {
                document.documentElement.msRequestFullscreen();
            }
        }

        // Start animation
        gameLoop();
    </script>
</body>
</html>