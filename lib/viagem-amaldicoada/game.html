<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0">
    <title>Viagem amaldiçoada</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', monospace;
            color: #8a0303;
        }

        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            touch-action: none; /* Prevent touch scrolling */
        }


        canvas {
            display: block;
            background: linear-gradient(to bottom, #0a0a0a, #1a0707);
            height: 100vh;
        }

        #game-container {
            position: absolute;
            width: 100vw;
            height: 100vh; /* This will be corrected by JS */
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        h1 {
            color: #8a0303;
            font-size: 1.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000; }
            50% { text-shadow: 0 0 15px #ff0000, 0 0 30px #ff0000; }
            100% { text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000; }
        }

        button {
            padding: 15px 30px;
            font-size: 1em;
            border: 2px solid #8a0303;
            background-color: #1a0707;
            color: #8a0303;
            cursor: pointer;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }

        button:hover {
            background-color: #8a0303;
            color: #000;
            transform: scale(1.05);
        }

        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1em;
            z-index: 5;
        }

        #game-over-score {
            font-size: 2em;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="score">Score: 0</div>
        <div id="inventory" style="
            position: absolute;
            top: 35px;
            left: 20px;
            font-size: .8em;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;">
        </div>
        <div id="lives" style="
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: .8em;
            color: white;
            z-index: 5;">
        </div>

        <div id="start-screen">
            <h1>VIAGEM AMALDIÇOADA</h1>
            <button id="start-button">PREPARE-SE PARA PERDER</button>
        </div>

        <div id="game-over-screen" style="display: none;">
            <h1>GAME OVER</h1>
            <div id="game-over-score"></div>
            <button id="restart-button">VAI TENTAR NEH</button>
        </div>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const gameOverScoreDisplay = document.getElementById('game-over-score');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');

        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game state
        const isMobile = /iPhone|iPad|Android|Mobile/i.test(navigator.userAgent);

        let gameStarted = false;
        let gameOver = false;
        let score = 0;
        let shipY = canvas.height / 2;
        let shipVelocity = 0;
        let backgroundSpeed = 5; // Independent background scrolling speed
        let obstacleSpeed = 1;    // Independent obstacle movement speed
        let obstacles = [];
        let groundLevel = canvas.height * 0.9;
        let ceilingLevel = canvas.height * 0.1;
        let lastObstacleTime = 0;
        let gameTime = 0;
        let isExploding = false;
        let shipFlicker = false;
        let flickerCount = 0;
        let shipXVelocity = 0; // Horizontal velocity
        const shipAcceleration = 0.3; // How fast the ship moves
        const shipFriction = 0.9; // Friction effect to smooth movement

        let lives = 5; // Ship starts with 3 lives
        let isHit = false; // To track ship blinking effect
        let hitTimer = 0;  // Timer for blinking animation

        const normalGravity = 0.3;
        const mobileGravity = 0.15; // 🔽 Lower gravity for mobile
        let gravity = isMobile ? mobileGravity : normalGravity;

        // Ship properties
        const shipWidth = 80;
        const shipHeight = 40;
        let shipX = canvas.width * 0.2;

        // Create a ship glow effect
        const shipGlow = {
            radius: 20,
            opacity: 0.5,
            color: '#8a0303'
        };

        // Images for backgrounds and effects
        const bgLayers = [];
        const numLayers = 3;
        let bgReady = false;

        // Define obstacle patterns with emojis
        // Define emoji obstacle shapes
        const emojiShapes = [
        { // Triangle of Thumbs Up 🤡
            pattern: [
                ["", "", "🤡", "", ""],
                ["", "🤡", "🤡", "🤡", ""],
                ["🤡", "🤡", "🤡", "🤡", "🤡"]
            ],
            type: "triangle"
        },
        { // Square of Poop 👾
            pattern: [
                ["👾", "👾", "👾"],
                ["👾", "👾", "👾"],
                ["👾", "👾", "👾"]
            ],
            type: "square"
        },
        { // Diamond (Losango) of Hearts 👽
            pattern: [
                ["", "", "👽", "", ""],
                ["", "👽", "👽", "👽", ""],
                ["👽", "👽", "👽", "👽", "👽"],
                ["", "👽", "👽", "👽", ""],
                ["", "", "👽", "", ""]
            ],
            type: "diamond"
        },
        {
            pattern: [
                ["🥚", "🥚", "🥚"],
                ["🥚", "🥚", "🥚"],
                ["🥚", "🥚", "🥚"],
                ["🥚", "🥚", "🥚"],
                ["🥚", "🥚", "🥚"],
                ["🥚", "🥚", "🥚"],
            ],
            type: "eggs"
        },
        {
            pattern: [
                ["",   "", "🐍"],
                ["",   "🐍", ""],
                ["🐍", "🐍", ""],
                ["🐍", "🐍", ""],
                ["",   "🐍", ""],
                ["",   "", "🐍"],
            ],
            type: "eggs"
        },
        {
            pattern: [
                ["🦴","🦴", "🦴", "🦴"],
                ["🦴","🦴", "🦴", "🦴"],
                ["","", "🦴", "🦴"],
                ["","", "🦴", "🦴"],
                ["","", "🦴", "🦴"],
                ["🦴","🦴", "🦴", "🦴"],
                ["🦴","🦴", "🦴", "🦴"],

            ],
            type: "eggs"
        }
        ];

        // Define collectible items
        const collectibles = [
        { emoji: "💧", name: "red drop", points: 5 },
        { emoji: "💎", name: "ring", points: 10 },
        { emoji: "🥥", name: "coconut", points: 15 },
        { emoji: "⏳", name: "time", points: 10 }
        ];

        let inventory = { "💧": 0, "💎": 0, "🥥": 0, "⏳": 0 };

        const sounds = {
            music1: new Audio("background-layer-0.mp3"),  // Background music
            music2: new Audio("background-layer-1.mp3"),  // Background music
            music3: new Audio("background-layer-2.mp3"),  // Background music
            risada: new Audio("risada-do-mal.mp3"),  // Background music
            ghost: new Audio("ghost.mp3"),  // Background music
            effects: new Audio("background-layer-.mp3"),  // Background music
            shoot: new Audio("shoot.mp3"),  // Shooting sound
            explosion: new Audio("collision.mp3"), // Explosion sound
            collect: new Audio("collect.mp3"), // Collectible sound
            gameover: new Audio("gameover.mp3") // Game over sound
        };

        // 🎵 Configure Looping & Volume
        sounds.music1.loop = true;
        sounds.music1.volume = 0.3; // Adjust volume as needed
        sounds.music2.loop = true;
        sounds.music2.volume = 0.2; // Adjust volume as needed
        sounds.music3.loop = true;
        sounds.music3.volume = 0.4; // Adjust volume as needed

        // 🚀 Play Background Music when the game starts
        function startMusic() {
            sounds.music1.play();
            sounds.music2.play();
            sounds.music3.play();
        }

        // 🔫 Play Sound Effects
        function playSound(sound) {
            if (sounds[sound]) {
                sounds[sound].currentTime = 0; // Reset to allow rapid triggers
                sounds[sound].play();
            }
        }

        let invincible = false;
        let invincibleTimer = 0;

        let bullets = [];
        let canShoot = false; // Starts as false, enabled when a coconut is collected
        const bulletSpeed = 10;
        const bulletSize = 8;
        let shootTimer = 0;

        let normalAcceleration = 0.3; // Default acceleration
        let slowAcceleration = 0.1;   // Reduced acceleration when diamond is active
        let currentAcceleration = normalAcceleration; // Track current acceleration

        let slowMovementTimer = 0; // Timer for slow effect
        // List of collectible objects in the game
        let activeCollectibles = [];

        // Shoot function
        function shootBullet() {
            if (canShoot) {
                bullets.push({
                    x: shipX + shipWidth,
                    y: shipY + shipHeight / 2,
                    size: bulletSize,
                });
                playSound("shoot");
            }
        }

        // Update bullets
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].x += bulletSpeed;

                // Remove bullet if it goes off-screen
                if (bullets[i].x > canvas.width) {
                    bullets.splice(i, 1);
                    continue;
                }

                // Check collision with obstacles
                for (let j = obstacles.length - 1; j >= 0; j--) {
                    let obstacle = obstacles[j];

                    if (obstacle.type === "emoji-block") {
                        for (let row = 0; row < obstacle.rows; row++) {
                            for (let col = 0; col < obstacle.pattern[row].length; col++) {
                                let emoji = obstacle.pattern[row][col];
                                if (emoji === "") continue;

                                let emojiX = obstacle.x + col * obstacle.blockSize;
                                let emojiY = obstacle.y + row * obstacle.blockSize;

                                // Bullet hitbox
                                if (
                                    bullets[i].x + bullets[i].size > emojiX &&
                                    bullets[i].x < emojiX + obstacle.blockSize &&
                                    bullets[i].y > emojiY &&
                                    bullets[i].y < emojiY + obstacle.blockSize
                                ) {
                                    console.log(`🔥 Bullet destroyed ${emoji}`);
                                    obstacle.pattern[row][col] = ""; // Remove emoji
                                    bullets.splice(i, 1); // Remove bullet
                                    score += 1
                                    return;
                                }
                            }
                        }
                    }
                }
            }
        }

        // Draw bullets
        function drawBullets() {
            ctx.fillStyle = "yellow";
            for (let bullet of bullets) {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Create background layers
        function createBackgroundLayers() {
            for (let i = 0; i < numLayers; i++) {
                const layer = {
                    x: 0,
                    speed: 0.3 + i * 0.3, // Different speeds for parallax effect
                    clouds: []
                };

                const numObjects = 5 + Math.floor(Math.random() * 20); // Random number of objects

                for (let j = 0; j < numObjects; j++) {
                    const type = Math.random() > 0.7 ? "planet" : "star"; // 30% chance for a planet
                    const depth = 0.1 + Math.random() * 0.3; // Depth factor between 0.3 and 1.0

                    layer.clouds.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        width: type === "planet" ? 60 + Math.random() * 140 : 4 + Math.random() * 6,
                        height: type === "planet" ? 60 + Math.random() * 140 : 4 + Math.random() * 6,
                        opacity: type === "star" ? (0.5 + Math.random() * 1) : .1,
                        color: type === "planet" ? ["#ffcc00", "#ff5500", "#0099ff", "#00ff66", "#ff66ff"][Math.floor(Math.random() * 5)] : "white",
                        type: type,
                        depth: depth // Assign depth for parallax effect
                    });
                }

                bgLayers.push(layer);
            }
            bgReady = true;
        }

        const explosionParticles = [];

        function createExplosion(x, y) {
            for (let i = 0; i < 40; i++) { // More particles for a bigger explosion
                explosionParticles.push({
                    x: x,
                    y: y,
                    size: 4 + Math.random() * 6,
                    speedX: (Math.random() - 0.5) * 8,
                    speedY: (Math.random() - 0.5) * 8,
                    life: 40 + Math.random() * 20,
                    color: `rgba(255, ${50 + Math.random() * 150}, 0, 1)` // Red-Orange explosion
                });
            }
        }

        function updateExplosion() {
            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                let p = explosionParticles[i];
                p.x += p.speedX;
                p.y += p.speedY;
                p.life--;
                if (p.life <= 0) explosionParticles.splice(i, 1); // Remove finished particles
            }
        }

        function drawExplosion() {
            for (const p of explosionParticles) {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }


        // Particles system for effects
        const particles = [];

        function createShipTrail() {
            particles.push({
                x: shipX,
                y: shipY + shipHeight / 2,
                size: 2 + Math.random() * 6,
                speedX: -1 - Math.random() * 2,
                speedY: (Math.random() - 0.5) * 2,
                life: 30 + Math.random() * 20,
                color: `rgba(${138 + Math.random() * 50}, ${3 + Math.random() * 20}, ${3 + Math.random() * 20}, ${0.3 + Math.random() * 0.5})`
            });
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.speedX;
                p.y += p.speedY;
                p.life--;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life / 50;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });
        }

        // Draw background layers
        function drawBackground() {
            if (!bgReady) return;

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (const layer of bgLayers) {
                layer.x -= backgroundSpeed * layer.speed; // Use `backgroundSpeed`
                if (layer.x < -canvas.width) {
                    layer.x = 0;
                }

                for (const obj of layer.clouds) {
                    obj.x -= backgroundSpeed * obj.depth; // Background scrolls separately
                    if (obj.x < -obj.width) {
                        obj.x = canvas.width + Math.random() * 100;
                        obj.y = Math.random() * canvas.height;
                    }

                    let adjustedOpacity = obj.opacity * obj.depth;

                    if (obj.type === "star") {
                        ctx.fillStyle = `rgba(255, 255, 255, ${adjustedOpacity})`;
                        ctx.beginPath();
                        ctx.arc(obj.x, obj.y, obj.width / 6, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (obj.type === "planet") {
                        ctx.fillStyle = obj.color;
                        ctx.globalAlpha = adjustedOpacity;
                        ctx.beginPath();
                        ctx.arc(obj.x, obj.y, obj.width / 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }
                }
            }
        }



        function drawCollectibles() {
            ctx.font = "20px Arial";  // Increased font size for visibility
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            for (const item of activeCollectibles) {
                if (!item.collected) {
                    ctx.fillStyle = "white"; // Ensure high contrast for visibility
                    ctx.fillText(item.emoji, item.x, item.y);
                }
            }
        }

        // Draw the ship with a glow effect
        function drawShip() {
            if (isExploding) return;
            if (isHit && shipFlicker) {
                flickerCount++;
                if (flickerCount % 6 < 3) {
                    isHit = false;
                    return;
                }
            }

            // 🚀 **Define Armor Colors**
            let shipBaseColor = canShoot ? "#444" : "#8B0000"; // Gunmetal Gray when armed
            let armorBorderColor = canShoot ? "#AAA" : "#FF6347"; // Brighter outline
            let energyColor = canShoot ? "cyan" : "red"; // Blue glow when armed

            // 🌟 **Ship Glow Effect**
            ctx.beginPath();
            ctx.arc(shipX + shipWidth / 2, shipY + shipHeight / 2, shipGlow.radius, 0, Math.PI * 2);
            const glowGradient = ctx.createRadialGradient(
                shipX + shipWidth / 2, shipY + shipHeight / 2, 0,
                shipX + shipWidth / 2, shipY + shipHeight / 2, shipGlow.radius
            );
            glowGradient.addColorStop(0, `rgba(${canShoot ? '0,255,255' : '255,50,50'}, 0.8)`);
            glowGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
            ctx.fillStyle = glowGradient;
            ctx.fill();

            // 🚀 **Main Ship Body**
            ctx.fillStyle = shipBaseColor;
            ctx.strokeStyle = armorBorderColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(shipX, shipY + shipHeight / 2);
            ctx.lineTo(shipX + shipWidth * 0.3, shipY + shipHeight * 0.2);
            ctx.lineTo(shipX + shipWidth * 0.8, shipY + shipHeight * 0.2);
            ctx.lineTo(shipX + shipWidth, shipY + shipHeight / 2);
            ctx.lineTo(shipX + shipWidth * 0.8, shipY + shipHeight * 0.8);
            ctx.lineTo(shipX + shipWidth * 0.3, shipY + shipHeight * 0.8);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // 🛡️ **Armor Plating (Metallic Highlights)**
            ctx.strokeStyle = "#DDD"; // Light metallic effect
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(shipX + shipWidth * 0.3, shipY + shipHeight * 0.2);
            ctx.lineTo(shipX + shipWidth * 0.3, shipY + shipHeight * 0.8);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(shipX + shipWidth * 0.6, shipY + shipHeight * 0.3);
            ctx.lineTo(shipX + shipWidth * 0.6, shipY + shipHeight * 0.7);
            ctx.stroke();

            // 🔥 **Energy Core (Glowing Center)**
            let coreGradient = ctx.createRadialGradient(
                shipX + shipWidth * 0.45, shipY + shipHeight * 0.5, 0,
                shipX + shipWidth * 0.45, shipY + shipHeight * 0.5, shipHeight * 0.15
            );
            coreGradient.addColorStop(0, "white");
            coreGradient.addColorStop(1, energyColor);
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(shipX + shipWidth * 0.45, shipY + shipHeight * 0.5, shipHeight * 0.15, 0, Math.PI * 2);
            ctx.fill();

            // **EXTRA ARMOR (When Shooting is Enabled)**
            if (canShoot) {
                ctx.fillStyle = "#666"; // Darker metallic armor
                ctx.strokeStyle = "#BBB";
                ctx.lineWidth = 2;

                // **Side Armor**
                ctx.fillRect(shipX + 5, shipY + 5, 15, shipHeight - 10);
                ctx.fillRect(shipX + shipWidth - 20, shipY + 5, 15, shipHeight - 10);

                // **Side Cannons**
                ctx.fillStyle = "#333";
                ctx.fillRect(shipX + shipWidth * 0.1, shipY + shipHeight * 0.2, 10, 20);
                ctx.fillRect(shipX + shipWidth * 0.1, shipY + shipHeight * 0.6, 10, 20);
                ctx.fillRect(shipX + shipWidth * 0.9 - 10, shipY + shipHeight * 0.2, 10, 20);
                ctx.fillRect(shipX + shipWidth * 0.9 - 10, shipY + shipHeight * 0.6, 10, 20);

                // **Glowing Vents & Weapon Ports**
                ctx.fillStyle = "rgba(0, 255, 255, 0.7)";
                ctx.fillRect(shipX + shipWidth * 0.35, shipY + shipHeight * 0.1, 8, 4);
                ctx.fillRect(shipX + shipWidth * 0.35, shipY + shipHeight * 0.85, 8, 4);
                ctx.fillRect(shipX + shipWidth * 0.6, shipY + shipHeight * 0.1, 8, 4);
                ctx.fillRect(shipX + shipWidth * 0.6, shipY + shipHeight * 0.85, 8, 4);
            }
        }


        // Create obstacles: ground spikes and ceiling spikes
        function createObstacle() {
            const isEmojiBlock = Math.random() > 0.5; // 50% chance to generate emoji obstacles

            // Calculate possible spawn points to prevent overlap
            const numSections = 5; // Divide screen height into 5 sections
            const sectionHeight = (groundLevel - ceilingLevel) / numSections;
            let availableSections = Array.from({ length: numSections }, (_, i) => i);

            const sectionIndex = availableSections.splice(
                Math.floor(Math.random() * availableSections.length),
                1
            )[0];

            let newObstacle;

            if (isEmojiBlock) {
                const shape = emojiShapes[Math.floor(Math.random() * emojiShapes.length)];
                const blockSize = 30;
                const numRows = shape.pattern.length;
                const numCols = shape.pattern[0].length;

                // **Deep copy the pattern** to prevent modifying the original
                const copiedPattern = shape.pattern.map(row => [...row]);

                newObstacle = {
                    type: "emoji-block",
                    x: canvas.width,
                    width: numCols * blockSize,
                    height: numRows * blockSize,
                    pattern: copiedPattern,  // Use copied pattern instead of reference
                    blockSize: blockSize,
                    rows: numRows,
                    isGroundObstacle: Math.random() > 0.5,
                    passed: false
                };

                newObstacle.y = ceilingLevel + sectionIndex * sectionHeight + (sectionHeight - newObstacle.height) / 2;
            } else {
                // Traditional spike obstacle
                const width = 40 + Math.random() * 40;
                const height = 80 + Math.random() * 120;

                newObstacle = {
                    type: "spike",
                    x: canvas.width,
                    width,
                    height,
                    isGroundObstacle: Math.random() > 0.5,
                    passed: false
                };

                newObstacle.y = ceilingLevel + sectionIndex * sectionHeight + (sectionHeight - height) / 2;
            }

            // Prevent obstacles from spawning too close together
            if (obstacles.length > 0) {
                const lastObstacle = obstacles[obstacles.length - 1];
                if (newObstacle.x - lastObstacle.x < 150) {
                    return; // Avoid spawning too close
                }
            }

            obstacles.push(newObstacle);
        }

        function createCollectible() {
            if (Math.random() > 0.8) return; // Only 20% chance to spawn a collectible

            const item = collectibles[Math.floor(Math.random() * collectibles.length)];
            const size = 20;
            const yPos = Math.random() * (groundLevel - ceilingLevel - size) + ceilingLevel;

            activeCollectibles.push({
                emoji: item.emoji,
                name: item.name,
                points: item.points,
                x: canvas.width,
                y: yPos,
                size: size,
                collected: false
            });
        }


        // Draw ground and ceiling
        function drawGroundAndCeiling() {
            // Draw ceiling
            const ceilingGradient = ctx.createLinearGradient(0, 0, 0, ceilingLevel);
            ceilingGradient.addColorStop(0, '#0a0a0a');
            ceilingGradient.addColorStop(1, '#350101');
            ctx.fillStyle = ceilingGradient;
            ctx.fillRect(0, 0, canvas.width, ceilingLevel);

            // Ceiling details
            for (let i = 0; i < canvas.width; i += 40) {
                const height = 10 + Math.sin(i * 0.05 + gameTime * 0.01) * 5;
                ctx.fillStyle = '#8a0303';
                ctx.beginPath();
                ctx.moveTo(i, ceilingLevel);
                ctx.lineTo(i + 20, ceilingLevel);
                ctx.lineTo(i + 10, ceilingLevel + height);
                ctx.closePath();
                ctx.fill();
            }

            // Draw ground
            const groundGradient = ctx.createLinearGradient(0, groundLevel, 0, canvas.height);
            groundGradient.addColorStop(0, '#350101');
            groundGradient.addColorStop(1, '#0a0a0a');
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, groundLevel, canvas.width, canvas.height - groundLevel);

            // Ground details
            for (let i = 0; i < canvas.width; i += 40) {
                const height = 10 + Math.sin(i * 0.03 + gameTime * 0.01) * 5;
                ctx.fillStyle = '#8a0303';
                ctx.beginPath();
                ctx.moveTo(i, groundLevel);
                ctx.lineTo(i + 20, groundLevel);
                ctx.lineTo(i + 10, groundLevel - height);
                ctx.closePath();
                ctx.fill();
            }
        }

        // Draw obstacles
        function drawObstacles() {
            for (const obstacle of obstacles) {
                if (obstacle.type === "emoji-block") {
                    // Draw emoji obstacles
                    for (let row = 0; row < obstacle.rows; row++) {
                        for (let col = 0; col < obstacle.pattern[row].length; col++) {
                            const emoji = obstacle.pattern[row][col];
                            if (emoji === "") continue; // Skip empty spaces in pattern

                            const x = obstacle.x + col * obstacle.blockSize;
                            const y = obstacle.y + row * obstacle.blockSize;

                            ctx.font = `${obstacle.blockSize * 0.7}px Arial`;
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.fillStyle = "yellow";  // Brighter color
                            ctx.strokeStyle = "black"; // Outline for better visibility
                            ctx.lineWidth = 3;
                            ctx.strokeText(emoji, x + obstacle.blockSize / 2, y + obstacle.blockSize / 2);
                            ctx.fillText(emoji, x + obstacle.blockSize / 2, y + obstacle.blockSize / 2);

                        }
                    }
                }
            }
        }

        // Check for collisions
        function checkCollisions() {
            // 🚀 Adjusted hitbox: slightly smaller than the visible ship
            const shipHitbox = {
                left: shipX + 10,  // Offset for better accuracy
                right: shipX + shipWidth - 10,
                top: shipY + 5,
                bottom: shipY + shipHeight - 5
            };

            // ✅ **Check ground and ceiling collision**
            if (shipHitbox.bottom > groundLevel || shipHitbox.top < ceilingLevel) {
                console.warn("🚨 Ship hit ground or ceiling!");
                loseLife();
                shipFlicker = true;
                return;
            }

            // ✅ **Check obstacle collisions**
            for (const obstacle of obstacles) {
                if (obstacle.type === "emoji-block") {
                    for (let row = 0; row < obstacle.rows; row++) {
                        for (let col = 0; col < obstacle.pattern[row].length; col++) {
                            const emoji = obstacle.pattern[row][col];
                            if (emoji === "") continue; // Skip empty spaces

                            // More precise obstacle hitbox
                            const emojiHitbox = {
                                left: obstacle.x + col * obstacle.blockSize + 5,  // Reduce width sensitivity
                                right: obstacle.x + (col + 1) * obstacle.blockSize - 5,
                                top: obstacle.y + row * obstacle.blockSize + 5,   // Reduce height sensitivity
                                bottom: obstacle.y + (row + 1) * obstacle.blockSize - 5
                            };

                            // **Collision detection (Fixed)**
                            if (
                                !invincible &&
                                shipHitbox.right > emojiHitbox.left &&
                                shipHitbox.left < emojiHitbox.right &&
                                shipHitbox.bottom > emojiHitbox.top &&
                                shipHitbox.top < emojiHitbox.bottom
                            ) {
                                console.log("💥 Collision detected with an emoji!");
                                playSound("risada");
                                loseLife();
                                shipFlicker = true;
                                return;
                            }
                        }
                    }
                }

                // ✅ **Check if obstacle has been passed (increase score)**
                if (!obstacle.passed && shipX > obstacle.x + obstacle.width) {
                    obstacle.passed = true;
                    score++;
                    obstacleSpeed += 0.04; // Gradual difficulty increase
                }
            }

            // ✅ **Check for collectible pickups**
            for (let i = activeCollectibles.length - 1; i >= 0; i--) {
                const item = activeCollectibles[i];

                // Define the hitbox for the collectible item
                const itemHitbox = {
                    left: item.x - item.size / 2,
                    right: item.x + item.size / 2,
                    top: item.y - item.size / 2,
                    bottom: item.y + item.size / 2
                };

                // **Collision detection with the ship**
                if (
                    shipHitbox.right > itemHitbox.left &&
                    shipHitbox.left < itemHitbox.right &&
                    shipHitbox.bottom > itemHitbox.top &&
                    shipHitbox.top < itemHitbox.bottom
                ) {
                    playSound("collect");
                    console.log(`✅ Collected: ${item.name}`);
                    score += item.points;
                    inventory[item.emoji]++;
                    updateInventoryDisplay();
                    activeCollectibles.splice(i, 1); // Remove collected item

                    // **Apply effects**
                    if (item.emoji === "💧") {
                        console.log("⚡ Invincibility Activated!");
                        invincible = true;
                        invincibleTimer = 1200;
                    }

                    if (item.emoji === "⏳") {
                        console.log("⏳ Time Slowdown Activated!");
                        slowDownTime();
                    }

                    if (item.emoji === "🥥") {
                        canShoot = true;
                        shootTimer = 1500;
                        console.log("🚀 Shooting enabled!");
                    }

                    if (item.emoji === "💎") {
                        console.log("💎 Diamond collected! Movement sensitivity reduced!");
                        currentAcceleration = slowAcceleration;
                        slowMovementTimer = 1500;
                    }
                }
            }
        }

        function slowDownTime() {
            if (window.isTimeSlowed) return; // Prevent multiple slowdowns at the same time
            window.isTimeSlowed = true;

            const originalSpeed = obstacleSpeed; // Store the original speed
            const originalBackgroundSpeed = backgroundSpeed; // Store the original speed

            obstacleSpeed *= 0.4; // Slow down time (reduce speed by half)
            backgroundSpeed *= .4;
            console.log("Game slowed down!");

            // Restore speed after 5 seconds
            setTimeout(() => {

                console.log("Game speed restored!");
                window.isTimeSlowed = false; // Allow future slowdowns
            }, 5000);
        }

        function loseLife() {
            if (isHit) return; // Prevent multiple hits in a short time
            isHit = true;
            isExploding = true; // 🚨 Set exploding state to keep rendering

            playSound("explosion");

            lives--; // Subtract 1 life
            console.log(`💥 Ship hit! Lives left: ${lives}`);

            createExplosion(shipX + shipWidth / 2, shipY + shipHeight / 2); // Generate explosion effect

            // **Stop ship movement, obstacles, but keep explosion running**
            shipVelocity = 0;
            shipXVelocity = 0;
            obstacleSpeed = 0;

            setTimeout(() => {
                isExploding = false; // Stop explosion effect after delay
                if (lives > 0) {
                    restartAfterHit();
                } else {
                    gameOver = true;
                    playSound("gameover");
                    gameOverScreen.style.display = 'flex';
                    gameOverScreen.style.fontSize = 40;
                    gameOverScoreDisplay.textContent = `${score}`;
                }
                obstacleSpeed = .4; // Reset speed
            }, 2000); // 2-second delay before restarting
        }

        function restartAfterHit() {
            console.log("⏪ Restarting after hit...");

            // Reset explosion state
            isHit = false;
            isExploding = false;

            // Reset ship position and movement
            shipY = canvas.height / 2;
            shipVelocity = 0;
            shipX = canvas.width * 0.2;
            shipXVelocity = 0;

            // Restore obstacle movement
            obstacleSpeed = .4;

            // Temporary invincibility after hit
            invincible = true;
            invincibleTimer = 600;

            canShoot = false;
            shootTimer = 0;
        }

        // Handle keyboard input
        const keys = {};


        let touchStartX = null;
        let touchStartY = null;
        let touchStartTime = null;
        let isMoving = false; // Track if the user is swiping or tapping

        window.addEventListener("touchstart", (e) => {
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                touchStartTime = Date.now();
                isMoving = false; // Reset movement state
            }
        });

        window.addEventListener("touchmove", (e) => {
            if (touchStartX === null || touchStartY === null) return;

            let touchX = e.touches[0].clientX;
            let touchY = e.touches[0].clientY;
            let deltaX = touchX - touchStartX;
            let deltaY = touchY - touchStartY;

            let movementThreshold = 10; // Lower threshold for smoother control
            let adjustedTouchSensitivity = currentAcceleration * 20; // Adjust movement strength

            // **Detect swipe movement in both directions**
            if (Math.abs(deltaX) > movementThreshold || Math.abs(deltaY) > movementThreshold) {
                isMoving = true; // Mark as a movement (not a tap)

                // **Allow diagonal movement naturally**
                shipXVelocity += (deltaX * adjustedTouchSensitivity) * 0.01;
                shipVelocity += (deltaY * adjustedTouchSensitivity) * 0.05;

                // **Update last touch position for smoother movement**
                touchStartX = touchX;
                touchStartY = touchY;
            }
        });

        window.addEventListener("touchend", (e) => {
            if (touchStartX === null || touchStartY === null) return;

            let touchEndX = e.changedTouches[0].clientX;
            let touchEndY = e.changedTouches[0].clientY;
            let touchEndTime = Date.now();

            let deltaX = touchEndX - touchStartX;
            let deltaY = touchEndY - touchStartY;
            let timeDiff = touchEndTime - touchStartTime;

            let tapThreshold = 120; // Max time for a tap (milliseconds)
            let minMovement = 20; // Ignore very small accidental movements

            // **Detect a tap (not a swipe) → SHOOT**
            if (!isMoving && timeDiff < tapThreshold && Math.abs(deltaX) < minMovement && Math.abs(deltaY) < minMovement) {
                if (touchStartX > window.innerWidth / 2) {
                    shootBullet();
                }
            }

            // Reset touch tracking
            touchStartX = null;
            touchStartY = null;
            touchStartTime = null;
        });




        window.addEventListener('keydown', e => {
            keys[e.key] = true;
        });
        window.addEventListener('keyup', e => {
            keys[e.key] = false;
        });
        window.addEventListener("keydown", (e) => {
            if (e.key === " " || e.code === "Space") {
                shootBullet();
            }
        });


        function handleInput() {
            if (keys['w'] || keys['W'] || keys['ArrowUp']) {
                shipVelocity -= currentAcceleration * 4;
            }
            if (keys['s'] || keys['S'] || keys['ArrowDown']) {
                shipVelocity += currentAcceleration * 2;
            }
            if (keys['a'] || keys['A'] || keys['ArrowLeft']) {
                shipXVelocity -= currentAcceleration * 1.2;
            }
            if (keys['d'] || keys['D'] || keys['ArrowRight']) {
                shipXVelocity += currentAcceleration;
            }
        }

        // Update game state
        function updateGame() {
            if (!gameStarted || gameOver || isHit) return;

            gameTime++;
            handleInput();

            if (invincible) {
                invincibleTimer--;
                if (invincibleTimer <= 0) {
                    invincible = false;
                    console.log("Invincibility Over!");
                }
            }

            // Move ship vertically
            shipVelocity += gravity;
            shipVelocity *= 0.6;
            shipY += shipVelocity;

            // Limit ship velocity
            if (shipVelocity > 10) shipVelocity = 10;
            if (shipVelocity < -10) shipVelocity = -10;

            // Apply friction to smooth horizontal movement
            shipXVelocity *= shipFriction;
            shipX += shipXVelocity;

            // Prevent out-of-bounds movement
            if (shipX < 0) shipX = 0;
            if (shipX > canvas.width - shipWidth) shipX = canvas.width - shipWidth;
            if (shipY < ceilingLevel) shipY = ceilingLevel;
            if (shipY > groundLevel - shipHeight) shipY = groundLevel - shipHeight;

            // Add ship trail particles
            if (gameTime % 2 === 0) {
                createShipTrail();
            }

             // 🚀 **Check High Speed for Ghost Sound Effect**
            const fastSpeedThreshold = 3; // Adjust as needed

            let totalSpeed = obstacleSpeed
            console.log(totalSpeed)
            if (totalSpeed > fastSpeedThreshold && !window.ghostSoundPlaying) {
                playSound("ghost");
            }

            updateParticles();

            // Move obstacles using `obstacleSpeed`
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].x -= obstacleSpeed;
                if (obstacles[i].x < -obstacles[i].width) {
                    obstacles.splice(i, 1);
                }
            }

            // Move collectibles using `obstacleSpeed`
            for (let i = activeCollectibles.length - 1; i >= 0; i--) {
                activeCollectibles[i].x -= obstacleSpeed;
                if (activeCollectibles[i].x < -50) {
                    activeCollectibles.splice(i, 1);
                }
            }

            // Spawn collectibles occasionally
            if (gameTime % 250 === 0) {
                createCollectible();
            }

            // Adjust the spawn frequency based on obstacle speed
            let obstacleSpawnRate = Math.max(80, 200 - obstacleSpeed * 20);
            // Faster speed = more frequent obstacles, but never less than 80 frames apart

            // Spawn obstacles dynamically
            if (gameTime - lastObstacleTime > obstacleSpawnRate) {
                createObstacle();
                lastObstacleTime = gameTime;
            }

            // Reduce shooting timer
            if (canShoot && shootTimer > 0) {
                shootTimer--;
                if (shootTimer <= 0) {
                    canShoot = false;
                    console.log("⏳ Shooting ability expired!");
                }
            }

            if (slowMovementTimer > 0) {
                slowMovementTimer--;
                if (slowMovementTimer <= 0) {
                    currentAcceleration = normalAcceleration;
                    console.log("⏳ Diamond effect over! Movement back to normal.");
                }
            }

            checkCollisions();

            // Update UI
            scoreDisplay.innerHTML = `Score\n${score}`;
            document.getElementById('lives').innerHTML = `❤️ Vidas ${lives}`;
        }


        // Main draw function
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawBackground();   // Draw background first
            drawObstacles();    // Then obstacles
            drawParticles();    // Then ship trail
            drawCollectibles();

            if (!isHit) drawShip();  // ❌ Hide ship if hit
            drawExplosion();  // Draw explosion effect

            drawGroundAndCeiling(); // Finally, draw ceiling & ground
        }

        function updateInventoryDisplay() {
            const inventoryDisplay = document.getElementById('inventory');
            inventoryDisplay.innerHTML = `
                💎 ${inventory["💎"]}
                🥥 ${inventory["🥥"]}
                💧 ${inventory["💧"]}`;
        }

        // Game loop
        function gameLoop() {
            if (!gameOver) {
                if (!isExploding) { // 🚨 Only stop updates, not rendering
                    updateGame();
                    updateBullets();
                }
                updateExplosion(); // ✅ Always update explosion effect
            }

            draw();
            drawBullets();
            drawExplosion(); // ✅ Ensure explosion is drawn

            requestAnimationFrame(gameLoop);
        }


        // Start the game
        startButton.addEventListener('click', () => {
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none'; // Hide Game Over screen if visible
            gameStarted = true;
            startMusic();
            createBackgroundLayers();
            gameLoop();
        });

        // Restart the game
        restartButton.addEventListener('click', () => {
            console.log("🔄 Restarting game...");

            // Stop any ongoing animations
            cancelAnimationFrame(gameLoop);

            // Hide game over screen
            gameOverScreen.style.display = 'none';

            // Reset game state
            gameStarted = true;
            gameOver = false;
            isExploding = false;  // Ensure ship is not "exploding"
            isHit = false;        // Prevent blinking effect
            flickerCount = 0;

            // Reset ship position and movement
            shipY = canvas.height / 2;
            shipX = canvas.width * 0.2;
            shipVelocity = 0;
            shipXVelocity = 0;

            backgroundSpeed = 5;
            obstacleSpeed = 1;

            // Reset obstacles, collectibles, and inventory
            obstacles = [];
            activeCollectibles = [];
            inventory = { "💧": 0, "💎": 0, "🥥": 0, "⏳": 0 };

            // Reset timers and speeds
            lastObstacleTime = 0;
            lastCollectibleTime = 0;
            gameTime = 0;
            lives = 5;
            invincible = false;
            invincibleTimer = 0;

            // Reset UI
            score = 0;
            scoreDisplay.textContent = `Score\n${score}`;
            document.getElementById('lives').innerHTML = `❤️ Vidas ${lives}`;
            updateInventoryDisplay();

            // Reset background and start fresh
            createBackgroundLayers();

            // Restart the game loop
            requestAnimationFrame(gameLoop);
        });

        // Handle game over
        function handleGameOver() {
            if (gameOver) {
                gameOverScreen.style.display = 'flex';
                gameOverScreen.style.fontSize = 40;
                gameOverScoreDisplay.textContent = score;
            }
        }

        // Set up resize handler
        window.addEventListener('resize', () => {
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                groundLevel = canvas.height * 0.8;
                ceilingLevel = canvas.height * 0.2;
                shipY = canvas.height / 2;
                gravity = /iPhone|iPad|Android|Mobile/i.test(navigator.userAgent) ? mobileGravity : normalGravity;
            }

            // Resize once on load & listen for screen changes
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            groundLevel = canvas.height * 0.8;
            ceilingLevel = canvas.height * 0.2;
            shipY = canvas.height / 2;
        });

        // Start animation
        gameLoop();

        // Check for game over in a separate interval
        setInterval(handleGameOver, 100);
    </script>
</body>
</html>