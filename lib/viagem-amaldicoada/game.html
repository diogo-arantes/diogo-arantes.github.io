<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0">
    <title>Viagem amaldiÃ§oada</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', monospace;
            color: #8a0303;
        }

        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            touch-action: none; /* Prevent touch scrolling */
        }


        canvas {
            display: block;
            background: linear-gradient(to bottom, #0a0a0a, #1a0707);
            height: 100vh;
        }

        #game-container {
            position: absolute;
            width: 100vw;
            height: 100vh; /* This will be corrected by JS */
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        h1 {
            color: #8a0303;
            font-size: 1.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000; }
            50% { text-shadow: 0 0 15px #ff0000, 0 0 30px #ff0000; }
            100% { text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000; }
        }

        button {
            padding: 15px 30px;
            font-size: 1em;
            border: 2px solid #8a0303;
            background-color: #1a0707;
            color: #8a0303;
            cursor: pointer;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }

        button:hover {
            background-color: #8a0303;
            color: #000;
            transform: scale(1.05);
        }

        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1em;
            z-index: 5;
        }

        #game-over-score {
            font-size: 2em;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="score">Score: 0</div>
        <div id="inventory" style="
            position: absolute;
            top: 35px;
            left: 20px;
            font-size: .8em;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;">
        </div>
        <div id="lives" style="
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: .8em;
            color: white;
            z-index: 5;">
        </div>
        <div id="mana-bar-container" style="
            position: absolute;
            top: 20px;
            left: 150px;
            width: 120px;
            height: 15px;
            background: rgb(34, 0, 0);
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid rgb(83, 0, 0);">
            <div id="mana-bar" style="
                width: 100%;
                height: 100%;
                background: rgb(255, 9, 9);
                transition: width 0.2s;"></div>
        </div>
        <div id="armor-bar-container" style="
            position: absolute;
            top: 20px;
            left: 280px;
            width: 120px;
            height: 15px;
            background: rgb(34, 0, 0);
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid rgb(0, 19, 83);">
            <div id="armor-bar" style="
                width: 0%;
                height: 100%;
                background: rgb(75, 9, 255);
                transition: width 0.2s;"></div>
        </div>

        <div id="start-screen">
            <h1>VIAGEM AMALDIÃ‡OADA</h1>
            <button id="start-button">PREPARE-SE PARA PERDER</button>
        </div>

        <div id="game-over-screen" style="display: none;">
            <h1>GAME OVER</h1>
            <div id="game-over-score"></div>
            <button id="restart-button">VAI TENTAR NEH</button>
        </div>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const gameOverScoreDisplay = document.getElementById('game-over-score');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');

        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game state
        const isMobile = /iPhone|iPad|Android|Mobile/i.test(navigator.userAgent);

        let gameStarted = false;
        let gameOver = false;
        let score = 0;
        let maxMana = 100;
        let mana = maxMana;
        let shipY = canvas.height / 2;
        let shipVelocity = 0;
        let backgroundSpeed = 5; // Independent background scrolling speed
        let obstacleSpeed = 1;    // Independent obstacle movement speed
        let obstacles = [];
        let groundLevel = canvas.height * 0.9;
        let ceilingLevel = canvas.height * 0.1;
        let lastObstacleTime = 0;
        let gameTime = 0;
        let isExploding = false;
        let shipFlicker = false;
        let flickerCount = 0;
        let shipXVelocity = 0; // Horizontal velocity
        const shipAcceleration = 0.3; // How fast the ship moves
        const shipFriction = 0.9; // Friction effect to smooth movement
        const fastSpeedThreshold = 3; // Adjust as needed

        let lives = 5; // Ship starts with 3 lives
        let isHit = false; // To track ship blinking effect
        let hitTimer = 0;  // Timer for blinking animation

        // Initialize armor system
        let maxArmor = 100;
        let armor = 0;
        let laserActive = false;
        let laserDuration = 2500; // Laser lasts 500 frames (~8 seconds)
        let laserBeam = null;

        let invincible = false;
        let invincibleTimer = 0;

        let bullets = [];
        let laserCooldown = false;
        let canShoot = false; // Starts as false, enabled when a coconut is collected
        const bulletSpeed = 10;
        const bulletSize = 8;
        let shootTimer = 0;
        // Initialize bullet count
        let bulletCount = 0;
        const maxBullets = 10;

        let normalAcceleration = 0.3; // Default acceleration
        let slowAcceleration = 0.1;   // Reduced acceleration when diamond is active
        let currentAcceleration = normalAcceleration; // Track current acceleration

        let slowMovementTimer = 0; // Timer for slow effect
        // List of collectible objects in the game
        let activeCollectibles = [];

        const normalGravity = 0.3;
        const mobileGravity = 0.15; // ğŸ”½ Lower gravity for mobile
        let gravity = isMobile ? mobileGravity : normalGravity;

        // Ship properties
        const shipWidth = 80;
        const shipHeight = 40;
        let shipX = canvas.width * 0.2;

        // Create a ship glow effect
        const shipGlow = {
            radius: 20,
            opacity: 0.5,
            color: '#8a0303'
        };

        let stalactites = [];
        let nextStalactiteTime = gameTime + Math.floor(Math.random() * 500) + 300; // Spawns every 500-1500 frames

        // Images for backgrounds and effects
        const bgLayers = [];
        const numLayers = 3;
        let bgReady = false;

        // Define obstacle patterns with emojis
        // Define emoji obstacle shapes
        const emojiShapes = [
        { // Triangle of Thumbs Up ğŸ¤¡
            pattern: [
                ["", "", "ğŸ¤¡", "", ""],
                ["", "ğŸ¤¡", "ğŸ¤¡", "ğŸ¤¡", ""],
                ["ğŸ¤¡", "ğŸ¤¡", "ğŸ¤¡", "ğŸ¤¡", "ğŸ¤¡"]
            ],
            type: "triangle"
        },
        { // Square of Poop ğŸ‘¾
            pattern: [
                ["ğŸ‘¾", "ğŸ‘¾", "ğŸ‘¾"],
                ["ğŸ‘¾", "ğŸ‘¾", "ğŸ‘¾"],
                ["ğŸ‘¾", "ğŸ‘¾", "ğŸ‘¾"],
                ["ğŸ‘¾", "ğŸ‘¾", "ğŸ‘¾"],
                ["ğŸ‘¾", "ğŸ‘¾", "ğŸ‘¾"],
            ],
            type: "square"
        },
        { // Diamond (Losango) of Hearts ğŸ‘½
            pattern: [
                ["", "", "ğŸ‘½", "", ""],
                ["", "ğŸ‘½", "ğŸ‘½", "ğŸ‘½", ""],
                ["ğŸ‘½", "ğŸ‘½", "ğŸ‘½", "ğŸ‘½", "ğŸ‘½"],
                ["", "ğŸ‘½", "ğŸ‘½", "ğŸ‘½", ""],
                ["", "", "ğŸ‘½", "", ""]
            ],
            type: "diamond"
        },
        { // Eyes
            pattern: [
                ["ğŸ‘€", "", "", "", "ğŸ‘€"],
                ["ğŸ‘€", "ğŸ‘€", "", "ğŸ‘€", "ğŸ‘€"],
                ["ğŸ‘€", "ğŸ‘€", "ğŸ‘€", "ğŸ‘€", "ğŸ‘€"],
                ["ğŸ‘€", "ğŸ‘€", "", "ğŸ‘€", "ğŸ‘€"],
                ["ğŸ‘€", "", "", "", "ğŸ‘€"]
            ],
            type: "eyes"
        },
        { // Bar
            pattern: [
                ["", "", "", "", ""],
                ["", "", "", "", ""],
                ["ğŸŸ¥", "ğŸŸ¥", "ğŸŸ¥", "ğŸŸ¥", "ğŸŸ¥"],
                ["", "", "", "", ""],
                ["", "", "", "", ""]
            ],
            type: "bar"
        },
        {
            pattern: [
                ["ğŸ¥š", "ğŸ¥š", "ğŸ¥š"],
                ["ğŸ¥š", "ğŸ¥š", "ğŸ¥š"],
                ["ğŸ¥š", "ğŸ¥š", "ğŸ¥š"],
                ["ğŸ¥š", "ğŸ¥š", "ğŸ¥š"],
                ["ğŸ¥š", "ğŸ¥š", "ğŸ¥š"],
                ["ğŸ¥š", "ğŸ¥š", "ğŸ¥š"],
            ],
            type: "eggs"
        },
        {
            pattern: [
                ["",   "", "ğŸ"],
                ["",   "ğŸ", ""],
                ["ğŸ", "ğŸ", ""],
                ["ğŸ", "ğŸ", ""],
                ["",   "ğŸ", ""],
                ["",   "", "ğŸ"],
            ],
            type: "eggs"
        },
        {
            pattern: [
                ["ğŸ¦´","ğŸ¦´", "ğŸ¦´", "ğŸ¦´"],
                ["ğŸ¦´","ğŸ¦´", "ğŸ¦´", "ğŸ¦´"],
                ["","", "ğŸ¦´", "ğŸ¦´"],
                ["","", "ğŸ¦´", "ğŸ¦´"],
                ["","", "ğŸ¦´", "ğŸ¦´"],
                ["ğŸ¦´","ğŸ¦´", "ğŸ¦´", "ğŸ¦´"],
                ["ğŸ¦´","ğŸ¦´", "ğŸ¦´", "ğŸ¦´"],

            ],
            type: "eggs"
        }
        ];

        // Define collectible items
        const collectibles = [
            { emoji: "ğŸ’€", name: "skull", points: 5, spawnRate: 0.5 },  // Common
            { emoji: "ğŸ’©", name: "ring", points: 10, spawnRate: 0.4 },  // Uncommon
            { emoji: "ğŸ”«", name: "coconut", points: 15, spawnRate: 0.8 }, // Less Common
            { emoji: "ğŸ¦â€ğŸ”¥", name: "time", points: 10, spawnRate: 0.5 }, // Rare
            { emoji: "â˜¢ï¸", name: "radiation", points: 10, spawnRate: 0.3 }, // Very Rare
            { emoji: "ğŸ”‹", name: "battery", points: 0, spawnRate: 0.3 }  // Uncommon
        ];

        let inventory = { "ğŸ’€": 0, "ğŸ’©": 0, "ğŸ”«": 0, "ğŸ¦â€ğŸ”¥": 0, "â˜¢ï¸": 0 };

        const sounds = {
            startup: new Audio("startup.mp3"),
            music1: new Audio("background-layer-0.mp3"),
            music2: new Audio("background-layer-1.mp3"),
            music3: new Audio("background-layer-2.mp3"),
            risada: new Audio("risada-do-mal.mp3"),
            ghost: new Audio("ghost.mp3"),
            shoot: new Audio("shoot.mp3"),
            laser: new Audio("laser.mp3"),
            explosion: new Audio("explosion.mp3"),
            explosionAll: new Audio("explosion-all.mp3"),
            collect: new Audio("collect.mp3"),
            shield: new Audio("shield.mp3"),
            life: new Audio("life.mp3"),
            loseLife: new Audio("lose-life.mp3"),
            gameover: new Audio("gameover.mp3")
        };

        // ğŸµ Configure Looping & Volume
        sounds.music1.loop = true;
        sounds.music1.volume = 0.3; // Adjust volume as needed
        sounds.music2.loop = true;
        sounds.music2.volume = 0.2; // Adjust volume as needed
        sounds.music3.loop = true;
        sounds.music3.volume = 0.4; // Adjust volume as needed

        // ğŸš€ Play Background Music when the game starts
        function startMusic() {
            sounds.music2.play();
            sounds.music3.play();
        }

        // ğŸ”« Play Sound Effects
        function playSound(sound) {
            if (sounds[sound]) {
                sounds[sound].currentTime = 0; // Reset to allow rapid triggers
                sounds[sound].play();
            }
        }

        function updateManaBar() {
            let manaPercentage = (mana / maxMana) * 100;
            document.getElementById('mana-bar').style.width = `${manaPercentage}%`;

            // Se a mana acabou, o jogador perde uma vida
            if (mana <= 0) {
                loseLife();
                mana = maxMana; // Recupera a mana ao perder uma vida
            }
        }

        function updateArmorBar() {
            let armorPercentage = (armor / maxArmor) * 100;
            document.getElementById('armor-bar').style.width = `${armorPercentage}%`;
        }

        // Create a falling stalactite
        function createStalactite() {
            let baseWidth = 40 + Math.random() * 30; // Wider base
            let height = 60 + Math.random() * 50; // Taller stalactite

            let stalactite = {
                x: Math.random() * (canvas.width - baseWidth) + baseWidth / 2, // Random horizontal position
                y: ceilingLevel, // Starts at ceiling
                width: baseWidth,
                height: height,
                speed: 2 + Math.random() * 2, // Falling speed
                active: true // Track if it's still in the game
            };
            stalactites.push(stalactite);
            console.log("ğŸ§Š Stalactite created!", stalactite);
        }

        // Draw stalactites
        function drawStalactites() {
            ctx.fillStyle = "#553322"; // Darker rock color
            ctx.strokeStyle = "#8a0303"; // Red outline for visibility
            ctx.lineWidth = 2;

            stalactites.forEach(stalactite => {
                ctx.beginPath();
                ctx.moveTo(stalactite.x, stalactite.y); // Top middle
                let peakOffset = stalactite.width * 0.2;

                // Draw a jagged, uneven base (simulating rocky formation)
                ctx.lineTo(stalactite.x - stalactite.width / 2, stalactite.y + peakOffset);
                ctx.lineTo(stalactite.x - stalactite.width * 0.3, stalactite.y + stalactite.height * 0.5);
                ctx.lineTo(stalactite.x - stalactite.width * 0.1, stalactite.y + stalactite.height * 0.8);
                ctx.lineTo(stalactite.x, stalactite.y + stalactite.height);
                ctx.lineTo(stalactite.x + stalactite.width * 0.1, stalactite.y + stalactite.height * 0.8);
                ctx.lineTo(stalactite.x + stalactite.width * 0.3, stalactite.y + stalactite.height * 0.5);
                ctx.lineTo(stalactite.x + stalactite.width / 2, stalactite.y + peakOffset);
                ctx.closePath();

                ctx.fill();
                ctx.stroke(); // Outline for better visibility
            });
        }

        // ğŸ—ï¸ Update stalactites (falling effect)
        function updateStalactites() {
            for (let i = stalactites.length - 1; i >= 0; i--) {
                let stalactite = stalactites[i];
                stalactite.y += stalactite.speed; // Move downward

                // Remove stalactites that go off the screen
                if (stalactite.y > canvas.height) {
                    stalactites.splice(i, 1);
                    console.log("ğŸ’¨ Stalactite removed (out of screen)");
                }

                // Check collision with the ship
                if (
                    shipX < stalactite.x + stalactite.width / 2 &&
                    shipX + shipWidth > stalactite.x - stalactite.width / 2 &&
                    shipY < stalactite.y + stalactite.height &&
                    shipY + shipHeight > stalactite.y
                ) {
                    console.log("ğŸ’¥ Stalactite hit the ship!");
                    loseLife();
                    stalactites.splice(i, 1);
                }
            }
        }

        // Shoot function
        function shoot() {
            if (armor <= 0) return

            if (inventory["ğŸ”«"] >= 3) {
                activateLaserMode();
            } else if (inventory["ğŸ”«"] > 0) {
                bullets.push({
                    x: shipX + shipWidth,
                    y: shipY + shipHeight / 2,
                    size: 8,
                    speed: 10
                });
                playSound("shoot");
            }
        }

        // Update bullets
        function updateShooting() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].x += bulletSpeed;

                // Remove bullet if it goes off-screen
                if (bullets[i].x > canvas.width) {
                    bullets.splice(i, 1);
                    continue;
                }

                // Check collision with obstacles
                for (let j = obstacles.length - 1; j >= 0; j--) {
                    let obstacle = obstacles[j];

                    if (obstacle.type === "emoji-block") {
                        for (let row = 0; row < obstacle.rows; row++) {
                            for (let col = 0; col < obstacle.pattern[row].length; col++) {
                                let emoji = obstacle.pattern[row][col];
                                if (emoji === "") continue;

                                let emojiX = obstacle.x + col * obstacle.blockSize;
                                let emojiY = obstacle.y + row * obstacle.blockSize;

                                if (
                                    bullets[i].x + bullets[i].size > emojiX &&
                                    bullets[i].x < emojiX + obstacle.blockSize &&
                                    bullets[i].y > emojiY &&
                                    bullets[i].y < emojiY + obstacle.blockSize
                                ) {
                                    console.log(`ğŸ”¥ Bullet destroyed ${emoji}`);
                                    obstacle.pattern[row][col] = ""; // Remove emoji
                                    bullets.splice(i, 1);
                                    score += 1;
                                    armor -= 1;
                                    updateArmorBar();
                                    return;
                                }
                            }
                        }
                    }
                }
            }

            if (laserBeam) {
                laserBeam.x += laserBeam.speed;
                if (laserBeam.x > canvas.width) laserBeam = null;

                for (let i = obstacles.length - 1; i >= 0; i--) {
                    let obstacle = obstacles[i];
                    if (
                        laserBeam &&
                        laserBeam.x + laserBeam.width > obstacle.x &&
                        laserBeam.x < obstacle.x + obstacle.width &&
                        laserBeam.y > obstacle.y &&
                        laserBeam.y < obstacle.y + obstacle.height
                    ) {
                        createExplosion(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
                        obstacles.splice(i, 1);
                        armor -= 1;
                        if (armor < 0) armor = 0;
                        updateArmorBar();
                        laserBeam = null;
                        break;
                    }
                }
            }
        }

        // Draw bullets
        function drawBullets() {
            ctx.fillStyle = "yellow";
            for (let bullet of bullets) {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function activateLaserMode() {
            if (laserCooldown || armor <= 0) return;

            laserActive = true;
            laserCooldown = true;
            playSound("laser");

            // Criar um novo feixe temporÃ¡rio
            laserBeam = {
                x: shipX + shipWidth,
                y: shipY + shipHeight / 2,
                width: 10,
                speed: 20
            };

            setTimeout(() => {
                laserActive = false;
                laserBeam = null;
                setTimeout(() => {
                    laserCooldown = false;
                }, 100); // Pequena pausa antes de permitir outro laser
            }, 500); // O feixe dura apenas 100ms
        }


        function drawLaser() {
            if (!laserBeam) return;

            let beamLength = 900; // Make it longer for a sci-fi effect
            let beamThickness = 8; // Core thickness
            let glowThickness = 18; // Glow thickness

            // **Core Laser Beam**
            ctx.globalAlpha = 0.9;
            ctx.strokeStyle = "rgba(0, 255, 255, 1)"; // Intense cyan core
            ctx.lineWidth = beamThickness;
            ctx.beginPath();
            ctx.moveTo(laserBeam.x, laserBeam.y);
            ctx.lineTo(laserBeam.x + beamLength, laserBeam.y);
            ctx.stroke();

            // **Outer Glow**
            ctx.globalAlpha = 0.4;
            ctx.strokeStyle = "rgba(0, 255, 255, 0.6)";
            ctx.lineWidth = glowThickness;
            ctx.beginPath();
            ctx.moveTo(laserBeam.x, laserBeam.y);
            ctx.lineTo(laserBeam.x + beamLength, laserBeam.y);
            ctx.stroke();

            // **Extra Flickering Effect (subtle randomness)**
            if (Math.random() > 0.5) {
                ctx.globalAlpha = 0.2;
                ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
                ctx.lineWidth = glowThickness + 4;
                ctx.beginPath();
                ctx.moveTo(laserBeam.x, laserBeam.y);
                ctx.lineTo(laserBeam.x + beamLength, laserBeam.y);
                ctx.stroke();
            }

            // Reset global alpha
            ctx.globalAlpha = 1;
        }

        function destroyObstaclesWithLaser() {
            if (!laserBeam) return;
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obstacle = obstacles[i];
                if (
                    laserBeam.x + laserBeam.width > obstacle.x &&
                    laserBeam.x < obstacle.x + obstacle.width &&
                    laserBeam.y > obstacle.y &&
                    laserBeam.y < obstacle.y + obstacle.height
                ) {
                    createExplosion(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
                    obstacles.splice(i, 1);
                    armor -= 3;
                    if (armor < 0) armor = 0;
                    updateArmorBar();
                    laserBeam = null; // Destroy beam after hitting an obstacle
                    break;
                }
            }
        }

        // Create background layers
        function createBackgroundLayers() {
            for (let i = 0; i < numLayers; i++) {
                const layer = {
                    x: 0,
                    speed: 0.3 + i * 0.3, // Different speeds for parallax effect
                    clouds: []
                };

                const numObjects = 5 + Math.floor(Math.random() * 20); // Random number of objects

                for (let j = 0; j < numObjects; j++) {
                    const type = Math.random() > 0.7 ? "planet" : "star"; // 30% chance for a planet
                    const depth = 0.1 + Math.random() * 0.3; // Depth factor between 0.3 and 1.0

                    layer.clouds.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        width: type === "planet" ? 60 + Math.random() * 140 : 4 + Math.random() * 6,
                        height: type === "planet" ? 60 + Math.random() * 140 : 4 + Math.random() * 6,
                        opacity: type === "star" ? (0.5 + Math.random() * 1) : .1,
                        color: type === "planet" ? ["#ffcc00", "#ff5500", "#0099ff", "#00ff66", "#ff66ff"][Math.floor(Math.random() * 5)] : "white",
                        type: type,
                        depth: depth // Assign depth for parallax effect
                    });
                }

                bgLayers.push(layer);
            }
            bgReady = true;
        }

        const explosionParticles = [];

        function createExplosion(x, y) {
            for (let i = 0; i < 50; i++) { // More particles for a stronger effect
                explosionParticles.push({
                    x: x,
                    y: y,
                    size: 5 + Math.random() * 12, // Bigger explosion
                    speedX: (Math.random() - 0.5) * 10,
                    speedY: (Math.random() - 0.5) * 10,
                    life: 50 + Math.random() * 30, // Lasts longer
                    color: `rgba(255, ${50 + Math.random() * 150}, 0, 1)`
                });
            }
        }

        function updateExplosion() {
            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                let p = explosionParticles[i];
                p.x += p.speedX;
                p.y += p.speedY;
                p.life--;
                if (p.life <= 0) explosionParticles.splice(i, 1); // Remove finished particles
            }
        }

        function drawExplosion() {
            for (const p of explosionParticles) {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }


        // Particles system for effects
        const particles = [];

        function createShipTrail() {
            particles.push({
                x: shipX,
                y: shipY + shipHeight / 2,
                size: 2 + Math.random() * 6,
                speedX: -1 - Math.random() * 2,
                speedY: (Math.random() - 0.5) * 2,
                life: 30 + Math.random() * 20,
                color: `rgba(${138 + Math.random() * 50}, ${3 + Math.random() * 20}, ${3 + Math.random() * 20}, ${0.3 + Math.random() * 0.5})`
            });
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.speedX;
                p.y += p.speedY;
                p.life--;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life / 50;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });
        }

        // Draw background layers
        function drawBackground() {
            if (!bgReady) return;

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (const layer of bgLayers) {
                layer.x -= backgroundSpeed * layer.speed; // Use `backgroundSpeed`
                if (layer.x < -canvas.width) {
                    layer.x = 0;
                }

                for (const obj of layer.clouds) {
                    obj.x -= backgroundSpeed * obj.depth; // Background scrolls separately
                    if (obj.x < -obj.width) {
                        obj.x = canvas.width + Math.random() * 100;
                        obj.y = Math.random() * canvas.height;
                    }

                    let adjustedOpacity = obj.opacity * obj.depth;

                    if (obj.type === "star") {
                        ctx.fillStyle = `rgba(255, 255, 255, ${adjustedOpacity})`;
                        ctx.beginPath();
                        ctx.arc(obj.x, obj.y, obj.width / 6, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (obj.type === "planet") {
                        ctx.fillStyle = obj.color;
                        ctx.globalAlpha = adjustedOpacity;
                        ctx.beginPath();
                        ctx.arc(obj.x, obj.y, obj.width / 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }
                }
            }
        }

        function drawCollectibles() {
            ctx.font = "20px Arial";  // Increased font size for visibility
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            for (const item of activeCollectibles) {
                if (!item.collected) {
                    ctx.fillStyle = "white"; // Ensure high contrast for visibility
                    ctx.fillText(item.emoji, item.x, item.y);
                }
            }
        }

        // Draw the ship with a glow effect
        function drawShip() {
            if (isExploding) return;
            if (isHit && shipFlicker) {
                flickerCount++;
                if (flickerCount % 6 < 3) {
                    isHit = false;
                    return;
                }
            }

            // ğŸš€ **Define Armor Colors**
            let shipBaseColor = canShoot ? "#444" : "#8B0000"; // Gunmetal Gray when armed
            let armorBorderColor = canShoot ? "#AAA" : "#FF6347"; // Brighter outline
            let energyColor = canShoot ? "cyan" : "red"; // Blue glow when armed

            // ğŸŒŸ **Ship Glow Effect**
            ctx.beginPath();
            ctx.arc(shipX + shipWidth / 2, shipY + shipHeight / 2, shipGlow.radius, 0, Math.PI * 2);
            const glowGradient = ctx.createRadialGradient(
                shipX + shipWidth / 2, shipY + shipHeight / 2, 0,
                shipX + shipWidth / 2, shipY + shipHeight / 2, shipGlow.radius
            );
            glowGradient.addColorStop(0, `rgba(${canShoot ? '0,255,255' : '255,50,50'}, 0.8)`);
            glowGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
            ctx.fillStyle = glowGradient;
            ctx.fill();

            // ğŸš€ **Main Ship Body**
            ctx.fillStyle = shipBaseColor;
            ctx.strokeStyle = armorBorderColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(shipX, shipY + shipHeight / 2);
            ctx.lineTo(shipX + shipWidth * 0.3, shipY + shipHeight * 0.2);
            ctx.lineTo(shipX + shipWidth * 0.8, shipY + shipHeight * 0.2);
            ctx.lineTo(shipX + shipWidth, shipY + shipHeight / 2);
            ctx.lineTo(shipX + shipWidth * 0.8, shipY + shipHeight * 0.8);
            ctx.lineTo(shipX + shipWidth * 0.3, shipY + shipHeight * 0.8);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // ğŸ›¡ï¸ **Armor Plating (Metallic Highlights)**
            ctx.strokeStyle = "#DDD"; // Light metallic effect
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(shipX + shipWidth * 0.3, shipY + shipHeight * 0.2);
            ctx.lineTo(shipX + shipWidth * 0.3, shipY + shipHeight * 0.8);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(shipX + shipWidth * 0.6, shipY + shipHeight * 0.3);
            ctx.lineTo(shipX + shipWidth * 0.6, shipY + shipHeight * 0.7);
            ctx.stroke();

            // ğŸ”¥ **Energy Core (Glowing Center)**
            let coreGradient = ctx.createRadialGradient(
                shipX + shipWidth * 0.45, shipY + shipHeight * 0.5, 0,
                shipX + shipWidth * 0.45, shipY + shipHeight * 0.5, shipHeight * 0.15
            );
            coreGradient.addColorStop(0, "white");
            coreGradient.addColorStop(1, energyColor);
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(shipX + shipWidth * 0.45, shipY + shipHeight * 0.5, shipHeight * 0.15, 0, Math.PI * 2);
            ctx.fill();

            // ğŸ‡ **Invincible Mode Glow Effect**
            if (invincible) {
                let invincibleGlow = ctx.createRadialGradient(
                    shipX + shipWidth / 2, shipY + shipHeight / 2, 10,
                    shipX + shipWidth / 2, shipY + shipHeight / 2, 50
                );
                invincibleGlow.addColorStop(0, "rgba(255, 255, 255, 0.8)");
                invincibleGlow.addColorStop(1, "rgba(255, 255, 255, 0)");

                ctx.fillStyle = invincibleGlow;
                ctx.beginPath();
                ctx.arc(shipX + shipWidth / 2, shipY + shipHeight / 2, 40, 0, Math.PI * 2);
                ctx.fill();
            }

            // **EXTRA ARMOR (When Shooting is Enabled)**
            if (armor > 0) {
                ctx.fillStyle = "#666"; // Darker metallic armor
                ctx.strokeStyle = "#BBB";
                ctx.lineWidth = 2;

                // **Side Armor**
                ctx.fillRect(shipX + 5, shipY + 5, 15, shipHeight - 10);
                ctx.fillRect(shipX + shipWidth - 20, shipY + 5, 15, shipHeight - 10);

                // **Side Cannons**
                ctx.fillStyle = "#333";
                ctx.fillRect(shipX + shipWidth * 0.1, shipY + shipHeight * 0.2, 10, 20);
                ctx.fillRect(shipX + shipWidth * 0.1, shipY + shipHeight * 0.6, 10, 20);
                ctx.fillRect(shipX + shipWidth * 0.9 - 10, shipY + shipHeight * 0.2, 10, 20);
                ctx.fillRect(shipX + shipWidth * 0.9 - 10, shipY + shipHeight * 0.6, 10, 20);

                // **Glowing Vents & Weapon Ports**
                ctx.fillStyle = "rgba(0, 255, 255, 0.7)";
                ctx.fillRect(shipX + shipWidth * 0.35, shipY + shipHeight * 0.1, 8, 4);
                ctx.fillRect(shipX + shipWidth * 0.35, shipY + shipHeight * 0.85, 8, 4);
                ctx.fillRect(shipX + shipWidth * 0.6, shipY + shipHeight * 0.1, 8, 4);
                ctx.fillRect(shipX + shipWidth * 0.6, shipY + shipHeight * 0.85, 8, 4);
            }
            else if (inventory['ğŸ”«'] > 3 && armor > 0) {
                ctx.strokeStyle = "cyan";
                ctx.lineWidth = 4;

                // **Energy Lines on Wings**
                ctx.beginPath();
                ctx.moveTo(shipX + shipWidth * 0.2, shipY + shipHeight * 0.1);
                ctx.lineTo(shipX + shipWidth * 0.8, shipY + shipHeight * 0.1);
                ctx.moveTo(shipX + shipWidth * 0.2, shipY + shipHeight * 0.9);
                ctx.lineTo(shipX + shipWidth * 0.8, shipY + shipHeight * 0.9);
                ctx.stroke();

                // **Outer Glow**
                let laserGlow = ctx.createRadialGradient(
                    shipX + shipWidth / 2, shipY + shipHeight / 2, 20,
                    shipX + shipWidth / 2, shipY + shipHeight / 2, 60
                );
                laserGlow.addColorStop(0, "rgba(0, 255, 255, 0.9)");
                laserGlow.addColorStop(1, "rgba(0, 0, 0, 0)");
                ctx.fillStyle = laserGlow;
                ctx.beginPath();
                ctx.arc(shipX + shipWidth / 2, shipY + shipHeight / 2, 50, 0, Math.PI * 2);
                ctx.fill();
            }
        }


        // Create obstacles: ground spikes and ceiling spikes
        function createObstacle() {
            const isEmojiBlock = Math.random() > 0.5; // 50% chance to generate emoji obstacles

            // Calculate possible spawn points to prevent overlap
            const numSections = 5; // Divide screen height into 5 sections
            const sectionHeight = (groundLevel - ceilingLevel) / numSections;
            let availableSections = Array.from({ length: numSections }, (_, i) => i);

            const sectionIndex = availableSections.splice(
                Math.floor(Math.random() * availableSections.length),
                1
            )[0];

            let newObstacle;

            if (isEmojiBlock) {
                const shape = emojiShapes[Math.floor(Math.random() * emojiShapes.length)];
                const blockSize = 30;
                const numRows = shape.pattern.length;
                const numCols = shape.pattern[0].length;

                // **Deep copy the pattern** to prevent modifying the original
                const copiedPattern = shape.pattern.map(row => [...row]);

                newObstacle = {
                    type: "emoji-block",
                    x: canvas.width,
                    width: numCols * blockSize,
                    height: numRows * blockSize,
                    pattern: copiedPattern,  // Use copied pattern instead of reference
                    blockSize: blockSize,
                    rows: numRows,
                    isGroundObstacle: Math.random() > 0.5,
                    passed: false
                };

                newObstacle.y = ceilingLevel + sectionIndex * sectionHeight + (sectionHeight - newObstacle.height) / 2;
            } else {
                // Traditional spike obstacle
                const width = 40 + Math.random() * 40;
                const height = 80 + Math.random() * 120;

                newObstacle = {
                    type: "spike",
                    x: canvas.width,
                    width,
                    height,
                    isGroundObstacle: Math.random() > 0.5,
                    passed: false
                };

                newObstacle.y = ceilingLevel + sectionIndex * sectionHeight + (sectionHeight - height) / 2;
            }

            // Prevent obstacles from spawning too close together
            if (obstacles.length > 0) {
                const lastObstacle = obstacles[obstacles.length - 1];
                if (newObstacle.x - lastObstacle.x < 150) {
                    return; // Avoid spawning too close
                }
            }

            obstacles.push(newObstacle);
        }

        function createCollectible() {
            if (Math.random() > 0.8) return; // General 20% chance to spawn any collectible

            // Filter only items that **pass the probability check**
            let availableItems = collectibles.filter(item => Math.random() < item.spawnRate);

            if (availableItems.length === 0) return; // If no items pass, don't spawn anything

            let item = availableItems[Math.floor(Math.random() * availableItems.length)];
            let size = 25;
            let yPos = Math.random() * (groundLevel - ceilingLevel - size) + ceilingLevel;

            activeCollectibles.push({
                emoji: item.emoji,
                name: item.name,
                points: item.points,
                x: canvas.width,
                y: yPos,
                size: size,
                collected: false
            });
        }

        // Draw ground and ceiling
        function drawGroundAndCeiling() {
            // Draw ceiling
            const ceilingGradient = ctx.createLinearGradient(0, 0, 0, ceilingLevel);
            ceilingGradient.addColorStop(0, '#0a0a0a');
            ceilingGradient.addColorStop(1, '#350101');
            ctx.fillStyle = ceilingGradient;
            ctx.fillRect(0, 0, canvas.width, ceilingLevel);

            // Ceiling details
            for (let i = 0; i < canvas.width; i += 40) {
                const height = 10 + Math.sin(i * 0.05 + gameTime * 0.01) * 5;
                ctx.fillStyle = '#8a0303';
                ctx.beginPath();
                ctx.moveTo(i, ceilingLevel);
                ctx.lineTo(i + 20, ceilingLevel);
                ctx.lineTo(i + 10, ceilingLevel + height);
                ctx.closePath();
                ctx.fill();
            }

            // Draw ground
            const groundGradient = ctx.createLinearGradient(0, groundLevel, 0, canvas.height);
            groundGradient.addColorStop(0, '#350101');
            groundGradient.addColorStop(1, '#0a0a0a');
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, groundLevel, canvas.width, canvas.height - groundLevel);

            // Ground details
            for (let i = 0; i < canvas.width; i += 40) {
                const height = 10 + Math.sin(i * 0.03 + gameTime * 0.01) * 5;
                ctx.fillStyle = '#8a0303';
                ctx.beginPath();
                ctx.moveTo(i, groundLevel);
                ctx.lineTo(i + 20, groundLevel);
                ctx.lineTo(i + 10, groundLevel - height);
                ctx.closePath();
                ctx.fill();
            }
        }

        // Draw obstacles
        function drawObstacles() {
            for (const obstacle of obstacles) {
                if (obstacle.type === "emoji-block") {
                    // Draw emoji obstacles
                    for (let row = 0; row < obstacle.rows; row++) {
                        for (let col = 0; col < obstacle.pattern[row].length; col++) {
                            const emoji = obstacle.pattern[row][col];
                            if (emoji === "") continue; // Skip empty spaces in pattern

                            const x = obstacle.x + col * obstacle.blockSize;
                            const y = obstacle.y + row * obstacle.blockSize;

                            ctx.font = `${obstacle.blockSize * 0.7}px Arial`;
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.fillStyle = "yellow";  // Brighter color
                            ctx.strokeStyle = "black"; // Outline for better visibility
                            ctx.lineWidth = 3;
                            ctx.strokeText(emoji, x + obstacle.blockSize / 2, y + obstacle.blockSize / 2);
                            ctx.fillText(emoji, x + obstacle.blockSize / 2, y + obstacle.blockSize / 2);

                        }
                    }
                }
            }
        }

        // Check for collisions
        function checkCollisions() {
            // ğŸš€ Adjusted hitbox: slightly smaller than the visible ship
            const shipHitbox = {
                left: shipX + 10,  // Offset for better accuracy
                right: shipX + shipWidth - 10,
                top: shipY + 5,
                bottom: shipY + shipHeight - 5
            };

            // âœ… **Check obstacle collisions**
            for (const obstacle of obstacles) {
                if (obstacle.type === "emoji-block") {
                    for (let row = 0; row < obstacle.rows; row++) {
                        for (let col = 0; col < obstacle.pattern[row].length; col++) {
                            const emoji = obstacle.pattern[row][col];
                            if (emoji === "") continue; // Skip empty spaces

                            // More precise obstacle hitbox
                            const emojiHitbox = {
                                left: obstacle.x + col * obstacle.blockSize + 5,  // Reduce width sensitivity
                                right: obstacle.x + (col + 1) * obstacle.blockSize - 5,
                                top: obstacle.y + row * obstacle.blockSize + 5,   // Reduce height sensitivity
                                bottom: obstacle.y + (row + 1) * obstacle.blockSize - 5
                            };

                            // **Collision detection (Fixed)**
                            if (
                                !invincible &&
                                shipHitbox.right > emojiHitbox.left &&
                                shipHitbox.left < emojiHitbox.right &&
                                shipHitbox.bottom > emojiHitbox.top &&
                                shipHitbox.top < emojiHitbox.bottom
                            ) {
                                console.log("ğŸ’¥ Collision detected with an emoji!");
                                mana -= .3;
                                if (mana > .3) {
                                    playSound('loseLife')
                                }
                                updateManaBar();
                                shipFlicker = true;
                                return;
                            }
                        }
                    }
                }

                // âœ… **Check if obstacle has been passed (increase score)**
                if (!obstacle.passed && shipX > obstacle.x + obstacle.width) {
                    obstacle.passed = true;
                    score++;
                    obstacleSpeed += 0.04; // Gradual difficulty increase
                }
            }

            // âœ… **Check for collectible pickups**
            for (let i = activeCollectibles.length - 1; i >= 0; i--) {
                const item = activeCollectibles[i];

                // Define the hitbox for the collectible item
                const itemHitbox = {
                    left: item.x - item.size / 2,
                    right: item.x + item.size / 2,
                    top: item.y - item.size / 2,
                    bottom: item.y + item.size / 2
                };

                // **Collision detection with the ship**
                if (
                    shipHitbox.right > itemHitbox.left &&
                    shipHitbox.left < itemHitbox.right &&
                    shipHitbox.bottom > itemHitbox.top &&
                    shipHitbox.top < itemHitbox.bottom
                ) {
                    playSound("collect");
                    console.log(`âœ… Collected: ${item.name}`);
                    score += item.points;

                    inventory[item.emoji]++;
                    activeCollectibles.splice(i, 1); // Remove collected item
                    updateInventoryDisplay();
                    checkLifeGain(); // âœ… Check if an extra life should be given

                    // **Apply effects**
                    if (item.emoji === "ğŸ’€") {
                        console.log("âš¡ Invincibility Activated!");
                        invincible = true;
                        invincibleTimer = 2500;
                        playSound("shield");

                        // âœ¨ Boost the ship glow when collecting a drop
                        shipGlow.radius = 35; // Temporarily increase glow
                        setTimeout(() => { shipGlow.radius = 20; }, 500); // Reset after 500ms
                    }

                    if (item.emoji === "ğŸ¦â€ğŸ”¥") {
                        console.log("ğŸ¦â€ğŸ”¥ Time Slowdown Activated!");
                        slowDownTime();
                    }

                    if (item.emoji === "ğŸ”«") {
                        inventory["ğŸ”«"]++;
                        armor += 10; // Increase armor
                        updateArmorBar();

                        // Apply the first armor skin when collecting the first gun
                        if (inventory["ğŸ”«"] === 1) {
                            shipHasArmorSkin = true;
                        }

                        // Apply the laser skin when collecting three guns
                        if (inventory["ğŸ”«"] >= 3) {
                            shipHasLaserSkin = true;
                        }

                        updateInventoryDisplay();
                    }

                    if (item.emoji === "ğŸ’©") {
                        console.log("ğŸ’© Diamond collected! Movement sensitivity reduced!");
                        currentAcceleration = slowAcceleration;
                        slowMovementTimer = 1500;
                    }

                    if (item.emoji === "ğŸ”‹") {
                        mana = Math.min(mana + 30, maxMana); // Recupera 30 de mana sem ultrapassar o mÃ¡ximo
                        updateManaBar();
                        console.log("âš¡ Mana recuperada!");
                    }

                    if (item.emoji === "â˜¢ï¸") {
                        console.log("â˜¢ï¸ RADIATION EXPLOSION ACTIVATED!");
                        explodeAllObstacles();
                    }
                }
            }
        }

        function slowDownTime() {
            window.isTimeSlowed = true;

            const originalSpeed = obstacleSpeed; // Store the original speed
            const originalBackgroundSpeed = backgroundSpeed; // Store the original speed

            obstacleSpeed *= 0.4; // Slow down time (reduce speed by half)
            backgroundSpeed *= .4;
            console.log("Game slowed down!");

            // Restore speed after 5 seconds
            setTimeout(() => {
                console.log("Game speed restored!");
                window.isTimeSlowed = false; // Allow future slowdowns
            }, 5000);
        }

        function explodeAllObstacles() {
            if (obstacles.length === 0) return;

            playSound("explosionAll");

            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obstacle = obstacles[i];

                // Get obstacle position and size
                let explosionX = obstacle.x + obstacle.width / 2;
                let explosionY = obstacle.y + obstacle.height / 2;

                // Create explosion effect
                createExplosion(explosionX, explosionY);

                // Remove obstacle from game
                obstacles.splice(i, 1);
            }

            console.log("ğŸ’¥ ALL OBSTACLES DESTROYED!");
        }

        function loseLife() {
            if (isHit) return; // Prevent multiple hits in a short time
            isHit = true;
            isExploding = true; // ğŸš¨ Set exploding state to keep rendering

            playSound("explosion");

            lives--; // Subtract 1 life
            console.log(`ğŸ’¥ Ship hit! Lives left: ${lives}`);

            createExplosion(shipX + shipWidth / 2, shipY + shipHeight / 2); // Generate explosion effect

            // **Stop ship movement, obstacles, but keep explosion running**
            shipVelocity = 0;
            shipXVelocity = 0;

            setTimeout(() => {
                isExploding = false; // Stop explosion effect after delay
                if (lives > 0) {
                    playSound("risada");
                    restartAfterHit();
                } else {
                    gameOver = true;
                    playSound("gameover");
                    gameOverScreen.style.display = 'flex';
                    gameOverScreen.style.fontSize = 40;
                    gameOverScoreDisplay.textContent = `${score}`;
                }

            }, 2000); // 2-second delay before restarting

            mana = maxMana; // Reseta a mana ao perder uma vida
            armor = 0; // Reset armor
            inventory["ğŸ”«"] = 0;
            updateManaBar();
        }

        function restartAfterHit() {
            console.log("âª Restarting after hit...");

            // Reset explosion state
            isHit = false;
            isExploding = false;

            // Reset ship position and movement
            shipY = canvas.height / 2;
            shipVelocity = 0;
            shipX = canvas.width * 0.2;
            shipXVelocity = 0;

            // Restore obstacle movement
            // obstacleSpeed = .4;

            // Temporary invincibility after hit
            invincible = true;
            invincibleTimer = 600;

            inventory['x'] = 0

            canShoot = false;
            shootTimer = 0;
        }

        // Handle keyboard input
        const keys = {};


        let touchStartX = null;
        let touchStartY = null;
        let touchStartTime = null;
        let isMoving = false; // Track if the user is swiping or tapping

        window.addEventListener("touchstart", (e) => {
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                touchStartTime = Date.now();
                isMoving = false; // Reset movement state
            }
        });

        window.addEventListener("touchmove", (e) => {
            if (touchStartX === null || touchStartY === null) return;

            let touchX = e.touches[0].clientX;
            let touchY = e.touches[0].clientY;
            let deltaX = touchX - touchStartX;
            let deltaY = touchY - touchStartY;

            let movementThreshold = 10; // Lower threshold for smoother control
            let adjustedTouchSensitivity = currentAcceleration * 20; // Adjust movement strength

            // **Detect swipe movement in both directions**
            if (Math.abs(deltaX) > movementThreshold || Math.abs(deltaY) > movementThreshold) {
                isMoving = true; // Mark as a movement (not a tap)

                // **Allow diagonal movement naturally**
                shipXVelocity += (deltaX * adjustedTouchSensitivity) * 0.02;
                shipVelocity += (deltaY * adjustedTouchSensitivity) * 0.08;

                // **Update last touch position for smoother movement**
                touchStartX = touchX;
                touchStartY = touchY;
            }
        });

        window.addEventListener("touchend", (e) => {
            if (touchStartX === null || touchStartY === null) return;

            let touchEndX = e.changedTouches[0].clientX;
            let touchEndY = e.changedTouches[0].clientY;
            let touchEndTime = Date.now();

            let deltaX = touchEndX - touchStartX;
            let deltaY = touchEndY - touchStartY;
            let timeDiff = touchEndTime - touchStartTime;

            let tapThreshold = 120; // Max time for a tap (milliseconds)
            let minMovement = 20; // Ignore very small accidental movements

            // **Detect a tap (not a swipe) â†’ SHOOT**
            if (!isMoving && timeDiff < tapThreshold && Math.abs(deltaX) < minMovement && Math.abs(deltaY) < minMovement) {
                shoot();
            }

            // Reset touch tracking
            touchStartX = null;
            touchStartY = null;
            touchStartTime = null;
        });


        window.addEventListener('keydown', e => {
            keys[e.key] = true;
        });
        window.addEventListener('keyup', e => {
            keys[e.key] = false;
        });
        window.addEventListener("keydown", (e) => {
            if (e.key === " " || e.code === "Space") {
                shoot();
            }
        });

        function handleInput() {
            if (keys['w'] || keys['W'] || keys['ArrowUp']) {
                shipVelocity -= currentAcceleration * 4;
            }
            if (keys['s'] || keys['S'] || keys['ArrowDown']) {
                shipVelocity += currentAcceleration * 2;
            }
            if (keys['a'] || keys['A'] || keys['ArrowLeft']) {
                shipXVelocity -= currentAcceleration * 1.2;
            }
            if (keys['d'] || keys['D'] || keys['ArrowRight']) {
                shipXVelocity += currentAcceleration;
            }
        }

        // Update game state
        let nextCollectibleTime = gameTime + Math.floor(Math.random() * 500) + 300; // Initial random delay

        function updateGame() {
            if (!gameStarted || gameOver || isHit) return;

            gameTime++;
            handleInput();

            if (invincible) {
                invincibleTimer--;
                if (invincibleTimer <= 0) {
                    invincible = false;
                    console.log("Invincibility Over!");
                }
            }

            // Move ship vertically
            shipVelocity += gravity;
            shipVelocity *= 0.6;
            shipY += shipVelocity;

            // Limit ship velocity
            if (shipVelocity > 10) shipVelocity = 10;
            if (shipVelocity < -10) shipVelocity = -10;

            // Apply friction to smooth horizontal movement
            shipXVelocity *= shipFriction;
            shipX += shipXVelocity;

            // Prevent out-of-bounds movement
            if (shipX < 0) shipX = 0;
            if (shipX > canvas.width - shipWidth) shipX = canvas.width - shipWidth;
            if (shipY < ceilingLevel) shipY = ceilingLevel;
            if (shipY > groundLevel - shipHeight) shipY = groundLevel - shipHeight;

            // Add ship trail particles
            if (gameTime % 2 === 0) {
                createShipTrail();
            }

            updateStalactites();

            if (gameTime >= nextStalactiteTime) {
                createStalactite();
                nextStalactiteTime = gameTime + Math.floor(Math.random() * 1000) + 800; // Next spawn in 800-1800 frames
            }

             // ğŸš€ **Check High Speed for Ghost Sound Effect**
            if (obstacleSpeed > fastSpeedThreshold) {
                playSound("ghost");
            }

            updateParticles();

            // Move obstacles using `obstacleSpeed`
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].x -= obstacleSpeed;
                if (obstacles[i].x < -obstacles[i].width) {
                    obstacles.splice(i, 1);
                }
            }

            // Move collectibles using `obstacleSpeed`
            for (let i = activeCollectibles.length - 1; i >= 0; i--) {
                activeCollectibles[i].x -= obstacleSpeed;
                if (activeCollectibles[i].x < -50) {
                    activeCollectibles.splice(i, 1);
                }
            }

            // Spawn collectibles occasionally
            if (gameTime >= nextCollectibleTime) {
                createCollectible();
                nextCollectibleTime = gameTime + Math.floor(Math.random() * 500) + 300; // Set next spawn
            }


            // Adjust the spawn frequency based on obstacle speed
            let obstacleSpawnRate = Math.max(80, 200 - obstacleSpeed * 20);
            // Faster speed = more frequent obstacles, but never less than 80 frames apart

            // Spawn obstacles dynamically
            if (gameTime - lastObstacleTime > obstacleSpawnRate) {
                createObstacle();
                lastObstacleTime = gameTime;
            }

            // Reduce shooting timer
            if (canShoot && shootTimer > 0) {
                shootTimer--;
                if (shootTimer <= 0) {
                    canShoot = false;
                    console.log("ğŸ¦â€ğŸ”¥ Shooting ability expired!");
                }
            }

            if (slowMovementTimer > 0) {
                slowMovementTimer--;
                if (slowMovementTimer <= 0) {
                    currentAcceleration = normalAcceleration;
                    console.log("ğŸ¦â€ğŸ”¥ Diamond effect over! Movement back to normal.");
                }
            }

            checkCollisions();

            // Update UI
            scoreDisplay.innerHTML = `Score\n${score}`;
            document.getElementById('lives').innerHTML = `â¤ï¸ Vidas ${lives}`;
        }


        // Main draw function
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawBackground();   // Draw background first
            drawObstacles();    // Then obstacles
            drawStalactites();
            drawParticles();    // Then ship trail
            drawCollectibles();

            if (!isHit) drawShip();  // âŒ Hide ship if hit
            drawExplosion();  // Draw explosion effect

            drawGroundAndCeiling(); // Finally, draw ceiling & ground
        }

        function updateInventoryDisplay() {
            const inventoryDisplay = document.getElementById('inventory');
            inventoryDisplay.innerHTML = `
                ğŸ’€ ${inventory["ğŸ’€"]}
                ğŸ’© ${inventory["ğŸ’©"]}
                ğŸ”« ${inventory["ğŸ”«"]}
                ğŸ¦â€ğŸ”¥ ${inventory["ğŸ¦â€ğŸ”¥"]}
                â˜¢ï¸ ${inventory["â˜¢ï¸"]}`
        }


        // Game loop
        function gameLoop() {
            if (!gameOver) {
                if (!isExploding) { // ğŸš¨ Only stop updates, not rendering
                    updateGame();
                    updateShooting();
                }
                updateExplosion(); // âœ… Always update explosion effect
            }

            draw();
            drawBullets();
            drawLaser();
            drawExplosion(); // âœ… Ensure explosion is drawn

            requestAnimationFrame(gameLoop);
        }

        // Start the game
        startButton.addEventListener('click', () => {
            if (isMobile) requestFullScreen();
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none'; // Hide Game Over screen if visible
            gameStarted = true;
            startMusic();
            createBackgroundLayers();
            gameLoop();
        });

        // Restart the game
        restartButton.addEventListener('click', () => {
            console.log("ğŸ”„ Restarting game...");

            // Stop any ongoing animations
            cancelAnimationFrame(gameLoop);

            // Hide game over screen
            gameOverScreen.style.display = 'none';

            // Reset game state
            gameStarted = true;
            gameOver = false;
            isExploding = false;  // Ensure ship is not "exploding"
            isHit = false;        // Prevent blinking effect
            flickerCount = 0;

            // Reset ship position and movement
            shipY = canvas.height / 2;
            shipX = canvas.width * 0.2;
            shipVelocity = 0;
            shipXVelocity = 0;

            backgroundSpeed = 5;
            obstacleSpeed = 1;

            // Reset obstacles, collectibles, and inventory
            obstacles = [];
            activeCollectibles = [];
            let inventory = { "ğŸ’€": 0, "ğŸ’©": 0, "ğŸ”«": 0, "ğŸ¦â€ğŸ”¥": 0, "â˜¢ï¸": 0 };

            // Reset timers and speeds
            lastObstacleTime = 0;
            lastCollectibleTime = 0;
            gameTime = 0;
            lives = 5;
            invincible = false;
            invincibleTimer = 0;

            // Reset UI
            score = 0;
            scoreDisplay.textContent = `Score\n${score}`;
            document.getElementById('lives').innerHTML = `â¤ï¸ Vidas ${lives}`;
            updateInventoryDisplay();

            // Reset background and start fresh
            createBackgroundLayers();

            // Restart the game loop
            requestAnimationFrame(gameLoop);
        });

        function checkLifeGain() {
            let inventorySum = Object.values(inventory).reduce((sum, value) => sum + value, 0);

            if (inventorySum > 0 && inventorySum % 10 === 0) {
                lives++;
                playSound('life')
                console.log(`ğŸ‰ Extra life awarded! Lives: ${lives}`);
                document.getElementById('lives').innerHTML = `â¤ï¸ Vidas ${lives}`;
            }
        }

        // Handle game over
        function handleGameOver() {
            if (gameOver) {
                gameOverScreen.style.display = 'flex';
                gameOverScreen.style.fontSize = 40;
                gameOverScoreDisplay.textContent = score;
            }
        }

        window.addEventListener("load", () => {
            document.body.addEventListener("click", function playStartupSound() {
                playSound('music1')
                playSound('startup')
                document.body.removeEventListener("click", playStartupSound); // Remove listener after playing
            });
        });

        // Set up resize handler
        window.addEventListener('resize', () => {
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                groundLevel = canvas.height * 0.8;
                ceilingLevel = canvas.height * 0.2;

                if (/iPhone|iPad|Android|Mobile/i.test(navigator.userAgent)) {
                    groundLevel = canvas.height * 0.95; // ğŸ“± 5% ceiling/floor
                    ceilingLevel = canvas.height * 0.05;
                } else {
                    groundLevel = canvas.height * 0.9; // ğŸ–¥ï¸ 10% ceiling/floor
                    ceilingLevel = canvas.height * 0.1;
                }

                shipY = canvas.height / 2;
                gravity = /iPhone|iPad|Android|Mobile/i.test(navigator.userAgent) ? mobileGravity : normalGravity;
            }

            // Resize once on load & listen for screen changes
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            groundLevel = canvas.height * 0.8;
            ceilingLevel = canvas.height * 0.2;
            shipY = canvas.height / 2;
        });

        // ğŸ“± Function to enable Fullscreen on mobile
        function requestFullScreen() {
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
            } else if (document.documentElement.mozRequestFullScreen) {
                document.documentElement.mozRequestFullScreen();
            } else if (document.documentElement.webkitRequestFullscreen) {
                document.documentElement.webkitRequestFullscreen();
            } else if (document.documentElement.msRequestFullscreen) {
                document.documentElement.msRequestFullscreen();
            }
        }

        // Start animation
        gameLoop();

        // Check for game over in a separate interval
        setInterval(handleGameOver, 100);
    </script>
</body>
</html>