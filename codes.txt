[jogo_memoria.html]
<!DOCTYPE html>
<html>
<!-- Previous styles remain the same -->
<head>
<style>
    /* All previous styles remain exactly the same */
    body {
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #6366f1, #a855f7);
      min-height: 100vh;
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .container {
      background: rgba(255, 255, 255, 0.95);
      padding: 2rem;
      border-radius: 1rem;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
    }

    .stats {
      display: flex;
      gap: 2rem;
      font-size: 1.25rem;
    }

    .stat {
      background: #f3f4f6;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
    }

    .game-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .card {
      aspect-ratio: 1;
      font-size: 2.5rem;
      background: #fff;
      border: 2px solid #e5e7eb;
      border-radius: 0.5rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.3s ease;
      transform-style: preserve-3d;
    }

    .card.flipped {
      transform: rotateY(180deg);
    }

    .card:hover {
      border-color: #6366f1;
    }

    .card-front, .card-back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .card-back {
      background: #6366f1;
      transform: rotateY(180deg);
      border-radius: 0.3rem;
    }

    button {
      background: #6366f1;
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      font-size: 1rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    button:hover {
      background: #4f46e5;
    }

    .game-over {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 2rem;
      flex-direction: column;
      gap: 1rem;
    }

    .game-over.show {
      display: flex;
    }

    .preview-message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 1rem 2rem;
      border-radius: 0.5rem;
      font-size: 1.5rem;
      display: none;
    }

    .preview-message.show {
      display: block;
    }
</style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="stats">
        <div class="stat">Pontos: <span id="score">0</span></div>
        <div class="stat">Tempo: <span id="timer">60</span>s</div>
      </div>
      <button id="restart">Reiniciar Jogo</button>
    </div>
    <div class="game-grid" id="gameGrid"></div>
  </div>

  <div class="game-over" id="gameOver">
    <h2>Fim de Jogo!</h2>
    <p>Pontua√ß√£o Final: <span id="finalScore">0</span></p>
    <button onclick="restartGame()">Jogar Novamente</button>
  </div>

  <div class="preview-message" id="previewMessage">
    Memorize as cartas!
  </div>

  <script>
    const emojis = [
      // Animais
      'ü¶ä', 'üêº', 'ü¶Å', 'üêØ', 'üê®', 'üê∏', 'üê∑', 'ü¶í', 'ü¶ò', 'ü¶•',
      // Comidas
      'üçï', 'üçî', 'üåÆ', 'üç£', 'üçú', 'ü•ê', 'ü•®', 'ü•û', 'üßá', 'ü•™',
      // Esportes
      '‚öΩÔ∏è', 'üèÄ', 'üéæ', 'üèà', '‚öæÔ∏è', 'üè∏', 'üèì', 'üé±', 'ü•ä', '‚õ∏Ô∏è',
      // Flores
      'üå∏', 'üå∫', 'üåπ', 'üå∑', 'üåª', 'üåº', 'üíê', 'üåø', 'üçÄ', 'üåµ',
      // Transportes
      'üöó', '‚úàÔ∏è', 'üöÇ', 'üö¢', 'üö≤', 'üõµ', 'üöÅ', 'üöÄ', 'üõ∏', 'üö§',
      // Clima
      '‚òÄÔ∏è', 'üåô', '‚≠êÔ∏è', '‚òÅÔ∏è', 'üåà', '‚ùÑÔ∏è', '‚õàÔ∏è', 'üå™Ô∏è', 'üåä', '‚ö°Ô∏è',
      // Frutas
      'üçé', 'üçå', 'üçá', 'üçä', 'üçì', 'ü•ù', 'üçç', 'ü•≠', 'üçê', 'ü´ê',
      // Profiss√µes
      'üë®‚Äç‚öïÔ∏è', 'üë©‚Äçüè´', 'üë®‚Äçüç≥', 'üë©‚ÄçüöÄ', 'üë®‚Äçüåæ', 'üë©‚Äçüè≠', 'üë®‚Äçüíª', 'üë©‚Äçüî¨', 'üë®‚Äçüé®', 'üë©‚Äç‚úàÔ∏è',
      // Instrumentos
      'üé∏', 'üéπ', 'üé∫', 'üéª', 'ü•Å', 'ü™ò', 'üé∑', 'ü™ó', 'üìØ', 'üéº',
      // Animais Marinhos
      'üêã', 'üê¨', 'ü¶à', 'üêü', 'üê†', 'ü¶Ä', 'ü¶û', 'üêô', 'ü¶ë', 'üê°',
      // Doces
      'üç¶', 'üç∞', 'üßÅ', 'üç™', 'üç´', 'üç¨', 'üç≠', 'üçÆ', 'üçØ', 'üç©',
      // Express√µes
      'üòä', 'ü•∞', 'üòé', 'ü§ì', 'ü§Ø', 'ü•≥', 'üò¥', 'ü§†', 'üòá', 'ü§™'
    ];

    let flippedCards = [];
    let matchedPairs = 0;
    let score = 0;
    let timeLeft = 60;
    let gameTimer;
    let isGameOver = false;
    let canFlip = false;

    function shuffleArray(array) {
      const newArray = [...array];
      for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
      }
      return newArray;
    }

    function createGame() {
      const gameGrid = document.getElementById('gameGrid');
      const selectedEmojis = shuffleArray(emojis).slice(0, 8);
      const gameEmojis = shuffleArray([...selectedEmojis, ...selectedEmojis]);

      gameGrid.innerHTML = '';
      gameEmojis.forEach((emoji, index) => {
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `
          <div class="card-front"></div>
          <div class="card-back">${emoji}</div>
        `;
        card.dataset.emoji = emoji;
        card.dataset.index = index;
        card.addEventListener('click', handleCardClick);
        gameGrid.appendChild(card);
      });

      showPreview();
    }

    function showPreview() {
      const previewMessage = document.getElementById('previewMessage');
      previewMessage.classList.add('show');

      const cards = document.querySelectorAll('.card');
      cards.forEach(card => card.classList.add('flipped'));

      setTimeout(() => {
        cards.forEach(card => card.classList.remove('flipped'));
        previewMessage.classList.remove('show');
        canFlip = true;
      }, 3000);
    }

    function handleCardClick(e) {
      if (isGameOver || !canFlip) return;

      const card = e.currentTarget;
      if (
        flippedCards.length === 2 ||
        flippedCards.includes(card) ||
        card.classList.contains('matched')
      ) {
        return;
      }

      card.classList.add('flipped');
      flippedCards.push(card);

      if (flippedCards.length === 2) {
        checkMatch();
      }
    }

    function checkMatch() {
      const [card1, card2] = flippedCards;
      const match = card1.dataset.emoji === card2.dataset.emoji;

      if (match) {
        card1.classList.add('matched');
        card2.classList.add('matched');
        matchedPairs++;
        score += 10;
        document.getElementById('score').textContent = score;

        if (matchedPairs === 8) {
          endGame(true);
        }
      } else {
        setTimeout(() => {
          card1.classList.remove('flipped');
          card2.classList.remove('flipped');
        }, 1000);
        score = Math.max(0, score - 1);
        document.getElementById('score').textContent = score;
      }

      setTimeout(() => {
        flippedCards = [];
      }, 1000);
    }

    function startTimer() {
      gameTimer = setInterval(() => {
        timeLeft--;
        document.getElementById('timer').textContent = timeLeft;

        if (timeLeft <= 0) {
          endGame(false);
        }
      }, 1000);
    }

    function endGame(isWin) {
      isGameOver = true;
      clearInterval(gameTimer);
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOver').classList.add('show');
    }

    function restartGame() {
      flippedCards = [];
      matchedPairs = 0;
      score = 0;
      timeLeft = 60;
      isGameOver = false;
      canFlip = false;

      document.getElementById('score').textContent = score;
      document.getElementById('timer').textContent = timeLeft;
      document.getElementById('gameOver').classList.remove('show');

      clearInterval(gameTimer);
      createGame();
      startTimer();
    }

    document.getElementById('restart').addEventListener('click', restartGame);

    // Initialize the game
    createGame();
    startTimer();
  </script>
</body>
</html>

[gravidade_planetas.py]
import pygame
import random
import math

# Inicializa o Pygame
pygame.init()

# Configura√ß√µes da Tela
LARGURA, ALTURA = 900, 900
tela = pygame.display.set_mode((LARGURA, ALTURA))
pygame.display.set_caption("Simulador de Gravidade")

# Cores
BRANCO = (255, 255, 255)
PRETO = (20, 20, 30)
AZUL = (50, 150, 255)
VERDE = (50, 130, 50)
VERMELHO = (255, 50, 50)
CINZA = (100, 100, 100)
AMARELO = (255, 215, 0)

GRAVIDADE_MIN = 0.05  # Gravidade m√≠nima
GRAVIDADE_MAX = 30.0 / 10  # Gravidade m√°xima

cores = [AZUL, VERDE, VERMELHO, AMARELO]

# Rel√≥gio para controle de FPS
clock = pygame.time.Clock()

# Gravidade inicial (Terra)
selected_planet = "Terra"
gravidade = 9.8 / 10  # Ajustado para a escala do jogo

# Planetas e suas gravidades (m/s¬≤ convertidos para escala do jogo)
planetas = {
    "Lua": 1.6 / 10,
    "Merc√∫rio": 3.7 / 10,
    "V√™nus": 8.9 / 10,
    "Terra": 9.8 / 10,
    "Marte": 3.7 / 10,
    "J√∫piter": 24.8 / 10,
    "Saturno": 10.4 / 10,
    "Urano": 8.7 / 10,
    "Netuno": 11.2 / 10
}

# Classe para representar uma bola
class Bola:
    def __init__(self, x, y, raio, cor):
        self.x = x
        self.y = y
        self.raio = raio
        self.cor = cor
        self.vel_x = random.uniform(-3, 3)  # Velocidade horizontal aleat√≥ria
        self.vel_y = 0  # Velocidade vertical
        self.restituicao = 0.8  # Quanto da energia √© preservada ao quicar

    def atualizar(self):
        # Aplica a gravidade
        self.vel_y += gravidade
        self.x += self.vel_x
        self.y += self.vel_y

        # Se atingir o ch√£o, quica
        if self.y + self.raio > ALTURA:
            self.y = ALTURA - self.raio
            self.vel_y *= -self.restituicao  # Invertemos a dire√ß√£o e aplicamos amortecimento

        # Se atingir as laterais, inverte a velocidade X
        if self.x - self.raio < 0 or self.x + self.raio > LARGURA:
            self.vel_x *= -self.restituicao

    def desenhar(self, tela):
        pygame.draw.circle(tela, self.cor, (int(self.x), int(self.y)), self.raio)

# Verifica e resolve colis√µes entre bolas
def resolver_colisoes(bolas):
    for i in range(len(bolas)):
        for j in range(i + 1, len(bolas)):
            bola1, bola2 = bolas[i], bolas[j]
            dx = bola2.x - bola1.x
            dy = bola2.y - bola1.y
            distancia = math.sqrt(dx**2 + dy**2)

            if distancia < bola1.raio + bola2.raio:  # Se houver colis√£o
                # Calcula o √¢ngulo da colis√£o
                angulo = math.atan2(dy, dx)

                # Separa as bolas para evitar sobreposi√ß√£o
                overlap = (bola1.raio + bola2.raio) - distancia
                bola1.x -= math.cos(angulo) * overlap / 2
                bola1.y -= math.sin(angulo) * overlap / 2
                bola2.x += math.cos(angulo) * overlap / 2
                bola2.y += math.sin(angulo) * overlap / 2

                # Velocidade ap√≥s a colis√£o (baseado em conserva√ß√£o de momento)
                vel1_proj = bola1.vel_x * math.cos(angulo) + bola1.vel_y * math.sin(angulo)
                vel2_proj = bola2.vel_x * math.cos(angulo) + bola2.vel_y * math.sin(angulo)

                bola1.vel_x += (vel2_proj - vel1_proj) * math.cos(angulo)
                bola1.vel_y += (vel2_proj - vel1_proj) * math.sin(angulo)
                bola2.vel_x += (vel1_proj - vel2_proj) * math.cos(angulo)
                bola2.vel_y += (vel1_proj - vel2_proj) * math.sin(angulo)

# Criando m√∫ltiplas bolas aleat√≥rias
def criar_bolas():
    return [Bola(random.randint(50, LARGURA - 50), random.randint(50, 300), random.randint(10, 45), random.choice(cores)) for _ in range(10)]

bolas = criar_bolas()

# Fonte para exibir texto
fonte = pygame.font.Font(None, 30)
fonte_titulo = pygame.font.Font(None, 40)

# Fun√ß√£o para desenhar bot√µes
def desenhar_botao(tela, texto, pos, tamanho, cor_fundo, cor_texto=BRANCO):
    """Desenha um bot√£o na tela com fundo, borda e texto"""
    rect = pygame.Rect(pos[0], pos[1], tamanho[0], tamanho[1])
    pygame.draw.rect(tela, cor_fundo, rect, border_radius=10)

    # Renderiza o texto centralizado
    texto_render = fonte.render(texto, True, cor_texto)
    texto_rect = texto_render.get_rect(center=rect.center)
    tela.blit(texto_render, texto_rect)

    return rect

# Loop do jogo
rodando = True
while rodando:
    tela.fill(PRETO)

    # Captura eventos
    for evento in pygame.event.get():
        if evento.type == pygame.QUIT:
            rodando = False
        elif evento.type == pygame.MOUSEBUTTONDOWN:
            x, y = evento.pos

            # Bot√£o "Jogar de Novo"
            if botao_reset.collidepoint(x, y):
                bolas = criar_bolas()  # Reseta as bolas

            # Bot√µes "Planetas"
            for i, (planeta, g) in enumerate(planetas.items()):
                if botoes_planetas[i].collidepoint(x, y):
                    gravidade = g  # Set gravity
                    selected_planet = planeta  # Update selected planet
                    bolas = criar_bolas()  # Reset balls

    # Atualiza e resolve colis√µes entre bolas
    for bola in bolas:
        bola.atualizar()
    resolver_colisoes(bolas)

    # Desenha as bolas
    for bola in bolas:
        bola.desenhar(tela)

    # Bot√£o de rein√≠cio
    botao_reset = desenhar_botao(tela, "Jogar de Novo", (LARGURA - 160, 20), (160, 40), VERMELHO)

    # T√≠tulo "Planetas"
    texto_planetas = fonte_titulo.render("Escolha um planeta:", True, BRANCO)
    tela.blit(texto_planetas, (50, 70))

    # Draw planet buttons with correct highlighting
    botoes_planetas = []
    for i, (planeta, g) in enumerate(planetas.items()):
        cor_botao = VERDE if planeta == selected_planet else AZUL  # Highlight selected planet
        botao = desenhar_botao(tela, planeta, (50 + (i % 4) * 190, 110 + (i // 4) * 50), (180, 40), cor_botao)
        botoes_planetas.append(botao)

    pygame.display.flip()
    clock.tick(60)

pygame.quit()

[tetris.py]
import pygame, random

pygame.init()
LARGURA, ALTURA, TAMANHO = 300, 600, 30
COLUNAS, LINHAS = LARGURA // TAMANHO, ALTURA // TAMANHO
tela = pygame.display.set_mode((LARGURA, ALTURA))
relogio = pygame.time.Clock()
velocidade = 3

FUNDO, CORES = "#000000", ["#FF3232", "#32FF32", "#3232FF", "#FFFF32", "#FF32FF"]

FORMAS = [
    [[1, 1, 1], [0, 1, 0]],  # T
    [[1, 1, 1, 1]],           # I
    [[1, 1], [1, 1]],         # O
    [[1, 1, 0], [0, 1, 1]],   # Z
    [[0, 1, 1], [1, 1, 0]],   # S
    [[1, 1, 0], [1, 1]],      # L
    [[0, 1, 1], [1, 1]]       # J
]

grade = [[0] * COLUNAS for _ in range(LINHAS)]

class Bloco:
    def __init__(self):
        self.forma = random.choice(FORMAS)
        self.cor = pygame.Color(random.choice(CORES))
        self.x, self.y = COLUNAS // 2 - len(self.forma[0]) // 2, 0

    def girar(self):
        nova_forma = list(zip(*self.forma[::-1]))
        if not self.colisao(0, 0, nova_forma):
            self.forma = nova_forma

    def mover(self, dx, dy):
        if not self.colisao(dx, dy):
            self.x += dx
            self.y += dy
        elif dy:
            for i, linha in enumerate(self.forma):
                for j, valor in enumerate(linha):
                    if valor:
                        grade[self.y + i][self.x + j] = self.cor
            return False
        return True

    def colisao(self, dx, dy, forma=None):
        forma = forma or self.forma
        for i, linha in enumerate(forma):
            for j, valor in enumerate(linha):
                if valor:
                    nx, ny = self.x + j + dx, self.y + i + dy
                    if nx < 0 or nx >= COLUNAS or ny >= LINHAS or (ny >= 0 and grade[ny][nx]):
                        return True
        return False

def limpar_linhas():
    global grade
    grade = [linha for linha in grade if any(celula == 0 for celula in linha)]
    while len(grade) < LINHAS:
        grade.insert(0, [0] * COLUNAS)

bloco = Bloco()
rodando, tempo_queda = True, 0

while rodando:
    tela.fill(FUNDO)
    for evento in pygame.event.get():
        if evento.type == pygame.QUIT:
            rodando = False
        elif evento.type == pygame.KEYDOWN:
            if evento.key == pygame.K_LEFT:
                bloco.mover(-1, 0)
            if evento.key == pygame.K_RIGHT:
                bloco.mover(1, 0)
            if evento.key == pygame.K_DOWN:
                bloco.mover(0, 1)
            if evento.key == pygame.K_UP:
                bloco.girar()

    tempo_queda += 1
    if tempo_queda > 60 // velocidade:
        if not bloco.mover(0, 1):
            limpar_linhas()
            bloco = Bloco()
        tempo_queda = 0

    for y, linha in enumerate(grade):
        for x, cor in enumerate(linha):
            if cor:
                pygame.draw.rect(tela, cor, (x * TAMANHO, y * TAMANHO, TAMANHO, TAMANHO), border_radius=5)

    for i, linha in enumerate(bloco.forma):
        for j, valor in enumerate(linha):
            if valor:
                pygame.draw.rect(tela, bloco.cor, ((bloco.x + j) * TAMANHO, (bloco.y + i) * TAMANHO, TAMANHO, TAMANHO), border_radius=5)

    pygame.display.flip()
    relogio.tick(60)

pygame.quit()

[planetas.py]
import turtle
import math
import random

screen = turtle.Screen()
screen.bgcolor("black")
screen.tracer(0)

def criar_estrelas(num_estrelas):
    estrelas = []
    for _ in range(num_estrelas):
        estrela = turtle.Turtle()
        estrela.shape("circle")
        estrela.color("white")
        estrela.shapesize(random.uniform(0.05, 0.15))
        estrela.penup()
        estrela.goto(random.randint(-800, 800), random.randint(-400, 400))
        estrelas.append(estrela)
    return estrelas

criar_estrelas(300)

sun = turtle.Turtle()
sun.shape("circle")
sun.color("#FFD700")
sun.shapesize(2)

planets = [
    ("Merc√∫rio", "#8B8B83", 0.4, 50, 2),
    ("V√™nus", "#E6B800", 0.6, 80, 1.5),
    ("Terra", "#0077BE", 0.8, 120, 1.2),
    ("Marte", "#FF4500", 0.7, 160, 1),
    ("J√∫piter", "#D2B48C", 1.5, 220, 0.8),
    ("Saturno", "#F4A460", 1.3, 280, 0.6),
    ("Urano", "#40E0D0", 1.1, 340, 0.5),
    ("Netuno", "#0000FF", 1.0, 400, 0.4)
]

planet_turtles = []
for planet in planets:
    name, color, size, distance, speed = planet
    p = turtle.Turtle()
    p.shape("circle")
    p.color(color)
    p.shapesize(size)
    p.penup()
    p.goto(distance, 0)
    p.pendown()
    planet_turtles.append((p, distance, speed, 0))

def move_planets():
    for planet in planet_turtles:
        p, distance, speed, angle = planet
        x = distance * math.cos(math.radians(angle))
        y = distance * math.sin(math.radians(angle))
        p.goto(x, y)
        planet_turtles[planet_turtles.index(planet)] = (p, distance, speed, angle + speed)

while True:
    screen.update()
    move_planets()
    turtle.time.sleep(0.03)

[aquario.py]
import turtle
import random

screen = turtle.Screen()
screen.bgcolor("lightblue")
screen.setup(width=1400, height=900)

def create_fish_shape():
    turtle.begin_poly()
    turtle.forward(30)
    turtle.left(120)
    turtle.forward(30)
    turtle.left(120)
    turtle.forward(30)
    turtle.left(120)
    turtle.end_poly()
    body = turtle.get_poly()

    turtle.begin_poly()
    turtle.forward(30)
    turtle.right(120)
    turtle.forward(30)
    turtle.right(120)
    turtle.forward(30)
    turtle.right(120)
    turtle.end_poly()
    tail = turtle.get_poly()

    screen.addshape("fish_body", body)
    screen.addshape("fish_tail", tail)

def create_fish():

    fish_color = random.choice(["coral", "gold", "firebrick",
                                "magenta", "green", "red"])
    body = turtle.Turtle()
    body.shape("fish_body")
    body.color(fish_color)
    body.penup()
    body.speed(0)
    body.setpos(random.randint(-380, 380), random.randint(-280, 280))
    body.setheading(random.randint(0, 360))

    tail = turtle.Turtle()
    tail.shape("fish_tail")
    tail.color(fish_color)
    tail.penup()
    tail.speed(0)
    tail.setpos(body.pos())
    tail.setheading(body.heading())

    return body, tail

create_fish_shape()

peixes = [create_fish() for _ in range(30)]

while True:
    for body, tail in peixes:
        if random.random() < 0.1:
            turn = random.randint(-70, 70)
            body.left(turn)
            tail.left(turn)

        body.forward(10)
        tail.forward(10)

        x, y = body.pos()
        if abs(x) > 700 or abs(y) > 450:
            body.setheading(body.heading() + 90)
            tail.setheading(tail.heading() + 90)


[relogio.py]
import os

import time
digits = {
    '0': ['  ***  ', ' *   * ', '*     *', '*     *', ' *   * ', '  ***  '],
    '1': ['   *   ', '  **   ', '   *   ', '   *   ', '   *   ', '  ***  '],
    '2': [' ***** ', '*     *', '     * ', '   *   ', ' *     ', '*******'],
    '3': [' ***** ', '      *', '  **** ', '      *', '      *', ' ***** '],
    '4': ['*     *', '*     *', ' ******', '      *', '      *', '      *'],
    '5': ['*******', '*      ', '****** ', '      *', '      *', '****** '],
    '6': [' ***** ', '*      ', '* **** ', '*     *', '*     *', ' ***** '],
    '7': ['*******', '     * ', '    *  ', '   *   ', '  *    ', ' *     '],
    '8': [' ***** ', '*     *', ' ***** ', '*     *', '*     *', ' ***** '],
    '9': [' ***** ', '*     *', '* **** ', '      *', '      *', ' ***** '],
    ':': ['       ', '   *   ', '       ', '   *   ', '       ', '       ']
}
while True:
    current_time = time.strftime("%H:%M:%S")
    for row in range(6):
        for char in current_time:
            print(digits[char][row], end=' ')
        print()
    print()
    time.sleep(1)
    os.system('clear')
    print()

[particulas.py]
import pygame, random, math

pygame.init()
tela = pygame.display.set_mode((800, 600))
cores = ["#FF3232", "#32FF32", "#3232FF", "#FFFF32", "#FF32FF"]
particulas = []

rodando = True
while rodando:
    tela.fill("#000000")
    for e in pygame.event.get():
        if e.type == pygame.QUIT:
            rodando = False

    x, y = pygame.mouse.get_pos()
    particulas.append([x, y, pygame.Color(random.choice(cores)), random.uniform(3, 6), random.uniform(0, 2*math.pi)])

    for p in particulas[:]:
        p[0] += math.cos(p[4]) * 3
        p[1] += math.sin(p[4]) * 3
        p[3] *= 0.97
        pygame.draw.circle(tela, p[2], (int(p[0]), int(p[1])), int(p[3]))
        if p[3] < 1:
            particulas.remove(p)

    pygame.display.flip()
pygame.quit()

[relogio_analogico.py]
import pygame
import math
import datetime

# Inicializa o Pygame
pygame.init()

# Configura√ß√µes do rel√≥gio
LARGURA, ALTURA = 500, 500
CENTRO = (LARGURA // 2, ALTURA // 2)
RAIO = 200  # Raio do rel√≥gio
COR_FUNDO = (20, 20, 30)  # Azul escuro elegante
COR_BORDA = (240, 240, 240)  # Borda branca
COR_NUMEROS = (200, 200, 200)  # Cinza claro
COR_PONTEIRO_H = (255, 100, 100)  # Vermelho suave
COR_PONTEIRO_M = (100, 255, 100)  # Verde claro
COR_PONTEIRO_S = (100, 100, 255)  # Azul claro

# Cria√ß√£o da tela
tela = pygame.display.set_mode((LARGURA, ALTURA))
pygame.display.set_caption("Rel√≥gio Anal√≥gico Minimalista")
clock = pygame.time.Clock()

# Fun√ß√£o para desenhar ponteiros
def desenha_ponteiro(tela, angulo, comprimento, cor, largura=4):
    """Desenha um ponteiro do rel√≥gio."""
    angulo_rad = math.radians(angulo - 90)  # Ajusta o √¢ngulo para come√ßar do topo
    ponta_x = CENTRO[0] + comprimento * math.cos(angulo_rad)
    ponta_y = CENTRO[1] + comprimento * math.sin(angulo_rad)
    pygame.draw.line(tela, cor, CENTRO, (ponta_x, ponta_y), largura)

# Fun√ß√£o principal do jogo
rodando = True
while rodando:
    tela.fill(COR_FUNDO)

    # Eventos do Pygame
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            rodando = False

    # Obt√©m o hor√°rio atual
    agora = datetime.datetime.now()
    segundos = agora.second
    minutos = agora.minute + segundos / 60  # Minutos suaves
    horas = agora.hour % 12 + minutos / 60  # Horas suaves

    # Converte para √¢ngulos (360¬∞ para 60 unidades)
    ang_h = horas * 30  # 360¬∞/12h = 30¬∞ por hora
    ang_m = minutos * 6  # 360¬∞/60min = 6¬∞ por minuto
    ang_s = segundos * 6  # 360¬∞/60s = 6¬∞ por segundo

    # Desenha o c√≠rculo do rel√≥gio
    pygame.draw.circle(tela, COR_BORDA, CENTRO, RAIO, 8)  # Contorno do rel√≥gio

    # Desenha os n√∫meros do rel√≥gio
    for i in range(1, 13):
        ang_num = math.radians(i * 30 - 90)
        num_x = CENTRO[0] + (RAIO - 30) * math.cos(ang_num)
        num_y = CENTRO[1] + (RAIO - 30) * math.sin(ang_num)
        fonte = pygame.font.Font(None, 40)
        texto = fonte.render(str(i), True, COR_NUMEROS)
        tela.blit(texto, (num_x - 10, num_y - 15))

    # Desenha os ponteiros
    desenha_ponteiro(tela, ang_h, RAIO * 0.5, COR_PONTEIRO_H, 8)  # Horas
    desenha_ponteiro(tela, ang_m, RAIO * 0.7, COR_PONTEIRO_M, 6)  # Minutos
    desenha_ponteiro(tela, ang_s, RAIO * 0.9, COR_PONTEIRO_S, 2)  # Segundos

    # Desenha o centro do rel√≥gio
    pygame.draw.circle(tela, (255, 255, 255), CENTRO, 8)  # Pequeno c√≠rculo no centro

    pygame.display.flip()
    clock.tick(30)  # Suaviza a anima√ß√£o

pygame.quit()