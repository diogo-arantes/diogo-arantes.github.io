[tetris.py]
import pygame, random

pygame.init()
LARGURA, ALTURA, TAMANHO = 300, 600, 30
COLUNAS, LINHAS = LARGURA // TAMANHO, ALTURA // TAMANHO
tela = pygame.display.set_mode((LARGURA, ALTURA))
relogio = pygame.time.Clock()
velocidade = 3

FUNDO, CORES = "#000000", ["#FF3232", "#32FF32", "#3232FF", "#FFFF32", "#FF32FF"]

FORMAS = [
    [[1, 1, 1], [0, 1, 0]],  # T
    [[1, 1, 1, 1]],           # I
    [[1, 1], [1, 1]],         # O
    [[1, 1, 0], [0, 1, 1]],   # Z
    [[0, 1, 1], [1, 1, 0]],   # S
    [[1, 1, 0], [1, 1]],      # L
    [[0, 1, 1], [1, 1]]       # J
]

grade = [[0] * COLUNAS for _ in range(LINHAS)]

class Bloco:
    def __init__(self):
        self.forma = random.choice(FORMAS)
        self.cor = pygame.Color(random.choice(CORES))
        self.x, self.y = COLUNAS // 2 - len(self.forma[0]) // 2, 0

    def girar(self):
        nova_forma = list(zip(*self.forma[::-1]))
        if not self.colisao(0, 0, nova_forma):
            self.forma = nova_forma

    def mover(self, dx, dy):
        if not self.colisao(dx, dy):
            self.x += dx
            self.y += dy
        elif dy:
            for i, linha in enumerate(self.forma):
                for j, valor in enumerate(linha):
                    if valor:
                        grade[self.y + i][self.x + j] = self.cor
            return False
        return True

    def colisao(self, dx, dy, forma=None):
        forma = forma or self.forma
        for i, linha in enumerate(forma):
            for j, valor in enumerate(linha):
                if valor:
                    nx, ny = self.x + j + dx, self.y + i + dy
                    if nx < 0 or nx >= COLUNAS or ny >= LINHAS or (ny >= 0 and grade[ny][nx]):
                        return True
        return False

def limpar_linhas():
    global grade
    grade = [linha for linha in grade if any(celula == 0 for celula in linha)]
    while len(grade) < LINHAS:
        grade.insert(0, [0] * COLUNAS)

bloco = Bloco()
rodando, tempo_queda = True, 0

while rodando:
    tela.fill(FUNDO)
    for evento in pygame.event.get():
        if evento.type == pygame.QUIT:
            rodando = False
        elif evento.type == pygame.KEYDOWN:
            if evento.key == pygame.K_LEFT:
                bloco.mover(-1, 0)
            if evento.key == pygame.K_RIGHT:
                bloco.mover(1, 0)
            if evento.key == pygame.K_DOWN:
                bloco.mover(0, 1)
            if evento.key == pygame.K_UP:
                bloco.girar()

    tempo_queda += 1
    if tempo_queda > 60 // velocidade:
        if not bloco.mover(0, 1):
            limpar_linhas()
            bloco = Bloco()
        tempo_queda = 0

    for y, linha in enumerate(grade):
        for x, cor in enumerate(linha):
            if cor:
                pygame.draw.rect(tela, cor, (x * TAMANHO, y * TAMANHO, TAMANHO, TAMANHO), border_radius=5)

    for i, linha in enumerate(bloco.forma):
        for j, valor in enumerate(linha):
            if valor:
                pygame.draw.rect(tela, bloco.cor, ((bloco.x + j) * TAMANHO, (bloco.y + i) * TAMANHO, TAMANHO, TAMANHO), border_radius=5)

    pygame.display.flip()
    relogio.tick(60)

pygame.quit()

[planetas.py]
import turtle
import math
import random

screen = turtle.Screen()
screen.bgcolor("black")
screen.tracer(0)

def criar_estrelas(num_estrelas):
    estrelas = []
    for _ in range(num_estrelas):
        estrela = turtle.Turtle()
        estrela.shape("circle")
        estrela.color("white")
        estrela.shapesize(random.uniform(0.05, 0.15))
        estrela.penup()
        estrela.goto(random.randint(-800, 800), random.randint(-400, 400))
        estrelas.append(estrela)
    return estrelas

criar_estrelas(300)

sun = turtle.Turtle()
sun.shape("circle")
sun.color("#FFD700")
sun.shapesize(2)

planets = [
    ("Mercúrio", "#8B8B83", 0.4, 50, 2),
    ("Vênus", "#E6B800", 0.6, 80, 1.5),
    ("Terra", "#0077BE", 0.8, 120, 1.2),
    ("Marte", "#FF4500", 0.7, 160, 1),
    ("Júpiter", "#D2B48C", 1.5, 220, 0.8),
    ("Saturno", "#F4A460", 1.3, 280, 0.6),
    ("Urano", "#40E0D0", 1.1, 340, 0.5),
    ("Netuno", "#0000FF", 1.0, 400, 0.4)
]

planet_turtles = []
for planet in planets:
    name, color, size, distance, speed = planet
    p = turtle.Turtle()
    p.shape("circle")
    p.color(color)
    p.shapesize(size)
    p.penup()
    p.goto(distance, 0)
    p.pendown()
    planet_turtles.append((p, distance, speed, 0))

def move_planets():
    for planet in planet_turtles:
        p, distance, speed, angle = planet
        x = distance * math.cos(math.radians(angle))
        y = distance * math.sin(math.radians(angle))
        p.goto(x, y)
        planet_turtles[planet_turtles.index(planet)] = (p, distance, speed, angle + speed)

while True:
    screen.update()
    move_planets()
    turtle.time.sleep(0.03)

[aquario.py]
import turtle
import random

screen = turtle.Screen()
screen.bgcolor("lightblue")
screen.setup(width=1400, height=900)

def create_fish_shape():
    turtle.begin_poly()
    turtle.forward(30)
    turtle.left(120)
    turtle.forward(30)
    turtle.left(120)
    turtle.forward(30)
    turtle.left(120)
    turtle.end_poly()
    body = turtle.get_poly()

    turtle.begin_poly()
    turtle.forward(30)
    turtle.right(120)
    turtle.forward(30)
    turtle.right(120)
    turtle.forward(30)
    turtle.right(120)
    turtle.end_poly()
    tail = turtle.get_poly()

    screen.addshape("fish_body", body)
    screen.addshape("fish_tail", tail)

def create_fish():

    fish_color = random.choice(["coral", "gold", "firebrick",
                                "magenta", "green", "red"])
    body = turtle.Turtle()
    body.shape("fish_body")
    body.color(fish_color)
    body.penup()
    body.speed(0)
    body.setpos(random.randint(-380, 380), random.randint(-280, 280))
    body.setheading(random.randint(0, 360))

    tail = turtle.Turtle()
    tail.shape("fish_tail")
    tail.color(fish_color)
    tail.penup()
    tail.speed(0)
    tail.setpos(body.pos())
    tail.setheading(body.heading())

    return body, tail

create_fish_shape()

peixes = [create_fish() for _ in range(30)]

while True:
    for body, tail in peixes:
        if random.random() < 0.1:
            turn = random.randint(-70, 70)
            body.left(turn)
            tail.left(turn)

        body.forward(10)
        tail.forward(10)

        x, y = body.pos()
        if abs(x) > 700 or abs(y) > 450:
            body.setheading(body.heading() + 90)
            tail.setheading(tail.heading() + 90)


[relogio.py]
import os

import time
digits = {
    '0': ['  ***  ', ' *   * ', '*     *', '*     *', ' *   * ', '  ***  '],
    '1': ['   *   ', '  **   ', '   *   ', '   *   ', '   *   ', '  ***  '],
    '2': [' ***** ', '*     *', '     * ', '   *   ', ' *     ', '*******'],
    '3': [' ***** ', '      *', '  **** ', '      *', '      *', ' ***** '],
    '4': ['*     *', '*     *', ' ******', '      *', '      *', '      *'],
    '5': ['*******', '*      ', '****** ', '      *', '      *', '****** '],
    '6': [' ***** ', '*      ', '* **** ', '*     *', '*     *', ' ***** '],
    '7': ['*******', '     * ', '    *  ', '   *   ', '  *    ', ' *     '],
    '8': [' ***** ', '*     *', ' ***** ', '*     *', '*     *', ' ***** '],
    '9': [' ***** ', '*     *', '* **** ', '      *', '      *', ' ***** '],
    ':': ['       ', '   *   ', '       ', '   *   ', '       ', '       ']
}
while True:
    current_time = time.strftime("%H:%M:%S")
    for row in range(6):
        for char in current_time:
            print(digits[char][row], end=' ')
        print()
    print()
    time.sleep(1)
    os.system('clear')
    print()

[particulas.py]
import pygame, random, math

pygame.init()
tela = pygame.display.set_mode((800, 600))
cores = ["#FF3232", "#32FF32", "#3232FF", "#FFFF32", "#FF32FF"]
particulas = []

rodando = True
while rodando:
    tela.fill("#000000")
    for e in pygame.event.get():
        if e.type == pygame.QUIT:
            rodando = False

    x, y = pygame.mouse.get_pos()
    particulas.append([x, y, pygame.Color(random.choice(cores)), random.uniform(3, 6), random.uniform(0, 2*math.pi)])

    for p in particulas[:]:
        p[0] += math.cos(p[4]) * 3
        p[1] += math.sin(p[4]) * 3
        p[3] *= 0.97
        pygame.draw.circle(tela, p[2], (int(p[0]), int(p[1])), int(p[3]))
        if p[3] < 1:
            particulas.remove(p)

    pygame.display.flip()
pygame.quit()

[jogo_cobrinha.py]
import pygame, random

# Initialize pygame
pygame.init()

# Game settings
TAMANHO = 900
TAMANHO_CELULA = 20
tela = pygame.display.set_mode((TAMANHO, TAMANHO))
pygame.display.set_caption("Jogo da Cobrinha")
clock = pygame.time.Clock()

# Colors
cor_fundo = "#000000"
cor_snake = "#32FF32"
cor_food = ["#FF3232", "#FFAA32", "#32AAFF", "#AA32FF", "#32FFAA"]
cor_texto = (255, 255, 255)  # White

# Initialize snake and food
snake = [[300, 300]]
direcao_atual = (TAMANHO_CELULA, 0)  # Starts moving to the right
foods = [[random.randint(0, (TAMANHO // TAMANHO_CELULA) - 1) * TAMANHO_CELULA,
          random.randint(0, (TAMANHO // TAMANHO_CELULA) - 1) * TAMANHO_CELULA] for _ in range(5)]

# Score
score = 0
fonte = pygame.font.Font(None, 36)  # Default Pygame font
fonte_gameover = pygame.font.Font(None, 100)  # Larger font for "Game Over"

running = True
game_over = False

while running:
    tela.fill(cor_fundo)

    # Event handling
    for e in pygame.event.get():
        if e.type == pygame.QUIT:
            running = False
        elif e.type == pygame.KEYDOWN:
            if not game_over:  # Only change direction if game is still running
                if e.key == pygame.K_UP and direcao_atual != (0, TAMANHO_CELULA):
                    direcao_atual = (0, -TAMANHO_CELULA)
                elif e.key == pygame.K_DOWN and direcao_atual != (0, -TAMANHO_CELULA):
                    direcao_atual = (0, TAMANHO_CELULA)
                elif e.key == pygame.K_LEFT and direcao_atual != (TAMANHO_CELULA, 0):
                    direcao_atual = (-TAMANHO_CELULA, 0)
                elif e.key == pygame.K_RIGHT and direcao_atual != (-TAMANHO_CELULA, 0):
                    direcao_atual = (TAMANHO_CELULA, 0)
            else:
                running = False  # Exit on key press after game over

    if not game_over:
        # Move the snake
        new_head = [snake[0][0] + direcao_atual[0], snake[0][1] + direcao_atual[1]]

        # Check collision with itself or wall
        if new_head in snake or not (0 <= new_head[0] < TAMANHO and 0 <= new_head[1] < TAMANHO):
            game_over = True

        if not game_over:
            snake.insert(0, new_head)

            # Check if food is eaten
            if new_head in foods:
                foods.remove(new_head)
                foods.append([random.randint(0, (TAMANHO // TAMANHO_CELULA) - 1) * TAMANHO_CELULA,
                              random.randint(0, (TAMANHO // TAMANHO_CELULA) - 1) * TAMANHO_CELULA])
                score += 1  # Increase score
            else:
                snake.pop()

    # Draw snake
    for s in snake:
        pygame.draw.rect(tela, cor_snake, (*s, TAMANHO_CELULA, TAMANHO_CELULA))

    # Draw food
    for i, f in enumerate(foods):
        pygame.draw.rect(tela, pygame.Color(cor_food[i % len(cor_food)]), (*f, TAMANHO_CELULA, TAMANHO_CELULA))

    # Draw score
    texto_score = fonte.render(f"Comidas: {score}", True, cor_texto)
    tela.blit(texto_score, (10, 10))  # Position top left

    # Show "Game Over" message
    if game_over:
        overlay = pygame.Surface((TAMANHO, TAMANHO))  # Create a transparent layer
        overlay.set_alpha(150)  # Set transparency (0-255)
        overlay.fill((0, 0, 0))  # Black overlay
        tela.blit(overlay, (0, 0))  # Draw the overlay

        texto_gameover = fonte_gameover.render("GAME OVER", True, (255, 0, 0))  # Red Game Over
        rect = texto_gameover.get_rect(center=(TAMANHO // 2, TAMANHO // 2))  # Centered
        tela.blit(texto_gameover, rect)

        texto_hint = fonte.render("Pressione qualquer tecla para sair", True, cor_texto)
        rect_hint = texto_hint.get_rect(center=(TAMANHO // 2, TAMANHO // 2 + 80))
        tela.blit(texto_hint, rect_hint)

    pygame.display.flip()
    clock.tick(10)  # Control speed

pygame.quit()


[relogio_analogico.py]
import pygame
import math
import datetime

# Inicializa o Pygame
pygame.init()

# Configurações do relógio
LARGURA, ALTURA = 500, 500
CENTRO = (LARGURA // 2, ALTURA // 2)
RAIO = 200  # Raio do relógio
COR_FUNDO = (20, 20, 30)  # Azul escuro elegante
COR_BORDA = (240, 240, 240)  # Borda branca
COR_NUMEROS = (200, 200, 200)  # Cinza claro
COR_PONTEIRO_H = (255, 100, 100)  # Vermelho suave
COR_PONTEIRO_M = (100, 255, 100)  # Verde claro
COR_PONTEIRO_S = (100, 100, 255)  # Azul claro

# Criação da tela
tela = pygame.display.set_mode((LARGURA, ALTURA))
pygame.display.set_caption("Relógio Analógico Minimalista")
clock = pygame.time.Clock()

# Função para desenhar ponteiros
def desenha_ponteiro(tela, angulo, comprimento, cor, largura=4):
    """Desenha um ponteiro do relógio."""
    angulo_rad = math.radians(angulo - 90)  # Ajusta o ângulo para começar do topo
    ponta_x = CENTRO[0] + comprimento * math.cos(angulo_rad)
    ponta_y = CENTRO[1] + comprimento * math.sin(angulo_rad)
    pygame.draw.line(tela, cor, CENTRO, (ponta_x, ponta_y), largura)

# Função principal do jogo
rodando = True
while rodando:
    tela.fill(COR_FUNDO)

    # Eventos do Pygame
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            rodando = False

    # Obtém o horário atual
    agora = datetime.datetime.now()
    segundos = agora.second
    minutos = agora.minute + segundos / 60  # Minutos suaves
    horas = agora.hour % 12 + minutos / 60  # Horas suaves

    # Converte para ângulos (360° para 60 unidades)
    ang_h = horas * 30  # 360°/12h = 30° por hora
    ang_m = minutos * 6  # 360°/60min = 6° por minuto
    ang_s = segundos * 6  # 360°/60s = 6° por segundo

    # Desenha o círculo do relógio
    pygame.draw.circle(tela, COR_BORDA, CENTRO, RAIO, 8)  # Contorno do relógio

    # Desenha os números do relógio
    for i in range(1, 13):
        ang_num = math.radians(i * 30 - 90)
        num_x = CENTRO[0] + (RAIO - 30) * math.cos(ang_num)
        num_y = CENTRO[1] + (RAIO - 30) * math.sin(ang_num)
        fonte = pygame.font.Font(None, 40)
        texto = fonte.render(str(i), True, COR_NUMEROS)
        tela.blit(texto, (num_x - 10, num_y - 15))

    # Desenha os ponteiros
    desenha_ponteiro(tela, ang_h, RAIO * 0.5, COR_PONTEIRO_H, 8)  # Horas
    desenha_ponteiro(tela, ang_m, RAIO * 0.7, COR_PONTEIRO_M, 6)  # Minutos
    desenha_ponteiro(tela, ang_s, RAIO * 0.9, COR_PONTEIRO_S, 2)  # Segundos

    # Desenha o centro do relógio
    pygame.draw.circle(tela, (255, 255, 255), CENTRO, 8)  # Pequeno círculo no centro

    pygame.display.flip()
    clock.tick(30)  # Suaviza a animação

pygame.quit()
