[gravidade_planetas.py]
import pygame
import random
import math

# Inicializa o Pygame
pygame.init()

# Configurações da Tela
LARGURA, ALTURA = 900, 900
tela = pygame.display.set_mode((LARGURA, ALTURA))
pygame.display.set_caption("Simulador de Gravidade")

# Cores
BRANCO = (255, 255, 255)
PRETO = (20, 20, 30)
AZUL = (50, 150, 255)
VERDE = (50, 130, 50)
VERMELHO = (255, 50, 50)
CINZA = (100, 100, 100)
AMARELO = (255, 215, 0)

GRAVIDADE_MIN = 0.05  # Gravidade mínima
GRAVIDADE_MAX = 30.0 / 10  # Gravidade máxima

cores = [AZUL, VERDE, VERMELHO, AMARELO]

# Relógio para controle de FPS
clock = pygame.time.Clock()

# Gravidade inicial (Terra)
selected_planet = "Terra"
gravidade = 9.8 / 10  # Ajustado para a escala do jogo

# Planetas e suas gravidades (m/s² convertidos para escala do jogo)
planetas = {
    "Lua": 1.6 / 10,
    "Mercúrio": 3.7 / 10,
    "Vênus": 8.9 / 10,
    "Terra": 9.8 / 10,
    "Marte": 3.7 / 10,
    "Júpiter": 24.8 / 10,
    "Saturno": 10.4 / 10,
    "Urano": 8.7 / 10,
    "Netuno": 11.2 / 10
}

# Classe para representar uma bola
class Bola:
    def __init__(self, x, y, raio, cor):
        self.x = x
        self.y = y
        self.raio = raio
        self.cor = cor
        self.vel_x = random.uniform(-3, 3)  # Velocidade horizontal aleatória
        self.vel_y = 0  # Velocidade vertical
        self.restituicao = 0.8  # Quanto da energia é preservada ao quicar

    def atualizar(self):
        # Aplica a gravidade
        self.vel_y += gravidade
        self.x += self.vel_x
        self.y += self.vel_y

        # Se atingir o chão, quica
        if self.y + self.raio > ALTURA:
            self.y = ALTURA - self.raio
            self.vel_y *= -self.restituicao  # Invertemos a direção e aplicamos amortecimento

        # Se atingir as laterais, inverte a velocidade X
        if self.x - self.raio < 0 or self.x + self.raio > LARGURA:
            self.vel_x *= -self.restituicao

    def desenhar(self, tela):
        pygame.draw.circle(tela, self.cor, (int(self.x), int(self.y)), self.raio)

# Verifica e resolve colisões entre bolas
def resolver_colisoes(bolas):
    for i in range(len(bolas)):
        for j in range(i + 1, len(bolas)):
            bola1, bola2 = bolas[i], bolas[j]
            dx = bola2.x - bola1.x
            dy = bola2.y - bola1.y
            distancia = math.sqrt(dx**2 + dy**2)

            if distancia < bola1.raio + bola2.raio:  # Se houver colisão
                # Calcula o ângulo da colisão
                angulo = math.atan2(dy, dx)

                # Separa as bolas para evitar sobreposição
                overlap = (bola1.raio + bola2.raio) - distancia
                bola1.x -= math.cos(angulo) * overlap / 2
                bola1.y -= math.sin(angulo) * overlap / 2
                bola2.x += math.cos(angulo) * overlap / 2
                bola2.y += math.sin(angulo) * overlap / 2

                # Velocidade após a colisão (baseado em conservação de momento)
                vel1_proj = bola1.vel_x * math.cos(angulo) + bola1.vel_y * math.sin(angulo)
                vel2_proj = bola2.vel_x * math.cos(angulo) + bola2.vel_y * math.sin(angulo)

                bola1.vel_x += (vel2_proj - vel1_proj) * math.cos(angulo)
                bola1.vel_y += (vel2_proj - vel1_proj) * math.sin(angulo)
                bola2.vel_x += (vel1_proj - vel2_proj) * math.cos(angulo)
                bola2.vel_y += (vel1_proj - vel2_proj) * math.sin(angulo)

# Criando múltiplas bolas aleatórias
def criar_bolas():
    return [Bola(random.randint(50, LARGURA - 50), random.randint(50, 300), random.randint(10, 45), random.choice(cores)) for _ in range(10)]

bolas = criar_bolas()

# Fonte para exibir texto
fonte = pygame.font.Font(None, 30)
fonte_titulo = pygame.font.Font(None, 40)

# Função para desenhar botões
def desenhar_botao(tela, texto, pos, tamanho, cor_fundo, cor_texto=BRANCO):
    """Desenha um botão na tela com fundo, borda e texto"""
    rect = pygame.Rect(pos[0], pos[1], tamanho[0], tamanho[1])
    pygame.draw.rect(tela, cor_fundo, rect, border_radius=10)

    # Renderiza o texto centralizado
    texto_render = fonte.render(texto, True, cor_texto)
    texto_rect = texto_render.get_rect(center=rect.center)
    tela.blit(texto_render, texto_rect)

    return rect

# Loop do jogo
rodando = True
while rodando:
    tela.fill(PRETO)

    # Captura eventos
    for evento in pygame.event.get():
        if evento.type == pygame.QUIT:
            rodando = False
        elif evento.type == pygame.MOUSEBUTTONDOWN:
            x, y = evento.pos

            # Botão "Jogar de Novo"
            if botao_reset.collidepoint(x, y):
                bolas = criar_bolas()  # Reseta as bolas

            # Botões "Planetas"
            for i, (planeta, g) in enumerate(planetas.items()):
                if botoes_planetas[i].collidepoint(x, y):
                    gravidade = g  # Set gravity
                    selected_planet = planeta  # Update selected planet
                    bolas = criar_bolas()  # Reset balls

    # Atualiza e resolve colisões entre bolas
    for bola in bolas:
        bola.atualizar()
    resolver_colisoes(bolas)

    # Desenha as bolas
    for bola in bolas:
        bola.desenhar(tela)

    # Botão de reinício
    botao_reset = desenhar_botao(tela, "Jogar de Novo", (LARGURA - 160, 20), (160, 40), VERMELHO)

    # Título "Planetas"
    texto_planetas = fonte_titulo.render("Escolha um planeta:", True, BRANCO)
    tela.blit(texto_planetas, (50, 70))

    # Draw planet buttons with correct highlighting
    botoes_planetas = []
    for i, (planeta, g) in enumerate(planetas.items()):
        cor_botao = VERDE if planeta == selected_planet else AZUL  # Highlight selected planet
        botao = desenhar_botao(tela, planeta, (50 + (i % 4) * 190, 110 + (i // 4) * 50), (180, 40), cor_botao)
        botoes_planetas.append(botao)

    pygame.display.flip()
    clock.tick(60)

pygame.quit()

[tetris.py]
import pygame, random

pygame.init()
LARGURA, ALTURA, TAMANHO = 300, 600, 30
COLUNAS, LINHAS = LARGURA // TAMANHO, ALTURA // TAMANHO
tela = pygame.display.set_mode((LARGURA, ALTURA))
relogio = pygame.time.Clock()
velocidade = 3

FUNDO, CORES = "#000000", ["#FF3232", "#32FF32", "#3232FF", "#FFFF32", "#FF32FF"]

FORMAS = [
    [[1, 1, 1], [0, 1, 0]],  # T
    [[1, 1, 1, 1]],           # I
    [[1, 1], [1, 1]],         # O
    [[1, 1, 0], [0, 1, 1]],   # Z
    [[0, 1, 1], [1, 1, 0]],   # S
    [[1, 1, 0], [1, 1]],      # L
    [[0, 1, 1], [1, 1]]       # J
]

grade = [[0] * COLUNAS for _ in range(LINHAS)]

class Bloco:
    def __init__(self):
        self.forma = random.choice(FORMAS)
        self.cor = pygame.Color(random.choice(CORES))
        self.x, self.y = COLUNAS // 2 - len(self.forma[0]) // 2, 0

    def girar(self):
        nova_forma = list(zip(*self.forma[::-1]))
        if not self.colisao(0, 0, nova_forma):
            self.forma = nova_forma

    def mover(self, dx, dy):
        if not self.colisao(dx, dy):
            self.x += dx
            self.y += dy
        elif dy:
            for i, linha in enumerate(self.forma):
                for j, valor in enumerate(linha):
                    if valor:
                        grade[self.y + i][self.x + j] = self.cor
            return False
        return True

    def colisao(self, dx, dy, forma=None):
        forma = forma or self.forma
        for i, linha in enumerate(forma):
            for j, valor in enumerate(linha):
                if valor:
                    nx, ny = self.x + j + dx, self.y + i + dy
                    if nx < 0 or nx >= COLUNAS or ny >= LINHAS or (ny >= 0 and grade[ny][nx]):
                        return True
        return False

def limpar_linhas():
    global grade
    grade = [linha for linha in grade if any(celula == 0 for celula in linha)]
    while len(grade) < LINHAS:
        grade.insert(0, [0] * COLUNAS)

bloco = Bloco()
rodando, tempo_queda = True, 0

while rodando:
    tela.fill(FUNDO)
    for evento in pygame.event.get():
        if evento.type == pygame.QUIT:
            rodando = False
        elif evento.type == pygame.KEYDOWN:
            if evento.key == pygame.K_LEFT:
                bloco.mover(-1, 0)
            if evento.key == pygame.K_RIGHT:
                bloco.mover(1, 0)
            if evento.key == pygame.K_DOWN:
                bloco.mover(0, 1)
            if evento.key == pygame.K_UP:
                bloco.girar()

    tempo_queda += 1
    if tempo_queda > 60 // velocidade:
        if not bloco.mover(0, 1):
            limpar_linhas()
            bloco = Bloco()
        tempo_queda = 0

    for y, linha in enumerate(grade):
        for x, cor in enumerate(linha):
            if cor:
                pygame.draw.rect(tela, cor, (x * TAMANHO, y * TAMANHO, TAMANHO, TAMANHO), border_radius=5)

    for i, linha in enumerate(bloco.forma):
        for j, valor in enumerate(linha):
            if valor:
                pygame.draw.rect(tela, bloco.cor, ((bloco.x + j) * TAMANHO, (bloco.y + i) * TAMANHO, TAMANHO, TAMANHO), border_radius=5)

    pygame.display.flip()
    relogio.tick(60)

pygame.quit()

[planetas.py]
import turtle
import math
import random

screen = turtle.Screen()
screen.bgcolor("black")
screen.tracer(0)

def criar_estrelas(num_estrelas):
    estrelas = []
    for _ in range(num_estrelas):
        estrela = turtle.Turtle()
        estrela.shape("circle")
        estrela.color("white")
        estrela.shapesize(random.uniform(0.05, 0.15))
        estrela.penup()
        estrela.goto(random.randint(-800, 800), random.randint(-400, 400))
        estrelas.append(estrela)
    return estrelas

criar_estrelas(300)

sun = turtle.Turtle()
sun.shape("circle")
sun.color("#FFD700")
sun.shapesize(2)

planets = [
    ("Mercúrio", "#8B8B83", 0.4, 50, 2),
    ("Vênus", "#E6B800", 0.6, 80, 1.5),
    ("Terra", "#0077BE", 0.8, 120, 1.2),
    ("Marte", "#FF4500", 0.7, 160, 1),
    ("Júpiter", "#D2B48C", 1.5, 220, 0.8),
    ("Saturno", "#F4A460", 1.3, 280, 0.6),
    ("Urano", "#40E0D0", 1.1, 340, 0.5),
    ("Netuno", "#0000FF", 1.0, 400, 0.4)
]

planet_turtles = []
for planet in planets:
    name, color, size, distance, speed = planet
    p = turtle.Turtle()
    p.shape("circle")
    p.color(color)
    p.shapesize(size)
    p.penup()
    p.goto(distance, 0)
    p.pendown()
    planet_turtles.append((p, distance, speed, 0))

def move_planets():
    for planet in planet_turtles:
        p, distance, speed, angle = planet
        x = distance * math.cos(math.radians(angle))
        y = distance * math.sin(math.radians(angle))
        p.goto(x, y)
        planet_turtles[planet_turtles.index(planet)] = (p, distance, speed, angle + speed)

while True:
    screen.update()
    move_planets()
    turtle.time.sleep(0.03)

[aquario.py]
import turtle
import random

screen = turtle.Screen()
screen.bgcolor("lightblue")
screen.setup(width=1400, height=900)

def create_fish_shape():
    turtle.begin_poly()
    turtle.forward(30)
    turtle.left(120)
    turtle.forward(30)
    turtle.left(120)
    turtle.forward(30)
    turtle.left(120)
    turtle.end_poly()
    body = turtle.get_poly()

    turtle.begin_poly()
    turtle.forward(30)
    turtle.right(120)
    turtle.forward(30)
    turtle.right(120)
    turtle.forward(30)
    turtle.right(120)
    turtle.end_poly()
    tail = turtle.get_poly()

    screen.addshape("fish_body", body)
    screen.addshape("fish_tail", tail)

def create_fish():

    fish_color = random.choice(["coral", "gold", "firebrick",
                                "magenta", "green", "red"])
    body = turtle.Turtle()
    body.shape("fish_body")
    body.color(fish_color)
    body.penup()
    body.speed(0)
    body.setpos(random.randint(-380, 380), random.randint(-280, 280))
    body.setheading(random.randint(0, 360))

    tail = turtle.Turtle()
    tail.shape("fish_tail")
    tail.color(fish_color)
    tail.penup()
    tail.speed(0)
    tail.setpos(body.pos())
    tail.setheading(body.heading())

    return body, tail

create_fish_shape()

peixes = [create_fish() for _ in range(30)]

while True:
    for body, tail in peixes:
        if random.random() < 0.1:
            turn = random.randint(-70, 70)
            body.left(turn)
            tail.left(turn)

        body.forward(10)
        tail.forward(10)

        x, y = body.pos()
        if abs(x) > 700 or abs(y) > 450:
            body.setheading(body.heading() + 90)
            tail.setheading(tail.heading() + 90)


[relogio.py]
import os

import time
digits = {
    '0': ['  ***  ', ' *   * ', '*     *', '*     *', ' *   * ', '  ***  '],
    '1': ['   *   ', '  **   ', '   *   ', '   *   ', '   *   ', '  ***  '],
    '2': [' ***** ', '*     *', '     * ', '   *   ', ' *     ', '*******'],
    '3': [' ***** ', '      *', '  **** ', '      *', '      *', ' ***** '],
    '4': ['*     *', '*     *', ' ******', '      *', '      *', '      *'],
    '5': ['*******', '*      ', '****** ', '      *', '      *', '****** '],
    '6': [' ***** ', '*      ', '* **** ', '*     *', '*     *', ' ***** '],
    '7': ['*******', '     * ', '    *  ', '   *   ', '  *    ', ' *     '],
    '8': [' ***** ', '*     *', ' ***** ', '*     *', '*     *', ' ***** '],
    '9': [' ***** ', '*     *', '* **** ', '      *', '      *', ' ***** '],
    ':': ['       ', '   *   ', '       ', '   *   ', '       ', '       ']
}
while True:
    current_time = time.strftime("%H:%M:%S")
    for row in range(6):
        for char in current_time:
            print(digits[char][row], end=' ')
        print()
    print()
    time.sleep(1)
    os.system('clear')
    print()

[particulas.py]
import pygame, random, math

pygame.init()
tela = pygame.display.set_mode((800, 600))
cores = ["#FF3232", "#32FF32", "#3232FF", "#FFFF32", "#FF32FF"]
particulas = []

rodando = True
while rodando:
    tela.fill("#000000")
    for e in pygame.event.get():
        if e.type == pygame.QUIT:
            rodando = False

    x, y = pygame.mouse.get_pos()
    particulas.append([x, y, pygame.Color(random.choice(cores)), random.uniform(3, 6), random.uniform(0, 2*math.pi)])

    for p in particulas[:]:
        p[0] += math.cos(p[4]) * 3
        p[1] += math.sin(p[4]) * 3
        p[3] *= 0.97
        pygame.draw.circle(tela, p[2], (int(p[0]), int(p[1])), int(p[3]))
        if p[3] < 1:
            particulas.remove(p)

    pygame.display.flip()
pygame.quit()

[relogio_analogico.py]
import pygame
import math
import datetime

# Inicializa o Pygame
pygame.init()

# Configurações do relógio
LARGURA, ALTURA = 500, 500
CENTRO = (LARGURA // 2, ALTURA // 2)
RAIO = 200  # Raio do relógio
COR_FUNDO = (20, 20, 30)  # Azul escuro elegante
COR_BORDA = (240, 240, 240)  # Borda branca
COR_NUMEROS = (200, 200, 200)  # Cinza claro
COR_PONTEIRO_H = (255, 100, 100)  # Vermelho suave
COR_PONTEIRO_M = (100, 255, 100)  # Verde claro
COR_PONTEIRO_S = (100, 100, 255)  # Azul claro

# Criação da tela
tela = pygame.display.set_mode((LARGURA, ALTURA))
pygame.display.set_caption("Relógio Analógico Minimalista")
clock = pygame.time.Clock()

# Função para desenhar ponteiros
def desenha_ponteiro(tela, angulo, comprimento, cor, largura=4):
    """Desenha um ponteiro do relógio."""
    angulo_rad = math.radians(angulo - 90)  # Ajusta o ângulo para começar do topo
    ponta_x = CENTRO[0] + comprimento * math.cos(angulo_rad)
    ponta_y = CENTRO[1] + comprimento * math.sin(angulo_rad)
    pygame.draw.line(tela, cor, CENTRO, (ponta_x, ponta_y), largura)

# Função principal do jogo
rodando = True
while rodando:
    tela.fill(COR_FUNDO)

    # Eventos do Pygame
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            rodando = False

    # Obtém o horário atual
    agora = datetime.datetime.now()
    segundos = agora.second
    minutos = agora.minute + segundos / 60  # Minutos suaves
    horas = agora.hour % 12 + minutos / 60  # Horas suaves

    # Converte para ângulos (360° para 60 unidades)
    ang_h = horas * 30  # 360°/12h = 30° por hora
    ang_m = minutos * 6  # 360°/60min = 6° por minuto
    ang_s = segundos * 6  # 360°/60s = 6° por segundo

    # Desenha o círculo do relógio
    pygame.draw.circle(tela, COR_BORDA, CENTRO, RAIO, 8)  # Contorno do relógio

    # Desenha os números do relógio
    for i in range(1, 13):
        ang_num = math.radians(i * 30 - 90)
        num_x = CENTRO[0] + (RAIO - 30) * math.cos(ang_num)
        num_y = CENTRO[1] + (RAIO - 30) * math.sin(ang_num)
        fonte = pygame.font.Font(None, 40)
        texto = fonte.render(str(i), True, COR_NUMEROS)
        tela.blit(texto, (num_x - 10, num_y - 15))

    # Desenha os ponteiros
    desenha_ponteiro(tela, ang_h, RAIO * 0.5, COR_PONTEIRO_H, 8)  # Horas
    desenha_ponteiro(tela, ang_m, RAIO * 0.7, COR_PONTEIRO_M, 6)  # Minutos
    desenha_ponteiro(tela, ang_s, RAIO * 0.9, COR_PONTEIRO_S, 2)  # Segundos

    # Desenha o centro do relógio
    pygame.draw.circle(tela, (255, 255, 255), CENTRO, 8)  # Pequeno círculo no centro

    pygame.display.flip()
    clock.tick(30)  # Suaviza a animação

pygame.quit()