[maldicao-do-emoji.html]
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0">
    <title>Viagem amaldiçoada</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', monospace;
            color: #8a0303;
        }

        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            touch-action: none; /* Prevent touch scrolling */
        }


        canvas {
            display: block;
            background: linear-gradient(to bottom, #0a0a0a, #1a0707);
            height: 100vh;
        }

        #game-container {
            position: absolute;
            width: 100vw;
            height: 100vh; /* This will be corrected by JS */
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        h1 {
            color: #8a0303;
            font-size: 1.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000; }
            50% { text-shadow: 0 0 15px #ff0000, 0 0 30px #ff0000; }
            100% { text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000; }
        }

        button {
            padding: 15px 30px;
            font-size: 1em;
            border: 2px solid #8a0303;
            background-color: #1a0707;
            color: #8a0303;
            cursor: pointer;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }

        button:hover {
            background-color: #8a0303;
            color: #000;
            transform: scale(1.05);
        }

        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1em;
            z-index: 5;
        }

        #game-over-score {
            font-size: 2em;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="score">Score: 0</div>
        <div id="inventory" style="
            position: absolute;
            top: 35px;
            left: 20px;
            font-size: .8em;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;">
        </div>
        <div id="lives" style="
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: .8em;
            color: white;
            z-index: 5;">
        </div>

        <div id="start-screen">
            <h1>VIAGEM AMALDIÇOADA</h1>
            <button id="start-button">PREPARE-SE PARA PERDER</button>
        </div>

        <div id="game-over-screen" style="display: none;">
            <h1>GAME OVER</h1>
            <div id="game-over-score"></div>
            <button id="restart-button">VAI TENTAR NEH</button>
        </div>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const gameOverScoreDisplay = document.getElementById('game-over-score');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');

        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game state
        const isMobile = /iPhone|iPad|Android|Mobile/i.test(navigator.userAgent);

        let gameStarted = false;
        let gameOver = false;
        let score = 0;
        let shipY = canvas.height / 2;
        let shipVelocity = 0;
        let backgroundSpeed = 5; // Independent background scrolling speed
        let obstacleSpeed = 1;    // Independent obstacle movement speed
        let obstacles = [];
        let groundLevel = canvas.height * 0.9;
        let ceilingLevel = canvas.height * 0.1;
        let lastObstacleTime = 0;
        let gameTime = 0;
        let isExploding = false;
        let shipFlicker = false;
        let flickerCount = 0;
        let shipXVelocity = 0; // Horizontal velocity
        const shipAcceleration = 0.3; // How fast the ship moves
        const shipFriction = 0.9; // Friction effect to smooth movement
        const fastSpeedThreshold = 3; // Adjust as needed

        let lives = 5; // Ship starts with 3 lives
        let isHit = false; // To track ship blinking effect
        let hitTimer = 0;  // Timer for blinking animation

        let laserActive = false;
        let laserDuration = 2500; // Laser lasts 500 frames (~8 seconds)

        const normalGravity = 0.3;
        const mobileGravity = 0.15; // 🔽 Lower gravity for mobile
        let gravity = isMobile ? mobileGravity : normalGravity;

        // Ship properties
        const shipWidth = 80;
        const shipHeight = 40;
        let shipX = canvas.width * 0.2;

        // Create a ship glow effect
        const shipGlow = {
            radius: 20,
            opacity: 0.5,
            color: '#8a0303'
        };

        // Images for backgrounds and effects
        const bgLayers = [];
        const numLayers = 3;
        let bgReady = false;

        // Define obstacle patterns with emojis
        // Define emoji obstacle shapes
        const emojiShapes = [
        { // Triangle of Thumbs Up 🤡
            pattern: [
                ["", "", "🤡", "", ""],
                ["", "🤡", "🤡", "🤡", ""],
                ["🤡", "🤡", "🤡", "🤡", "🤡"]
            ],
            type: "triangle"
        },
        { // Square of Poop 👾
            pattern: [
                ["👾", "👾", "👾"],
                ["👾", "👾", "👾"],
                ["👾", "👾", "👾"],
                ["👾", "👾", "👾"],
                ["👾", "👾", "👾"],
            ],
            type: "square"
        },
        { // Diamond (Losango) of Hearts 👽
            pattern: [
                ["", "", "👽", "", ""],
                ["", "👽", "👽", "👽", ""],
                ["👽", "👽", "👽", "👽", "👽"],
                ["", "👽", "👽", "👽", ""],
                ["", "", "👽", "", ""]
            ],
            type: "diamond"
        },
        { // Eyes
            pattern: [
                ["👀", "", "", "", "👀"],
                ["👀", "👀", "", "👀", "👀"],
                ["👀", "👀", "👀", "👀", "👀"],
                ["👀", "👀", "", "👀", "👀"],
                ["👀", "", "", "", "👀"]
            ],
            type: "eyes"
        },
        { // Bar
            pattern: [
                ["", "", "", "", ""],
                ["", "", "", "", ""],
                ["🟥", "🟥", "🟥", "🟥", "🟥"],
                ["", "", "", "", ""],
                ["", "", "", "", ""]
            ],
            type: "bar"
        },
        {
            pattern: [
                ["🥚", "🥚", "🥚"],
                ["🥚", "🥚", "🥚"],
                ["🥚", "🥚", "🥚"],
                ["🥚", "🥚", "🥚"],
                ["🥚", "🥚", "🥚"],
                ["🥚", "🥚", "🥚"],
            ],
            type: "eggs"
        },
        {
            pattern: [
                ["",   "", "🐍"],
                ["",   "🐍", ""],
                ["🐍", "🐍", ""],
                ["🐍", "🐍", ""],
                ["",   "🐍", ""],
                ["",   "", "🐍"],
            ],
            type: "eggs"
        },
        {
            pattern: [
                ["🦴","🦴", "🦴", "🦴"],
                ["🦴","🦴", "🦴", "🦴"],
                ["","", "🦴", "🦴"],
                ["","", "🦴", "🦴"],
                ["","", "🦴", "🦴"],
                ["🦴","🦴", "🦴", "🦴"],
                ["🦴","🦴", "🦴", "🦴"],

            ],
            type: "eggs"
        }
        ];

        // Define collectible items
        const collectibles = [
            { emoji: "💀", name: "skull", points: 5 },
            { emoji: "💩", name: "ring", points: 10 },
            { emoji: "🔫", name: "coconut", points: 15 },
            { emoji: "🐦‍🔥", name: "time", points: 10 },
            { emoji: "☢️", name: "radiation", points: 10 }
        ];

        let inventory = { "💀": 0, "💩": 0, "🔫": 0, "🐦‍🔥": 0, "☢️": 0 };

        const sounds = {
            music1: new Audio("background-layer-0.mp3"),
            music2: new Audio("background-layer-1.mp3"),
            music3: new Audio("background-layer-2.mp3"),
            risada: new Audio("risada-do-mal.mp3"),
            ghost: new Audio("ghost.mp3"),
            effects: new Audio("background-layer-.mp3"),
            shoot: new Audio("shoot.mp3"),
            explosion: new Audio("explosion.mp3"),
            explosionAll: new Audio("explosion-all.mp3"),
            collect: new Audio("collect.mp3"),
            shield: new Audio("shield.mp3"),
            gameover: new Audio("gameover.mp3")
        };

        // 🎵 Configure Looping & Volume
        sounds.music1.loop = true;
        sounds.music1.volume = 0.3; // Adjust volume as needed
        sounds.music2.loop = true;
        sounds.music2.volume = 0.2; // Adjust volume as needed
        sounds.music3.loop = true;
        sounds.music3.volume = 0.4; // Adjust volume as needed

        // 🚀 Play Background Music when the game starts
        function startMusic() {
            sounds.music1.play();
            sounds.music2.play();
            sounds.music3.play();
        }

        // 🔫 Play Sound Effects
        function playSound(sound) {
            if (sounds[sound]) {
                sounds[sound].currentTime = 0; // Reset to allow rapid triggers
                sounds[sound].play();
            }
        }

        let invincible = false;
        let invincibleTimer = 0;

        let bullets = [];
        let canShoot = false; // Starts as false, enabled when a coconut is collected
        const bulletSpeed = 10;
        const bulletSize = 8;
        let shootTimer = 0;

        let normalAcceleration = 0.3; // Default acceleration
        let slowAcceleration = 0.1;   // Reduced acceleration when diamond is active
        let currentAcceleration = normalAcceleration; // Track current acceleration

        let slowMovementTimer = 0; // Timer for slow effect
        // List of collectible objects in the game
        let activeCollectibles = [];

        // Shoot function
        function shootBullet() {
            if (canShoot) {
                bullets.push({
                    x: shipX + shipWidth,
                    y: shipY + shipHeight / 2,
                    size: bulletSize,
                });
                playSound("shoot");
            }
        }

        // Update bullets
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].x += bulletSpeed;

                // Remove bullet if it goes off-screen
                if (bullets[i].x > canvas.width) {
                    bullets.splice(i, 1);
                    continue;
                }

                // Check collision with obstacles
                for (let j = obstacles.length - 1; j >= 0; j--) {
                    let obstacle = obstacles[j];

                    if (obstacle.type === "emoji-block") {
                        for (let row = 0; row < obstacle.rows; row++) {
                            for (let col = 0; col < obstacle.pattern[row].length; col++) {
                                let emoji = obstacle.pattern[row][col];
                                if (emoji === "") continue;

                                let emojiX = obstacle.x + col * obstacle.blockSize;
                                let emojiY = obstacle.y + row * obstacle.blockSize;

                                // Bullet hitbox
                                if (
                                    bullets[i].x + bullets[i].size > emojiX &&
                                    bullets[i].x < emojiX + obstacle.blockSize &&
                                    bullets[i].y > emojiY &&
                                    bullets[i].y < emojiY + obstacle.blockSize
                                ) {
                                    console.log(`🔥 Bullet destroyed ${emoji}`);
                                    obstacle.pattern[row][col] = ""; // Remove emoji
                                    bullets.splice(i, 1); // Remove bullet
                                    score += 1
                                    return;
                                }
                            }
                        }
                    }
                }
            }
        }

        // Draw bullets
        function drawBullets() {
            ctx.fillStyle = "yellow";
            for (let bullet of bullets) {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function activateLaserMode() {
            console.log("⚡ LASER MODE ACTIVATED!");
            laserActive = true;
            playSound("shoot");

            setTimeout(() => {
                laserActive = false;
                console.log("⚡ Laser Mode Over!");
            }, laserDuration);
        }

        function drawLaser() {
            if (!laserActive) return;

            ctx.strokeStyle = "cyan"; // Laser color
            ctx.lineWidth = 4; // Thick laser beam
            ctx.globalAlpha = 0.7;

            ctx.beginPath();
            ctx.moveTo(shipX + shipWidth, shipY + shipHeight / 2);
            ctx.lineTo(canvas.width, shipY + shipHeight / 2); // Laser extends across the screen
            ctx.stroke();
            ctx.globalAlpha = 1;

            destroyObstaclesWithLaser();
        }

        function destroyObstaclesWithLaser() {
            if (!laserActive) return;

            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obstacle = obstacles[i];

                // Check if obstacle is aligned with the laser
                if (
                    obstacle.y < shipY + shipHeight / 2 + 20 &&
                    obstacle.y + obstacle.height > shipY + shipHeight / 2 - 20
                ) {
                    console.log("💥 Laser destroyed an obstacle!");
                    createExplosion(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
                    obstacles.splice(i, 1);
                }
            }
        }

        // Create background layers
        function createBackgroundLayers() {
            for (let i = 0; i < numLayers; i++) {
                const layer = {
                    x: 0,
                    speed: 0.3 + i * 0.3, // Different speeds for parallax effect
                    clouds: []
                };

                const numObjects = 5 + Math.floor(Math.random() * 20); // Random number of objects

                for (let j = 0; j < numObjects; j++) {
                    const type = Math.random() > 0.7 ? "planet" : "star"; // 30% chance for a planet
                    const depth = 0.1 + Math.random() * 0.3; // Depth factor between 0.3 and 1.0

                    layer.clouds.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        width: type === "planet" ? 60 + Math.random() * 140 : 4 + Math.random() * 6,
                        height: type === "planet" ? 60 + Math.random() * 140 : 4 + Math.random() * 6,
                        opacity: type === "star" ? (0.5 + Math.random() * 1) : .1,
                        color: type === "planet" ? ["#ffcc00", "#ff5500", "#0099ff", "#00ff66", "#ff66ff"][Math.floor(Math.random() * 5)] : "white",
                        type: type,
                        depth: depth // Assign depth for parallax effect
                    });
                }

                bgLayers.push(layer);
            }
            bgReady = true;
        }

        const explosionParticles = [];

        function createExplosion(x, y) {
            for (let i = 0; i < 50; i++) { // More particles for a stronger effect
                explosionParticles.push({
                    x: x,
                    y: y,
                    size: 5 + Math.random() * 12, // Bigger explosion
                    speedX: (Math.random() - 0.5) * 10,
                    speedY: (Math.random() - 0.5) * 10,
                    life: 50 + Math.random() * 30, // Lasts longer
                    color: `rgba(255, ${50 + Math.random() * 150}, 0, 1)`
                });
            }
        }

        function updateExplosion() {
            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                let p = explosionParticles[i];
                p.x += p.speedX;
                p.y += p.speedY;
                p.life--;
                if (p.life <= 0) explosionParticles.splice(i, 1); // Remove finished particles
            }
        }

        function drawExplosion() {
            for (const p of explosionParticles) {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }


        // Particles system for effects
        const particles = [];

        function createShipTrail() {
            particles.push({
                x: shipX,
                y: shipY + shipHeight / 2,
                size: 2 + Math.random() * 6,
                speedX: -1 - Math.random() * 2,
                speedY: (Math.random() - 0.5) * 2,
                life: 30 + Math.random() * 20,
                color: `rgba(${138 + Math.random() * 50}, ${3 + Math.random() * 20}, ${3 + Math.random() * 20}, ${0.3 + Math.random() * 0.5})`
            });
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.speedX;
                p.y += p.speedY;
                p.life--;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life / 50;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });
        }

        // Draw background layers
        function drawBackground() {
            if (!bgReady) return;

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (const layer of bgLayers) {
                layer.x -= backgroundSpeed * layer.speed; // Use `backgroundSpeed`
                if (layer.x < -canvas.width) {
                    layer.x = 0;
                }

                for (const obj of layer.clouds) {
                    obj.x -= backgroundSpeed * obj.depth; // Background scrolls separately
                    if (obj.x < -obj.width) {
                        obj.x = canvas.width + Math.random() * 100;
                        obj.y = Math.random() * canvas.height;
                    }

                    let adjustedOpacity = obj.opacity * obj.depth;

                    if (obj.type === "star") {
                        ctx.fillStyle = `rgba(255, 255, 255, ${adjustedOpacity})`;
                        ctx.beginPath();
                        ctx.arc(obj.x, obj.y, obj.width / 6, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (obj.type === "planet") {
                        ctx.fillStyle = obj.color;
                        ctx.globalAlpha = adjustedOpacity;
                        ctx.beginPath();
                        ctx.arc(obj.x, obj.y, obj.width / 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }
                }
            }
        }

        function drawCollectibles() {
            ctx.font = "20px Arial";  // Increased font size for visibility
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            for (const item of activeCollectibles) {
                if (!item.collected) {
                    ctx.fillStyle = "white"; // Ensure high contrast for visibility
                    ctx.fillText(item.emoji, item.x, item.y);
                }
            }
        }

        // Draw the ship with a glow effect
        function drawShip() {
            if (isExploding) return;
            if (isHit && shipFlicker) {
                flickerCount++;
                if (flickerCount % 6 < 3) {
                    isHit = false;
                    return;
                }
            }

            // 🚀 **Define Armor Colors**
            let shipBaseColor = canShoot ? "#444" : "#8B0000"; // Gunmetal Gray when armed
            let armorBorderColor = canShoot ? "#AAA" : "#FF6347"; // Brighter outline
            let energyColor = canShoot ? "cyan" : "red"; // Blue glow when armed

            // 🌟 **Ship Glow Effect**
            ctx.beginPath();
            ctx.arc(shipX + shipWidth / 2, shipY + shipHeight / 2, shipGlow.radius, 0, Math.PI * 2);
            const glowGradient = ctx.createRadialGradient(
                shipX + shipWidth / 2, shipY + shipHeight / 2, 0,
                shipX + shipWidth / 2, shipY + shipHeight / 2, shipGlow.radius
            );
            glowGradient.addColorStop(0, `rgba(${canShoot ? '0,255,255' : '255,50,50'}, 0.8)`);
            glowGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
            ctx.fillStyle = glowGradient;
            ctx.fill();

            // 🚀 **Main Ship Body**
            ctx.fillStyle = shipBaseColor;
            ctx.strokeStyle = armorBorderColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(shipX, shipY + shipHeight / 2);
            ctx.lineTo(shipX + shipWidth * 0.3, shipY + shipHeight * 0.2);
            ctx.lineTo(shipX + shipWidth * 0.8, shipY + shipHeight * 0.2);
            ctx.lineTo(shipX + shipWidth, shipY + shipHeight / 2);
            ctx.lineTo(shipX + shipWidth * 0.8, shipY + shipHeight * 0.8);
            ctx.lineTo(shipX + shipWidth * 0.3, shipY + shipHeight * 0.8);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // 🛡️ **Armor Plating (Metallic Highlights)**
            ctx.strokeStyle = "#DDD"; // Light metallic effect
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(shipX + shipWidth * 0.3, shipY + shipHeight * 0.2);
            ctx.lineTo(shipX + shipWidth * 0.3, shipY + shipHeight * 0.8);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(shipX + shipWidth * 0.6, shipY + shipHeight * 0.3);
            ctx.lineTo(shipX + shipWidth * 0.6, shipY + shipHeight * 0.7);
            ctx.stroke();

            // 🔥 **Energy Core (Glowing Center)**
            let coreGradient = ctx.createRadialGradient(
                shipX + shipWidth * 0.45, shipY + shipHeight * 0.5, 0,
                shipX + shipWidth * 0.45, shipY + shipHeight * 0.5, shipHeight * 0.15
            );
            coreGradient.addColorStop(0, "white");
            coreGradient.addColorStop(1, energyColor);
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(shipX + shipWidth * 0.45, shipY + shipHeight * 0.5, shipHeight * 0.15, 0, Math.PI * 2);
            ctx.fill();

            // 🎇 **Invincible Mode Glow Effect**
            if (invincible) {
                let invincibleGlow = ctx.createRadialGradient(
                    shipX + shipWidth / 2, shipY + shipHeight / 2, 10,
                    shipX + shipWidth / 2, shipY + shipHeight / 2, 50
                );
                invincibleGlow.addColorStop(0, "rgba(255, 255, 255, 0.8)");
                invincibleGlow.addColorStop(1, "rgba(255, 255, 255, 0)");

                ctx.fillStyle = invincibleGlow;
                ctx.beginPath();
                ctx.arc(shipX + shipWidth / 2, shipY + shipHeight / 2, 40, 0, Math.PI * 2);
                ctx.fill();
            }

            // **EXTRA ARMOR (When Shooting is Enabled)**
            if (canShoot) {
                ctx.fillStyle = "#666"; // Darker metallic armor
                ctx.strokeStyle = "#BBB";
                ctx.lineWidth = 2;

                // **Side Armor**
                ctx.fillRect(shipX + 5, shipY + 5, 15, shipHeight - 10);
                ctx.fillRect(shipX + shipWidth - 20, shipY + 5, 15, shipHeight - 10);

                // **Side Cannons**
                ctx.fillStyle = "#333";
                ctx.fillRect(shipX + shipWidth * 0.1, shipY + shipHeight * 0.2, 10, 20);
                ctx.fillRect(shipX + shipWidth * 0.1, shipY + shipHeight * 0.6, 10, 20);
                ctx.fillRect(shipX + shipWidth * 0.9 - 10, shipY + shipHeight * 0.2, 10, 20);
                ctx.fillRect(shipX + shipWidth * 0.9 - 10, shipY + shipHeight * 0.6, 10, 20);

                // **Glowing Vents & Weapon Ports**
                ctx.fillStyle = "rgba(0, 255, 255, 0.7)";
                ctx.fillRect(shipX + shipWidth * 0.35, shipY + shipHeight * 0.1, 8, 4);
                ctx.fillRect(shipX + shipWidth * 0.35, shipY + shipHeight * 0.85, 8, 4);
                ctx.fillRect(shipX + shipWidth * 0.6, shipY + shipHeight * 0.1, 8, 4);
                ctx.fillRect(shipX + shipWidth * 0.6, shipY + shipHeight * 0.85, 8, 4);
            }
        }


        // Create obstacles: ground spikes and ceiling spikes
        function createObstacle() {
            const isEmojiBlock = Math.random() > 0.5; // 50% chance to generate emoji obstacles

            // Calculate possible spawn points to prevent overlap
            const numSections = 5; // Divide screen height into 5 sections
            const sectionHeight = (groundLevel - ceilingLevel) / numSections;
            let availableSections = Array.from({ length: numSections }, (_, i) => i);

            const sectionIndex = availableSections.splice(
                Math.floor(Math.random() * availableSections.length),
                1
            )[0];

            let newObstacle;

            if (isEmojiBlock) {
                const shape = emojiShapes[Math.floor(Math.random() * emojiShapes.length)];
                const blockSize = 30;
                const numRows = shape.pattern.length;
                const numCols = shape.pattern[0].length;

                // **Deep copy the pattern** to prevent modifying the original
                const copiedPattern = shape.pattern.map(row => [...row]);

                newObstacle = {
                    type: "emoji-block",
                    x: canvas.width,
                    width: numCols * blockSize,
                    height: numRows * blockSize,
                    pattern: copiedPattern,  // Use copied pattern instead of reference
                    blockSize: blockSize,
                    rows: numRows,
                    isGroundObstacle: Math.random() > 0.5,
                    passed: false
                };

                newObstacle.y = ceilingLevel + sectionIndex * sectionHeight + (sectionHeight - newObstacle.height) / 2;
            } else {
                // Traditional spike obstacle
                const width = 40 + Math.random() * 40;
                const height = 80 + Math.random() * 120;

                newObstacle = {
                    type: "spike",
                    x: canvas.width,
                    width,
                    height,
                    isGroundObstacle: Math.random() > 0.5,
                    passed: false
                };

                newObstacle.y = ceilingLevel + sectionIndex * sectionHeight + (sectionHeight - height) / 2;
            }

            // Prevent obstacles from spawning too close together
            if (obstacles.length > 0) {
                const lastObstacle = obstacles[obstacles.length - 1];
                if (newObstacle.x - lastObstacle.x < 150) {
                    return; // Avoid spawning too close
                }
            }

            obstacles.push(newObstacle);
        }

        function createCollectible() {
            if (Math.random() > 0.8) return; // Only 20% chance to spawn a collectible

            const item = collectibles[Math.floor(Math.random() * collectibles.length)];
            const size = 20;
            const yPos = Math.random() * (groundLevel - ceilingLevel - size) + ceilingLevel;

            activeCollectibles.push({
                emoji: item.emoji,
                name: item.name,
                points: item.points,
                x: canvas.width,
                y: yPos,
                size: size,
                collected: false
            });
        }


        // Draw ground and ceiling
        function drawGroundAndCeiling() {
            // Draw ceiling
            const ceilingGradient = ctx.createLinearGradient(0, 0, 0, ceilingLevel);
            ceilingGradient.addColorStop(0, '#0a0a0a');
            ceilingGradient.addColorStop(1, '#350101');
            ctx.fillStyle = ceilingGradient;
            ctx.fillRect(0, 0, canvas.width, ceilingLevel);

            // Ceiling details
            for (let i = 0; i < canvas.width; i += 40) {
                const height = 10 + Math.sin(i * 0.05 + gameTime * 0.01) * 5;
                ctx.fillStyle = '#8a0303';
                ctx.beginPath();
                ctx.moveTo(i, ceilingLevel);
                ctx.lineTo(i + 20, ceilingLevel);
                ctx.lineTo(i + 10, ceilingLevel + height);
                ctx.closePath();
                ctx.fill();
            }

            // Draw ground
            const groundGradient = ctx.createLinearGradient(0, groundLevel, 0, canvas.height);
            groundGradient.addColorStop(0, '#350101');
            groundGradient.addColorStop(1, '#0a0a0a');
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, groundLevel, canvas.width, canvas.height - groundLevel);

            // Ground details
            for (let i = 0; i < canvas.width; i += 40) {
                const height = 10 + Math.sin(i * 0.03 + gameTime * 0.01) * 5;
                ctx.fillStyle = '#8a0303';
                ctx.beginPath();
                ctx.moveTo(i, groundLevel);
                ctx.lineTo(i + 20, groundLevel);
                ctx.lineTo(i + 10, groundLevel - height);
                ctx.closePath();
                ctx.fill();
            }
        }

        // Draw obstacles
        function drawObstacles() {
            for (const obstacle of obstacles) {
                if (obstacle.type === "emoji-block") {
                    // Draw emoji obstacles
                    for (let row = 0; row < obstacle.rows; row++) {
                        for (let col = 0; col < obstacle.pattern[row].length; col++) {
                            const emoji = obstacle.pattern[row][col];
                            if (emoji === "") continue; // Skip empty spaces in pattern

                            const x = obstacle.x + col * obstacle.blockSize;
                            const y = obstacle.y + row * obstacle.blockSize;

                            ctx.font = `${obstacle.blockSize * 0.7}px Arial`;
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.fillStyle = "yellow";  // Brighter color
                            ctx.strokeStyle = "black"; // Outline for better visibility
                            ctx.lineWidth = 3;
                            ctx.strokeText(emoji, x + obstacle.blockSize / 2, y + obstacle.blockSize / 2);
                            ctx.fillText(emoji, x + obstacle.blockSize / 2, y + obstacle.blockSize / 2);

                        }
                    }
                }
            }
        }

        // Check for collisions
        function checkCollisions() {
            // 🚀 Adjusted hitbox: slightly smaller than the visible ship
            const shipHitbox = {
                left: shipX + 10,  // Offset for better accuracy
                right: shipX + shipWidth - 10,
                top: shipY + 5,
                bottom: shipY + shipHeight - 5
            };

            // ✅ **Check ground and ceiling collision**
            if (shipHitbox.bottom > groundLevel || shipHitbox.top < ceilingLevel) {
                console.warn("🚨 Ship hit ground or ceiling!");
                loseLife();
                shipFlicker = true;
                return;
            }

            // ✅ **Check obstacle collisions**
            for (const obstacle of obstacles) {
                if (obstacle.type === "emoji-block") {
                    for (let row = 0; row < obstacle.rows; row++) {
                        for (let col = 0; col < obstacle.pattern[row].length; col++) {
                            const emoji = obstacle.pattern[row][col];
                            if (emoji === "") continue; // Skip empty spaces

                            // More precise obstacle hitbox
                            const emojiHitbox = {
                                left: obstacle.x + col * obstacle.blockSize + 5,  // Reduce width sensitivity
                                right: obstacle.x + (col + 1) * obstacle.blockSize - 5,
                                top: obstacle.y + row * obstacle.blockSize + 5,   // Reduce height sensitivity
                                bottom: obstacle.y + (row + 1) * obstacle.blockSize - 5
                            };

                            // **Collision detection (Fixed)**
                            if (
                                !invincible &&
                                shipHitbox.right > emojiHitbox.left &&
                                shipHitbox.left < emojiHitbox.right &&
                                shipHitbox.bottom > emojiHitbox.top &&
                                shipHitbox.top < emojiHitbox.bottom
                            ) {
                                console.log("💥 Collision detected with an emoji!");
                                playSound("risada");
                                loseLife();
                                shipFlicker = true;
                                return;
                            }
                        }
                    }
                }

                // ✅ **Check if obstacle has been passed (increase score)**
                if (!obstacle.passed && shipX > obstacle.x + obstacle.width) {
                    obstacle.passed = true;
                    score++;
                    obstacleSpeed += 0.04; // Gradual difficulty increase
                }
            }

            // ✅ **Check for collectible pickups**
            for (let i = activeCollectibles.length - 1; i >= 0; i--) {
                const item = activeCollectibles[i];

                // Define the hitbox for the collectible item
                const itemHitbox = {
                    left: item.x - item.size / 2,
                    right: item.x + item.size / 2,
                    top: item.y - item.size / 2,
                    bottom: item.y + item.size / 2
                };

                // **Collision detection with the ship**
                if (
                    shipHitbox.right > itemHitbox.left &&
                    shipHitbox.left < itemHitbox.right &&
                    shipHitbox.bottom > itemHitbox.top &&
                    shipHitbox.top < itemHitbox.bottom
                ) {
                    playSound("collect");
                    console.log(`✅ Collected: ${item.name}`);
                    score += item.points;
                    inventory[item.emoji]++;
                    updateInventoryDisplay();
                    activeCollectibles.splice(i, 1); // Remove collected item

                    // **Apply effects**
                    if (item.emoji === "💀") {
                        console.log("⚡ Invincibility Activated!");
                        invincible = true;
                        invincibleTimer = 2500;
                        playSound("shield");

                        // ✨ Boost the ship glow when collecting a drop
                        shipGlow.radius = 40; // Temporarily increase glow
                        setTimeout(() => { shipGlow.radius = 20; }, 500); // Reset after 500ms
                    }

                    if (item.emoji === "🐦‍🔥") {
                        console.log("🐦‍🔥 Time Slowdown Activated!");
                        slowDownTime();
                    }

                    if (item.emoji === "🔫") {
                        canShoot = true;
                        shootTimer = 1500;
                        console.log("🚀 Shooting enabled!");

                        if (inventory["🔫"] >= 3) {
                            activateLaserMode();
                            inventory["🔫"] = 0
                        }
                    }

                    if (item.emoji === "💩") {
                        console.log("💩 Diamond collected! Movement sensitivity reduced!");
                        currentAcceleration = slowAcceleration;
                        slowMovementTimer = 1500;
                    }

                    if (item.emoji === "☢️") {
                        console.log("☢️ RADIATION EXPLOSION ACTIVATED!");
                        explodeAllObstacles();
                    }
                }
            }
        }

        function slowDownTime() {
            window.isTimeSlowed = true;

            const originalSpeed = obstacleSpeed; // Store the original speed
            const originalBackgroundSpeed = backgroundSpeed; // Store the original speed

            obstacleSpeed *= 0.4; // Slow down time (reduce speed by half)
            backgroundSpeed *= .4;
            console.log("Game slowed down!");

            // Restore speed after 5 seconds
            setTimeout(() => {
                console.log("Game speed restored!");
                window.isTimeSlowed = false; // Allow future slowdowns
            }, 5000);
        }

        function explodeAllObstacles() {
            if (obstacles.length === 0) return;

            playSound("explosionAll");

            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obstacle = obstacles[i];

                // Get obstacle position and size
                let explosionX = obstacle.x + obstacle.width / 2;
                let explosionY = obstacle.y + obstacle.height / 2;

                // Create explosion effect
                createExplosion(explosionX, explosionY);

                // Remove obstacle from game
                obstacles.splice(i, 1);
            }

            console.log("💥 ALL OBSTACLES DESTROYED!");
        }

        function loseLife() {
            if (isHit) return; // Prevent multiple hits in a short time
            isHit = true;
            isExploding = true; // 🚨 Set exploding state to keep rendering

            playSound("explosion");

            lives--; // Subtract 1 life
            console.log(`💥 Ship hit! Lives left: ${lives}`);

            createExplosion(shipX + shipWidth / 2, shipY + shipHeight / 2); // Generate explosion effect

            // **Stop ship movement, obstacles, but keep explosion running**
            shipVelocity = 0;
            shipXVelocity = 0;
            obstacleSpeed = 0;

            setTimeout(() => {
                isExploding = false; // Stop explosion effect after delay
                if (lives > 0) {
                    restartAfterHit();
                } else {
                    gameOver = true;
                    playSound("gameover");
                    gameOverScreen.style.display = 'flex';
                    gameOverScreen.style.fontSize = 40;
                    gameOverScoreDisplay.textContent = `${score}`;
                }
                obstacleSpeed = .4; // Reset speed
            }, 2000); // 2-second delay before restarting
        }

        function restartAfterHit() {
            console.log("⏪ Restarting after hit...");

            // Reset explosion state
            isHit = false;
            isExploding = false;

            // Reset ship position and movement
            shipY = canvas.height / 2;
            shipVelocity = 0;
            shipX = canvas.width * 0.2;
            shipXVelocity = 0;

            // Restore obstacle movement
            obstacleSpeed = .4;

            // Temporary invincibility after hit
            invincible = true;
            invincibleTimer = 600;

            canShoot = false;
            shootTimer = 0;
        }

        // Handle keyboard input
        const keys = {};


        let touchStartX = null;
        let touchStartY = null;
        let touchStartTime = null;
        let isMoving = false; // Track if the user is swiping or tapping

        window.addEventListener("touchstart", (e) => {
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                touchStartTime = Date.now();
                isMoving = false; // Reset movement state
            }
        });

        window.addEventListener("touchmove", (e) => {
            if (touchStartX === null || touchStartY === null) return;

            let touchX = e.touches[0].clientX;
            let touchY = e.touches[0].clientY;
            let deltaX = touchX - touchStartX;
            let deltaY = touchY - touchStartY;

            let movementThreshold = 10; // Lower threshold for smoother control
            let adjustedTouchSensitivity = currentAcceleration * 20; // Adjust movement strength

            // **Detect swipe movement in both directions**
            if (Math.abs(deltaX) > movementThreshold || Math.abs(deltaY) > movementThreshold) {
                isMoving = true; // Mark as a movement (not a tap)

                // **Allow diagonal movement naturally**
                shipXVelocity += (deltaX * adjustedTouchSensitivity) * 0.02;
                shipVelocity += (deltaY * adjustedTouchSensitivity) * 0.08;

                // **Update last touch position for smoother movement**
                touchStartX = touchX;
                touchStartY = touchY;
            }
        });

        window.addEventListener("touchend", (e) => {
            if (touchStartX === null || touchStartY === null) return;

            let touchEndX = e.changedTouches[0].clientX;
            let touchEndY = e.changedTouches[0].clientY;
            let touchEndTime = Date.now();

            let deltaX = touchEndX - touchStartX;
            let deltaY = touchEndY - touchStartY;
            let timeDiff = touchEndTime - touchStartTime;

            let tapThreshold = 120; // Max time for a tap (milliseconds)
            let minMovement = 20; // Ignore very small accidental movements

            // **Detect a tap (not a swipe) → SHOOT**
            if (!isMoving && timeDiff < tapThreshold && Math.abs(deltaX) < minMovement && Math.abs(deltaY) < minMovement) {
                shootBullet();
            }

            // Reset touch tracking
            touchStartX = null;
            touchStartY = null;
            touchStartTime = null;
        });


        window.addEventListener('keydown', e => {
            keys[e.key] = true;
        });
        window.addEventListener('keyup', e => {
            keys[e.key] = false;
        });
        window.addEventListener("keydown", (e) => {
            if (e.key === " " || e.code === "Space") {
                shootBullet();
            }
        });

        function handleInput() {
            if (keys['w'] || keys['W'] || keys['ArrowUp']) {
                shipVelocity -= currentAcceleration * 4;
            }
            if (keys['s'] || keys['S'] || keys['ArrowDown']) {
                shipVelocity += currentAcceleration * 2;
            }
            if (keys['a'] || keys['A'] || keys['ArrowLeft']) {
                shipXVelocity -= currentAcceleration * 1.2;
            }
            if (keys['d'] || keys['D'] || keys['ArrowRight']) {
                shipXVelocity += currentAcceleration;
            }
        }

        // Update game state
        let nextCollectibleTime = gameTime + Math.floor(Math.random() * 500) + 300; // Initial random delay

        function updateGame() {
            if (!gameStarted || gameOver || isHit) return;

            gameTime++;
            handleInput();

            if (invincible) {
                invincibleTimer--;
                if (invincibleTimer <= 0) {
                    invincible = false;
                    console.log("Invincibility Over!");
                }
            }

            // Move ship vertically
            shipVelocity += gravity;
            shipVelocity *= 0.6;
            shipY += shipVelocity;

            // Limit ship velocity
            if (shipVelocity > 10) shipVelocity = 10;
            if (shipVelocity < -10) shipVelocity = -10;

            // Apply friction to smooth horizontal movement
            shipXVelocity *= shipFriction;
            shipX += shipXVelocity;

            // Prevent out-of-bounds movement
            if (shipX < 0) shipX = 0;
            if (shipX > canvas.width - shipWidth) shipX = canvas.width - shipWidth;
            if (shipY < ceilingLevel) shipY = ceilingLevel;
            if (shipY > groundLevel - shipHeight) shipY = groundLevel - shipHeight;

            // Add ship trail particles
            if (gameTime % 2 === 0) {
                createShipTrail();
            }

             // 🚀 **Check High Speed for Ghost Sound Effect**
            if (obstacleSpeed > fastSpeedThreshold) {
                playSound("ghost");
            }

            updateParticles();

            // Move obstacles using `obstacleSpeed`
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].x -= obstacleSpeed;
                if (obstacles[i].x < -obstacles[i].width) {
                    obstacles.splice(i, 1);
                }
            }

            // Move collectibles using `obstacleSpeed`
            for (let i = activeCollectibles.length - 1; i >= 0; i--) {
                activeCollectibles[i].x -= obstacleSpeed;
                if (activeCollectibles[i].x < -50) {
                    activeCollectibles.splice(i, 1);
                }
            }

            // Spawn collectibles occasionally
            if (gameTime >= nextCollectibleTime) {
                createCollectible();
                nextCollectibleTime = gameTime + Math.floor(Math.random() * 500) + 300; // Set next spawn
            }


            // Adjust the spawn frequency based on obstacle speed
            let obstacleSpawnRate = Math.max(80, 200 - obstacleSpeed * 20);
            // Faster speed = more frequent obstacles, but never less than 80 frames apart

            // Spawn obstacles dynamically
            if (gameTime - lastObstacleTime > obstacleSpawnRate) {
                createObstacle();
                lastObstacleTime = gameTime;
            }

            // Reduce shooting timer
            if (canShoot && shootTimer > 0) {
                shootTimer--;
                if (shootTimer <= 0) {
                    canShoot = false;
                    console.log("🐦‍🔥 Shooting ability expired!");
                }
            }

            if (slowMovementTimer > 0) {
                slowMovementTimer--;
                if (slowMovementTimer <= 0) {
                    currentAcceleration = normalAcceleration;
                    console.log("🐦‍🔥 Diamond effect over! Movement back to normal.");
                }
            }

            checkCollisions();

            // Update UI
            scoreDisplay.innerHTML = `Score\n${score}`;
            document.getElementById('lives').innerHTML = `❤️ Vidas ${lives}`;
        }


        // Main draw function
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawBackground();   // Draw background first
            drawObstacles();    // Then obstacles
            drawParticles();    // Then ship trail
            drawCollectibles();

            if (!isHit) drawShip();  // ❌ Hide ship if hit
            drawExplosion();  // Draw explosion effect

            drawGroundAndCeiling(); // Finally, draw ceiling & ground
        }

        function updateInventoryDisplay() {
            const inventoryDisplay = document.getElementById('inventory');
            inventoryDisplay.innerHTML = `
                💀 ${inventory["💀"]}
                💩 ${inventory["💩"]}
                🔫 ${inventory["🔫"]}
                🐦‍🔥 ${inventory["🐦‍🔥"]}
                ☢️ ${inventory["☢️"]}`
        }

        // Game loop
        function gameLoop() {
            if (!gameOver) {
                if (!isExploding) { // 🚨 Only stop updates, not rendering
                    updateGame();
                    updateBullets();
                }
                updateExplosion(); // ✅ Always update explosion effect
            }

            draw();
            drawBullets();
            drawLaser();
            drawExplosion(); // ✅ Ensure explosion is drawn

            requestAnimationFrame(gameLoop);
        }


        // Start the game
        startButton.addEventListener('click', () => {
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none'; // Hide Game Over screen if visible
            gameStarted = true;
            startMusic();
            createBackgroundLayers();
            gameLoop();
        });

        // Restart the game
        restartButton.addEventListener('click', () => {
            console.log("🔄 Restarting game...");

            // Stop any ongoing animations
            cancelAnimationFrame(gameLoop);

            // Hide game over screen
            gameOverScreen.style.display = 'none';

            // Reset game state
            gameStarted = true;
            gameOver = false;
            isExploding = false;  // Ensure ship is not "exploding"
            isHit = false;        // Prevent blinking effect
            flickerCount = 0;

            // Reset ship position and movement
            shipY = canvas.height / 2;
            shipX = canvas.width * 0.2;
            shipVelocity = 0;
            shipXVelocity = 0;

            backgroundSpeed = 5;
            obstacleSpeed = 1;

            // Reset obstacles, collectibles, and inventory
            obstacles = [];
            activeCollectibles = [];
            let inventory = { "💀": 0, "💩": 0, "🔫": 0, "🐦‍🔥": 0, "☢️": 0 };

            // Reset timers and speeds
            lastObstacleTime = 0;
            lastCollectibleTime = 0;
            gameTime = 0;
            lives = 5;
            invincible = false;
            invincibleTimer = 0;

            // Reset UI
            score = 0;
            scoreDisplay.textContent = `Score\n${score}`;
            document.getElementById('lives').innerHTML = `❤️ Vidas ${lives}`;
            updateInventoryDisplay();

            // Reset background and start fresh
            createBackgroundLayers();

            // Restart the game loop
            requestAnimationFrame(gameLoop);
        });

        // Handle game over
        function handleGameOver() {
            if (gameOver) {
                gameOverScreen.style.display = 'flex';
                gameOverScreen.style.fontSize = 40;
                gameOverScoreDisplay.textContent = score;
            }
        }

        // Set up resize handler
        window.addEventListener('resize', () => {
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                groundLevel = canvas.height * 0.8;
                ceilingLevel = canvas.height * 0.2;
                shipY = canvas.height / 2;
                gravity = /iPhone|iPad|Android|Mobile/i.test(navigator.userAgent) ? mobileGravity : normalGravity;
            }

            // Resize once on load & listen for screen changes
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            groundLevel = canvas.height * 0.8;
            ceilingLevel = canvas.height * 0.2;
            shipY = canvas.height / 2;
        });

        // Start animation
        gameLoop();

        // Check for game over in a separate interval
        setInterval(handleGameOver, 100);
    </script>
</body>
</html>

[memoria.html]
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Memory Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* General Body Styles */
body {
    font-family: 'Segoe UI', sans-serif;
    min-height: 100vh;
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    position: relative;
    background: #1e1e2f;
}

/* Animated Background Layers */
body::before, body::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at center, #6366f1, #a855f7, #f43f5e, #10b981);
    animation: moveBackground 20s linear infinite alternate;
    z-index: -1;
    opacity: 0.4;
    filter: blur(100px);
}

body::after {
    animation: moveBackground 30s linear infinite alternate-reverse;
    opacity: 0.3;
}

/* Main Game Container */
#container {
    display: none;
    background: rgba(255, 255, 255, 0.95);
    padding: 2.5vw;
    border-radius: 1rem;
    width: 80vw;
    max-width: 500px;
    max-height: 80vh;
    overflow: hidden;
    box-shadow: 0 0 40px rgba(163, 77, 255, 0.5), 0 0 80px rgba(163, 77, 255, 0.3);
    animation: glowEffect 4s ease-in-out infinite alternate;
}

/* Subtle Glowing Effect */
@keyframes glowEffect {
    0% { box-shadow: 0 0 20px rgba(163, 77, 255, 0.3), 0 0 40px rgba(163, 77, 255, 0.2); }
    100% { box-shadow: 0 0 40px rgba(163, 77, 255, 0.5), 0 0 80px rgba(163, 77, 255, 0.3); }
}

.category-name {
    position: absolute;
    top: clamp(2rem, 15vh, 5vh);
    left: 50%;
    transform: translateX(-50%);
    font-size: clamp(2rem, 5vw, 3rem);
    font-weight: bold;
    color: #9c96ff;
    text-shadow: 0 0 10px rgb(44 40 107);
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    z-index: 5;
    text-align: center;
    white-space: nowrap;
}

/* Header Styling */
.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 1rem;
    margin-bottom: 1rem;
    padding: 0.5rem;
    background: #efefef;
    border-radius: 10px;
}

/* Start Button */
.start-button {
    background: #6366f1;
    color: white;
    padding: clamp(0.8rem, 2vw, 1.5rem) clamp(1.5rem, 4vw, 3rem);
    font-size: clamp(1.2rem, 4vw, 2rem);
    border: none;
    border-radius: 1rem;
    cursor: pointer;
    transition: background-color 0.2s;
}

.start-button:hover {
    background: #4f46e5;
}

/* Button and Select */
button {
    background: #6366f1;
    color: white;
    padding: 10px 15px;
    border: none;
    border-radius: 0.5rem;
    font-size: clamp(1rem, 3vw, 1.2rem);
    cursor: pointer;
    transition: background-color 0.2s;
}

button:hover {
    background: #4f46e5;
}

select {
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    background-color: #6366f1;
    color: white;
    padding: 0 35px 0 20px;
    border: none;
    border-radius: 0.5rem;
    font-size: clamp(1rem, 3vw, 1.2rem);
    cursor: pointer;
    position: relative;
    transition: background-color 0.2s;
    background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="white"><path d="M7 10l4 5 4-5z"/></svg>');
    background-repeat: no-repeat;
    background-position: calc(100% - 6px) center;
    background-size: 30px;
}

@media (max-width: 768px) {
    select {
        width: 25px;
        height: 25px;
        padding: 0;
        border-radius: 50%;
        background-position: center;
        background-size: 23px;
        text-indent: -9999px;
        margin-top: 9px;
    }

    select option {
        padding: 10px 15px;
        background-color: #6366f1;
        color: white;
        font-size: 1rem;
        cursor: pointer;
    }
}

/* Hover effect */
select:hover {
    background-color: #4f46e5;
}

/* Memorize Label */
.memorize-label {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 1rem 2rem;
    border-radius: 0.5rem;
    font-size: clamp(1.5rem, 4vw, 2rem);
    display: none;
    z-index: 10;
}

/* Stats Container */
.stats {
    display: flex;
    justify-content: space-between;
    width: 100%;
}

/* Stat and Timer */
.stat, .timer {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 5px;
    padding: 0.4rem 0.8rem;
    border-radius: 0.5rem;
    font-size: clamp(1.3rem, 3vw, 1.2rem);
}

/* Timer Glow */
.timer.glow {
    color: #ff3333;
    text-shadow: 0 0 10px #ff3333, 0 0 20px #ff3333, 0 0 30px #ff0000;
}

/* Game Grid */
.game-grid {
    display: grid;
    gap: 1vw;
    grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
}

/* Card Styling */
.card {
    aspect-ratio: 1;
    font-size: clamp(1.5rem, 8vw, 3rem);
    background: #fff;
    border: 2px solid #e5e7eb;
    border-radius: 0.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.3s ease;
    transform-style: preserve-3d;
}

.card.flipped {
    transform: rotateY(180deg);
}

.card:hover {
    border-color: #6366f1;
}

/* Card Sides */
.card-front, .card-back {
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
}

.card-back {
    background: #6366f1;
    transform: rotateY(180deg);
    border-radius: 0.3rem;
}

/* Game Over Modal */
.game-over {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.8);
    display: none;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    gap: 1rem;
    color: white;
    font-size: clamp(1.5rem, 4vw, 2rem);
}

.win-message {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8);
    color: #10b981;
    padding: 2rem 4rem;
    border-radius: 1rem;
    font-size: clamp(2rem, 6vw, 4rem);
    font-weight: bold;
    z-index: 20;
    display: none;
    text-shadow: 0 0 20px #10b981, 0 0 40px #10b981;
}

.game-over.show {
    display: flex;
}


    </style>
</head>
<body>
    <div id="startOverlay" class="start-overlay">
        <button id="start" class="start-button">Iniciar Jogo</button>
    </div>
    <div id="container">
        <div id="categoryName" class="category-name"></div>

        <div class="header">
            <div class="stats">
                <div class="stat">🏆 <span id="wins">0</span></div>
                <div class="stat">❌ <span id="fails">0</span></div>
                <div class="stat">⭐ <span id="score">0</span></div>
                <div class="timer">⏰ <span id="timer">60s</span></div>
                <select id="gridSize">
                    <option value="4x4">4x4</option>
                    <option value="4x5">4x5</option>
                    <option value="5x5">5x5</option>
                </select>
            </div>

            <div id="memorizeLabel" class="memorize-label">MEMORIZE AS CARTAS</div>

        </div>
        <div class="game-grid" id="gameGrid"></div>
    </div>

    <div id="winMessage" class="win-message">BOA!</div>

    <div class="game-over" id="gameOver">
        <h2>Fim de Jogo!</h2>
        <p>Pontuação Final: <span id="finalScore">0</span></p>
        <button onclick="restartGame()">Jogar Novamente</button>
    </div>

    <script>
        const emojiCategories = [
            {
                name: 'Bicharada Divertida',
                emojis: ['🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼', '🦁', '🐯']
            },
            {
                name: 'Banquete Maluco',
                emojis: ['🍔', '🍟', '🍕', '🌭', '🍗', '🍖', '🥪', '🥗', '🍿', '🍝']
            },
            {
                name: 'Esporte é Vida',
                emojis: ['⚽', '🏀', '🏈', '⚾', '🎾', '🏐', '🥊', '🏓', '⛳', '🚴']
            },
            {
                name: 'Flores Encantadas',
                emojis: ['🌹', '🌻', '🌼', '🌸', '🌷', '💐', '🌺', '🌿', '🍀', '🌾']
            },
            {
                name: 'Brum Brum Aventuras',
                emojis: ['🚗', '🚕', '🚙', '🚌', '🚎', '🏎️', '🚓', '🚑', '🚒', '🚚']
            },
            {
                name: 'Clima Maluco',
                emojis: ['☀️', '🌤️', '⛅', '🌧️', '⛈️', '❄️', '🌪️', '🌈', '🌙', '⭐']
            },
            {
                name: 'Frutas do Paraíso',
                emojis: ['🍎', '🍊', '🍋', '🍌', '🍉', '🍇', '🍓', '🍍', '🥭', '🥝']
            },
            {
                name: 'Profissões Geniais',
                emojis: ['👩‍⚕️', '👨‍⚕️', '👩‍🏫', '👨‍🏫', '👩‍💻', '👨‍💻', '👩‍🚀', '👨‍🚀', '👩‍🍳', '👨‍🍳']
            },
            {
                name: 'Orquestra Maluca',
                emojis: ['🎸', '🎺', '🎷', '🥁', '🎻', '🎹', '🪕', '🪘', '🎼', '🎤']
            },
            {
                name: 'Mistérios do Mar',
                emojis: ['🐠', '🐟', '🐡', '🦈', '🐬', '🐳', '🐋', '🦭', '🦀', '🦐']
            },
            {
                name: 'Coisas Sinistras',
                emojis: ['👻', '☠️', '💀', '🦴', '🧛', '🧟', '🦷', '🕷️', '🕸️', '🦠']
            },
            {
                name: 'Lendas e Magias',
                emojis: ['🧞', '🧙', '👹', '👺', '👽', '👾', '🤖', '⚰️', '🪦', '🩸']
            },
            {
                name: 'Sinais Misteriosos',
                emojis: ['⚠️', '🚸', '⛔', '🚫', '🔞', '♻️', '🆘', '🚷', '🛑', '📵']
            }
        ];

        let flippedCards = [];
        let matchedPairs = 0;
        let totalPairs = 0;
        let wins = 0;
        let currentCategory = null;
        let score = 0;
        let fails = 0;
        let timeLeft = 60;
        let gameTimer;
        let isGameOver = false;
        let canFlip = false;
        let currentBackgroundAudio = null;
        let currentEffectAudio = null;

        document.getElementById('start').addEventListener('click', () => {
            setTimeout(() => {
                adjustBoardForDevice();
            }, 100);
            document.getElementById('startOverlay').style.display = 'none';
            document.getElementById('memorizeLabel').style.display = 'block';
            startGame();

            setTimeout(() => {
                document.getElementById('memorizeLabel').style.display = 'none';
            }, 1000);
        });

        document.getElementById('gridSize').addEventListener('change', () => {
            restartGame();
        });

        function startGame() {
            resetGame();
            createGame();
            previewCards();
        }

        function createGame() {
            const container = document.getElementById('container');
            const gameGrid = document.getElementById('gameGrid');
            const categoryName = document.getElementById('categoryName');
            const gridSize = document.getElementById('gridSize').value;
            const [cols, rows] = gridSize.split('x').map(Number);
            let totalCards = cols * rows;

            if (totalCards % 2 !== 0) {
                totalCards -= 1;
            }

            totalPairs = totalCards / 2;

            // Select a random, different category
            let availableCategories = emojiCategories.filter(cat => cat !== currentCategory);
            currentCategory = availableCategories[Math.floor(Math.random() * availableCategories.length)];

            const selectedEmojis = shuffleArray(currentCategory.emojis).slice(0, totalPairs);
            const gameEmojis = shuffleArray([...selectedEmojis, ...selectedEmojis]);

            // Display the category name
            categoryName.textContent = currentCategory.name;

            container.style.display = 'block';
            gameGrid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            gameGrid.innerHTML = '';

            gameEmojis.forEach(emoji => {
                const card = document.createElement('div');
                card.className = 'card';
                card.innerHTML = `<div class="card-front"></div><div class="card-back">${emoji}</div>`;
                card.dataset.emoji = emoji;
                card.addEventListener('click', handleCardClick);
                gameGrid.appendChild(card);
            });
        }

        function previewCards() {
            const cards = document.querySelectorAll('.card');
            cards.forEach(card => card.classList.add('flipped'));

            setTimeout(() => {
                cards.forEach(card => card.classList.remove('flipped'));
                canFlip = true;
                startTimer();
            }, 3000);
        }

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function handleCardClick(e) {
            const card = e.currentTarget;
            if (!canFlip || flippedCards.length === 2 || card.classList.contains('flipped')) return;

            card.classList.add('flipped');
            flippedCards.push(card);

            if (flippedCards.length === 2) {
                checkMatch();
            }
        }

        function checkMatch() {
            const [card1, card2] = flippedCards;
            if (card1.dataset.emoji === card2.dataset.emoji) {
                score += 10;
                matchedPairs++;
                playSound('match');
                checkWinCondition();
            } else {
                fails++;
                score -= 5
                document.getElementById('fails').textContent = fails;
                playSound('no-match');
                setTimeout(() => {
                    card1.classList.remove('flipped');
                    card2.classList.remove('flipped');
                }, 1000);
            }
            document.getElementById('score').textContent = score;
            flippedCards = [];
        }

        function checkWinCondition() {
            if (matchedPairs === totalPairs) {
                endGame(true);
            }
        }

        function updateTimerDisplay() {
            const timerElement = document.getElementById('timer');
            const minFontSize = 20;
            const maxFontSize = 32;
            const maxTime = 60;
            const remainingTime = Math.max(0, timeLeft);

            // Apply glow effect if time is less than 10 seconds
            if (remainingTime <= 10) {
                timerElement.classList.add('glow');
            } else {
                timerElement.classList.remove('glow');
            }

            timerElement.textContent = remainingTime;
        }

        function startTimer() {
            clearInterval(gameTimer);
            gameTimer = setInterval(() => {
                timeLeft--;
                updateTimerDisplay();

                if (timeLeft <= 0) {
                    clearInterval(gameTimer);
                    endGame(false);
                }
            }, 1000);
        }

        function endGame(isWin) {
            clearInterval(gameTimer);
            isGameOver = true;

            if (isWin) {
                wins++;
                document.getElementById('wins').textContent = wins;
                playSound('win');
                showWinMessage();

                setTimeout(() => {
                    // Upgrade board size based on wins
                    if (wins === 3) {
                        document.getElementById('gridSize').value = '4x5';
                    } else if (wins === 5) {
                        document.getElementById('gridSize').value = '5x5';
                    }
                    restartGame();
                }, 2000);
            } else {
                document.getElementById('finalScore').textContent = score;
                document.getElementById('gameOver').classList.add('show');
                playSound('lose');
            }
        }

        function showWinMessage() {
            const winMessage = document.getElementById('winMessage');
            winMessage.style.display = 'block';

            setTimeout(() => {
                winMessage.style.display = 'none';
            }, 2000);
        }

        function restartGame() {
            resetGame();
            createGame();
            previewCards();
        }

        function resetGame() {
            flippedCards = [];
            matchedPairs = 0;
            score = 0;
            fails = 0;
            timeLeft = 60;
            isGameOver = false;
            canFlip = false;

            document.getElementById('score').textContent = score;
            document.getElementById('fails').textContent = fails;
            document.getElementById('timer').textContent = timeLeft;
            document.getElementById('gameOver').classList.remove('show');
            clearInterval(gameTimer);

            // Stop any existing music and play new track
            const randomTrack = `music${Math.floor(Math.random() * 4) + 1}`;
            playSound(randomTrack, { loop: true, isMusic: true });
        }

        function playSound(name, options = { loop: false, isMusic: false }) {
            const audio = new Audio(`./assets/audio/${name}.mp3`);
            audio.loop = options.loop;

            // Handle background music
            if (options.isMusic) {
                if (currentBackgroundAudio) {
                    currentBackgroundAudio.pause();
                    currentBackgroundAudio.currentTime = 0;
                }
                currentBackgroundAudio = audio;
            } else {
                // Handle sound effects
                if (currentEffectAudio) {
                    currentEffectAudio.pause();
                    currentEffectAudio.currentTime = 0;
                }
                currentEffectAudio = audio;
            }

            audio.play().catch(error => {
                console.error('Error playing sound:', error);
            });
        }

    </script>
</body>
</html>

[aventuras_da_cobrinha.html]
<!DOCTYPE html>
<html lang="pt-br">
<head>
	<meta charset="UTF-8">
	<title>Aventuras da Cobrinha</title>
	<meta name="viewport" content="width=device-width, initial-scale=.9">
	<style>
		body {
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			background: linear-gradient(135deg, #1a2a3a, #0d1b2a);
			margin: 0;
			padding: 20px;
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			color: white;
			height: 95vh;
			overflow: hidden;
		}

		.game-container {
			position: relative;
			width: 100%;
			max-width: 900px;
			height: auto;
			aspect-ratio: 1 / 1;
		}

		canvas {
			width: 100%;
			height: 100%;
			border: 5px solid #2a4365;
			border-radius: 15px;
			background: #000;
		}

		.ui-container {
			display: flex;
			justify-content: space-between;
			position: relative;
			width: 100%;
			max-width: 900px;
			height: auto;
			margin-bottom: 20px;
		}

		.stats {
			width: 15vw;
			display: flex;
			justify-content: space-between;
			font-size: 20px;
			color: #a0e4ff;
			text-shadow: 0 0 10px rgba(160, 228, 255, 0.6);
		}

		#lives {
			font-size: 20px;
			color: #ff6b6b;
			text-shadow: 0 0 10px rgba(255, 107, 107, 0.6);
		}

		.level-indicator {
			font-size: 20px;
			color: #ffd166;
			text-shadow: 0 0 15px rgba(255, 209, 102, 0.7);
		}

		.game-over {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			font-size: 60px;
			font-weight: bold;
			color: #ff4757;
			text-shadow: 0 0 20px rgba(255, 71, 87, 0.8);
			display: none;
			text-align: center;
		}

		.game-over button {
			background: #2a4365;
			color: white;
			border: none;
			padding: 15px 30px;
			margin-top: 20px;
			font-size: 20px;
			border-radius: 8px;
			cursor: pointer;
			transition: all 0.3s;
		}

		.game-over button:hover {
			background: #3a5375;
			transform: scale(1.05);
			box-shadow: 0 0 15px rgba(41, 121, 255, 0.6);
		}

		svg {
			display: none;
		}

		.power-up-indicator {
			position: absolute;
			top: 10px;
			right: 10px;
			display: flex;
			align-items: center;
			gap: 10px;
			font-size: 20px;
			color: #a0e4ff;
			opacity: 0;
			transition: opacity 0.3s;
		}

		.power-up-indicator.active {
			opacity: 1;
		}

		.power-up-icon {
			width: 30px;
			height: 30px;
			border-radius: 50%;
		}
	</style>
</head>
<body>
	<div class="ui-container">
		<div class="stats">
			<div id="lives">🩸 3</div>
			<div id="score">⭐ 0</div>
			<div class="level-indicator" id="level">🏆 1</div>
		</div>
	</div>

	<div class="game-container">
		<canvas id="gameCanvas" width="900" height="900"></canvas>
		<div class="game-over" id="startGame">
			<div>Aventuras da Cobrinha</div>
			<button id="restartButton">Jogar</button>
		</div>
		<div class="game-over" id="gameOver">
			<div>Perdeu!!</div>
			<div id="finalScore" style="font-size: 36px; margin-top: 20px;">Score 0</div>
			<div id="highScore" style="font-size: 36px; margin-top: 20px;">Score máximo 0</div>
			<button id="restartButton">Jogar</button>
		</div>
		<div class="power-up-indicator" id="powerUpIndicator">
			<div class="power-up-icon" id="powerUpIcon"></div>
			<div id="powerUpText">Velocidade!</div>
		</div>
	</div>

	<!-- SVG assets -->
	<svg id="snakeHead" viewBox="0 0 20 20">
		<circle cx="10" cy="10" r="9" fill="#4ade80"/>
		<circle cx="6" cy="7" r="2" fill="#000"/>
		<circle cx="14" cy="7" r="2" fill="#000"/>
		<path d="M7 12 C10 15, 13 12, 13 12" stroke="#000" stroke-width="1.5" fill="none"/>
	</svg>

	<svg id="snakeHeadPowerUp" viewBox="0 0 20 20">
		<circle cx="10" cy="10" r="9" fill="#8b5cf6"/>
		<circle cx="6" cy="7" r="2" fill="#000"/>
		<circle cx="14" cy="7" r="2" fill="#000"/>
		<path d="M7 11 C10 15, 13 11, 13 11" stroke="#000" stroke-width="1.5" fill="none"/>
		<circle cx="10" cy="10" r="11" fill="none" stroke="#d8b4fe" stroke-width="1" opacity="0.7">
			<animate attributeName="r" values="9;12;9" dur="1s" repeatCount="indefinite"/>
			<animate attributeName="opacity" values="0.7;0.3;0.7" dur="1s" repeatCount="indefinite"/>
		</circle>
	</svg>

	<script>
		const config = {
			gridSize: 900,
			cellSize: 30,
			initialSpeed: 110,
			speedIncrement: 5,
			maxSpeed: 50,
			foodCount: 1,
			powerUpChance: 0.1,
			powerUpDuration: 5000,
			difficultyThreshold: 5
		};

		// Game elements
		const canvas = document.getElementById('gameCanvas');
		const ctx = canvas.getContext('2d');
		const gameOver = document.getElementById('gameOver');
		const finalScore = document.getElementById('finalScore');
		const scoreElement = document.getElementById('score');
		const highScoreElement = document.getElementById('highScore');
		const levelElement = document.getElementById('level');
		const restartButton = document.getElementById('restartButton');
		const powerUpIndicator = document.getElementById('powerUpIndicator');
		const powerUpIcon = document.getElementById('powerUpIcon');
		const powerUpText = document.getElementById('powerUpText');

		// Game state
		let lives = 3;
		let isRecovering = false;
		let snake = [];
		let direction = { x: config.cellSize, y: 0 };
		let nextDirection = { x: config.cellSize, y: 0 };
		let food = [];
		let powerUps = [];
		let activePowerUp = null;
		let powerUpTimer = null;
		let score = 0;
		let highScore = localStorage.getItem('snakeHighScore') || 0;
		let level = 1;
		let gameSpeed = config.initialSpeed;
		let lastUpdate = 0;
		let gameActive = false;
		let gamePaused = false;
		let currentBackgroundAudio = null;
        let currentEffectAudio = null;

		// Images
		const images = {};

		// Power-up types
		const powerUpTypes = [
		{
			name: 'speed',
			color: '#8b5cf6',
			effect: () => {
				const originalSpeed = gameSpeed;
				gameSpeed = Math.max(config.maxSpeed, gameSpeed - 40);
				return () => { gameSpeed = originalSpeed; };
			},
			text: 'Veloz!'
		},
		{
			name: 'points',
			color: '#f59e0b',
			effect: () => {
				// No state change needed, just double points on next few foods
				return () => {}; // No cleanup needed
			},
			text: 'Pontos em dobro!'
		},
		{
			name: 'ghost',
			color: '#94a3b8',
			effect: () => {
				// Original state is already preserved in game logic
				return () => {}; // No cleanup needed
			},
			text: 'Modo fantasma!'
		}
		];

		// Initialize game
		function initGame() {
			snake = [{ x: 300, y: 300 }];
			direction = { x: config.cellSize, y: 0 };
			nextDirection = { x: config.cellSize, y: 0 };
			food = [];
			powerUps = [];
			score = 0;
			level = 1;
			gameSpeed = config.initialSpeed;
			gameActive = true;
			gamePaused = false;
			lives = 3;  // Reset lives
			isRecovering = false;

			if (powerUpTimer) clearTimeout(powerUpTimer);
			activePowerUp = null;
			powerUpIndicator.classList.remove('active');

			for (let i = 0; i < config.foodCount; i++) {
				food.push(generateFood());
			}

			updateScore();
			updateLevel();
			updateLives();  // Update lives display

			gameOver.style.display = 'none';
			startGame.style.display = 'none';

			playSound('music', { loop: true, isMusic: true });

			requestAnimationFrame(gameLoop);
		}

		// Generate random color
		function randomColor() {
			const hue = Math.floor(Math.random() * 360);
			return `hsl(${hue}, 100%, 65%)`;
		}

		// Generate random position (avoid snake)
		function randomPosition() {
			const x = Math.floor(Math.random() * (config.gridSize / config.cellSize)) * config.cellSize;
			const y = Math.floor(Math.random() * (config.gridSize / config.cellSize)) * config.cellSize;

			// Check if position overlaps with snake
			if (snake.some(segment => segment.x === x && segment.y === y)) {
				return randomPosition(); // Try again
			}

			return { x, y };
		}

		// Generate food
		function generateFood() {
			const pos = randomPosition();
			return {
				...pos,
				color: randomColor(),
				pulseScale: 1,
				pulseDirection: -0.01,
				sparkles: Array(3).fill().map(() => ({
					x: Math.random() * config.cellSize,
					y: Math.random() * config.cellSize,
					size: 1 + Math.random() * 2,
					speed: 0.1 + Math.random() * 0.2
				}))
			};
		}

		// Generate power-up
		function generatePowerUp() {
			const pos = randomPosition();
			const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];

			return {
				...pos,
				type: type,
				color: type.color,
				pulseScale: 1,
				pulseDirection: -0.02,
				rotation: 0
			};
		}

		// Activate power-up
		function activatePowerUp(powerUp) {
			// Clear any existing power-up
			if (activePowerUp && activePowerUp.reset) {
				activePowerUp.reset();
			}

			// Apply new power-up effect
			const reset = powerUp.type.effect();

			// Set active power-up
			activePowerUp = {
				type: powerUp.type,
				reset: reset
			};

			// Update UI
			powerUpIcon.style.backgroundColor = powerUp.color;
			powerUpText.textContent = powerUp.type.text;
			powerUpIndicator.classList.add('active');

			// Set timer to clear power-up
			if (powerUpTimer) clearTimeout(powerUpTimer);
			powerUpTimer = setTimeout(() => {
				if (activePowerUp && activePowerUp.reset) {
					activePowerUp.reset();
				}
				activePowerUp = null;
				powerUpIndicator.classList.remove('active');
			}, config.powerUpDuration);
		}

		// Update score
		function updateScore() {
			scoreElement.textContent = `⭐ ${score}`;
		}

		// Update level
		function updateLevel() {
			levelElement.textContent = `🏆 ${level}`;
		}

		// Check collision
		function checkCollision(pos) {
			if (isRecovering) return false;

			if (activePowerUp?.type.name !== 'ghost') {
				if (pos.x < 0 || pos.x >= config.gridSize || pos.y < 0 || pos.y >= config.gridSize) {
					playSound('collision')
					handleLifeLoss();
					return false;
				}
			}

			for (let i = 1; i < snake.length; i++) {
				if (snake[i].x === pos.x && snake[i].y === pos.y) {
					playSound('collision')
					handleLifeLoss();
					return false;
				}
			}

			return false;
		}

		function handleLifeLoss() {
			lives--;
			updateLives();

			if (lives <= 0) {
				endGame();
			} else {
				isRecovering = true;
				setTimeout(() => {
					resetSnake();
					isRecovering = false;
				}, 500); // 500ms recovery pause
			}
		}

		function resetSnake() {
			snake = [{
				x: Math.floor(config.gridSize / 2),
				y: Math.floor(config.gridSize / 2)
			}];
			direction = { x: config.cellSize, y: 0 };
			nextDirection = { x: config.cellSize, y: 0 };
		}

		function updateLives() {
			document.getElementById('lives').textContent = `🏆 ${lives}`;
		}

		// Game loop
		function gameLoop(timestamp) {
			if (!gameActive || gamePaused) {
				if (gameActive) requestAnimationFrame(gameLoop);
				return;
			}

			// Calculate delta time
			const deltaTime = timestamp - lastUpdate;

			// Update game at appropriate speed
			if (deltaTime >= gameSpeed) {
				update();
				lastUpdate = timestamp;
			}

			// Always render
			render();

			// Continue loop
			requestAnimationFrame(gameLoop);
		}

		// Update game state
		function update() {
			// Update direction
			direction = nextDirection;

			// Calculate new head position
			let newHead = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

			// Handle wrapping in ghost mode
			if (activePowerUp?.type.name === 'ghost') {
				if (newHead.x < 0) newHead.x = config.gridSize - config.cellSize;
				if (newHead.x >= config.gridSize) newHead.x = 0;
				if (newHead.y < 0) newHead.y = config.gridSize - config.cellSize;
				if (newHead.y >= config.gridSize) newHead.y = 0;
			}

			// Check collision
			if (checkCollision(newHead)) {
				endGame();
				return;
			}

			// Add new head
			snake.unshift(newHead);

			// Check for food collision
			let ate = false;
			for (let i = 0; i < food.length; i++) {
				if (newHead.x === food[i].x && newHead.y === food[i].y) {
					// Remove eaten food
					food.splice(i, 1);

					// Add score
					const pointsMultiplier = activePowerUp?.type.name === 'points' ? 2 : 1;
					score += 10 * pointsMultiplier;

					// Check for level up
					if (score >= level * config.difficultyThreshold * 10) {
						level++;
						gameSpeed = Math.max(config.maxSpeed, gameSpeed - config.speedIncrement);
						updateLevel();
					}

					// Add new food
					food.push(generateFood());

					// Possibly add power-up
					if (Math.random() < config.powerUpChance) {
						powerUps.push(generatePowerUp());
					}

					// Update score
					updateScore();

					playSound('eat')

					// Keep tail
					ate = true;
					break;
				}
			}

			// Check for power-up collision
			for (let i = 0; i < powerUps.length; i++) {
				if (newHead.x === powerUps[i].x && newHead.y === powerUps[i].y) {
					// Activate power-up
					activatePowerUp(powerUps[i]);

					// Remove collected power-up
					powerUps.splice(i, 1);

					playSound('power-up')

					break;
				}
			}

			// Remove tail if didn't eat
			if (!ate) {
				snake.pop();
			}

			// Update food animations
			food.forEach(f => {
				f.pulseScale += f.pulseDirection;
				if (f.pulseScale <= 0.8 || f.pulseScale >= 1) {
					f.pulseDirection *= -1;
				}

				f.sparkles.forEach(s => {
					s.y -= s.speed;
					if (s.y < 0) {
						s.y = config.cellSize;
						s.x = Math.random() * config.cellSize;
					}
				});
			});

			// Update power-up animations
			powerUps.forEach(p => {
				p.pulseScale += p.pulseDirection;
				if (p.pulseScale <= 0.7 || p.pulseScale >= 1) {
					p.pulseDirection *= -1;
				}
				p.rotation += 0.1;
			});
		}

		// Render game
		function render() {
			// Clear canvas
			ctx.fillStyle = "#000";
			ctx.fillRect(0, 0, config.gridSize, config.gridSize);

			// Draw grid
			ctx.strokeStyle = "rgba(255, 255, 255, 0.05)";
			ctx.lineWidth = 1;

			for (let x = 0; x < config.gridSize; x += config.cellSize) {
				ctx.beginPath();
				ctx.moveTo(x, 0);
				ctx.lineTo(x, config.gridSize);
				ctx.stroke();
			}

			for (let y = 0; y < config.gridSize; y += config.cellSize) {
				ctx.beginPath();
				ctx.moveTo(0, y);
				ctx.lineTo(config.gridSize, y);
				ctx.stroke();
			}

			// Draw snake
			snake.forEach((segment, index) => {
				if (index === 0) {
					// Draw head
					if (activePowerUp) {
						// Draw powered-up head if SVG is available
						if (images.headPowerUp) {
							ctx.drawImage(images.headPowerUp, segment.x, segment.y, config.cellSize, config.cellSize);
						} else {
							// Fallback
							ctx.fillStyle = activePowerUp.type.color;
							ctx.beginPath();
							ctx.arc(
							segment.x + config.cellSize / 2,
							segment.y + config.cellSize / 2,
							config.cellSize / 2,
							0, Math.PI * 2
							);
							ctx.fill();
						}
					} else {
						// Draw normal head
						if (images.head) {
							ctx.drawImage(images.head, segment.x, segment.y, config.cellSize, config.cellSize);
						} else {
							// Fallback
							ctx.fillStyle = "#4ade80";
							ctx.beginPath();
							ctx.arc(
							segment.x + config.cellSize / 2,
							segment.y + config.cellSize / 2,
							config.cellSize / 2,
							0, Math.PI * 2
							);
							ctx.fill();
						}
					}
				} else {
					// Draw body with gradient from head color to tail
					const colorProgress = index / snake.length;
					let baseColor = activePowerUp ? activePowerUp.type.color : "#4ade80";

					// Interpolate to darker color
					const r = parseInt(baseColor.slice(1, 3), 16);
					const g = parseInt(baseColor.slice(3, 5), 16);
					const b = parseInt(baseColor.slice(5, 7), 16);

					const darkR = Math.floor(r * (1 - colorProgress * 0.7));
					const darkG = Math.floor(g * (1 - colorProgress * 0.5));
					const darkB = Math.floor(b * (1 - colorProgress * 0.3));

					const segmentColor = `rgb(${darkR}, ${darkG}, ${darkB})`;

					// Draw rounded segment
					ctx.fillStyle = segmentColor;
					ctx.beginPath();
					ctx.arc(
					segment.x + config.cellSize / 2,
					segment.y + config.cellSize / 2,
					(config.cellSize / 2) * (1 - colorProgress * 0.3),
					0, Math.PI * 2
					);
					ctx.fill();
				}
			});

			// Draw food
			food.forEach(f => {
				// Draw main food
				ctx.fillStyle = f.color;
				ctx.beginPath();
				ctx.arc(
				f.x + config.cellSize / 2,
				f.y + config.cellSize / 2,
				(config.cellSize / 2) * f.pulseScale,
				0, Math.PI * 2
				);
				ctx.fill();

				// Draw sparkles
				ctx.fillStyle = "#fff";
				f.sparkles.forEach(s => {
					ctx.beginPath();
					ctx.arc(
					f.x + s.x,
					f.y + s.y,
					s.size,
					0, Math.PI * 2
					);
					ctx.fill();
				});
			});

			// Draw power-ups
			powerUps.forEach(p => {
				ctx.save();
				ctx.translate(p.x + config.cellSize / 2, p.y + config.cellSize / 2);
				ctx.rotate(p.rotation);

				// Draw star shape
				ctx.fillStyle = p.color;
				ctx.beginPath();
				for (let i = 0; i < 5; i++) {
					const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
					const outerRadius = (config.cellSize / 2) * p.pulseScale;
					const innerRadius = outerRadius * 0.4;

					// Outer point
					const outerX = Math.cos(angle) * outerRadius;
					const outerY = Math.sin(angle) * outerRadius;

					if (i === 0) {
						ctx.moveTo(outerX, outerY);
					} else {
						ctx.lineTo(outerX, outerY);
					}

					// Inner point
					const innerAngle = angle + Math.PI / 5;
					const innerX = Math.cos(innerAngle) * innerRadius;
					const innerY = Math.sin(innerAngle) * innerRadius;
					ctx.lineTo(innerX, innerY);
				}
				ctx.closePath();
				ctx.fill();

				// Draw glow
				ctx.strokeStyle = `rgba(255, 255, 255, ${0.5 * p.pulseScale})`;
				ctx.lineWidth = 2;
				ctx.stroke();

				ctx.restore();
			});

			// Draw ghost mode visual effect
			if (activePowerUp?.type.name === 'ghost') {
				ctx.fillStyle = "rgba(148, 163, 184, 0.15)";
				ctx.fillRect(0, 0, config.gridSize, config.gridSize);

				// Draw boundary indicators
				ctx.strokeStyle = "#94a3b8";
				ctx.lineWidth = 5;
				ctx.setLineDash([15, 15]);
				ctx.strokeRect(0, 0, config.gridSize, config.gridSize);
				ctx.setLineDash([]);

				playSound('ghost')
			}
		}

		// End game
		function endGame() {
			gameActive = false;

			if (score > highScore) {
				highScore = score;
				localStorage.setItem('snakeHighScore', highScore);
				highScoreElement.textContent = `Melhor Score: ${highScore}`;
			}

			finalScore.textContent = `⭐ ${score}`;
			highScoreElement.textContent = `⭐ máximo ${highScore}`;
			gameOver.style.display = 'block';

			setTimeout(() => {
				playSound('game-over')
			}, 1500)
		}

		// Load images
		function loadImages() {
			// Load head image
			const headSvg = document.getElementById("snakeHead");
			const headImg = new Image();
			const headData = new XMLSerializer().serializeToString(headSvg);
			const headUrl = URL.createObjectURL(new Blob([headData], { type: "image/svg+xml" }));
			headImg.onload = () => {
				images.head = headImg;
				URL.revokeObjectURL(headUrl);
			};
			headImg.src = headUrl;

			// Load powered-up head image
			const powerHeadSvg = document.getElementById("snakeHeadPowerUp");
			const powerHeadImg = new Image();
			const powerHeadData = new XMLSerializer().serializeToString(powerHeadSvg);
			const powerHeadUrl = URL.createObjectURL(new Blob([powerHeadData], { type: "image/svg+xml" }));
			powerHeadImg.onload = () => {
				images.headPowerUp = powerHeadImg;
				URL.revokeObjectURL(powerHeadUrl);
			};
			powerHeadImg.src = powerHeadUrl;
		}

		// Event listeners
		document.addEventListener('keydown', e => {
			if (!gameActive) {
				if (e.key === ' ' || e.key === 'Enter') {
					initGame();
				}
				return;
			}

			// Handle pause
			if (e.key === ' ') {
				gamePaused = !gamePaused;
				return;
			}

			// Prevent opposite direction
			if (e.key === 'ArrowUp' && direction.y === 0) {
				nextDirection = { x: 0, y: -config.cellSize };
			} else if (e.key === 'ArrowDown' && direction.y === 0) {
				nextDirection = { x: 0, y: config.cellSize };
			} else if (e.key === 'ArrowLeft' && direction.x === 0) {
				nextDirection = { x: -config.cellSize, y: 0 };
			} else if (e.key === 'ArrowRight' && direction.x === 0) {
				nextDirection = { x: config.cellSize, y: 0 };
			}
		});

		restartButton.addEventListener('click', initGame);

		// Initialize
		loadImages();

		// Start screen - wait for user input
		startGame.style.display = 'block';
		document.getElementById('restartButton').textContent = 'Começar';

		function playSound(name, options = { loop: false, isMusic: false }) {
            const audio = new Audio(`./assets/audio/${name}.mp3`);
            audio.loop = options.loop;

            // Handle background music
            if (options.isMusic) {
                if (currentBackgroundAudio) {
                    currentBackgroundAudio.pause();
                    currentBackgroundAudio.currentTime = 0;
                }
                currentBackgroundAudio = audio;
            } else {
                // Handle sound effects
                if (currentEffectAudio) {
                    currentEffectAudio.pause();
                    currentEffectAudio.currentTime = 0;
                }
                currentEffectAudio = audio;
            }

            audio.play().catch(error => {
                console.error('Error playing sound:', error);
            });
        }

	</script>
</body>
</html>

[gravidade_planetas.py]
import pygame
import random
import math

# Inicializa o Pygame
pygame.init()

# Configuracoes da Tela
LARGURA, ALTURA = 900, 900
tela = pygame.display.set_mode((LARGURA, ALTURA))
pygame.display.set_caption("Simulador de Gravidade")

# Cores
BRANCO = (255, 255, 255)
PRETO = (20, 20, 30)
AZUL = (50, 150, 255)
VERDE = (50, 130, 50)
VERMELHO = (255, 50, 50)
CINZA = (100, 100, 100)
AMARELO = (255, 215, 0)

GRAVIDADE_MIN = 0.05  # Gravidade minima
GRAVIDADE_MAX = 30.0 / 10  # Gravidade maxima

cores = [AZUL, VERDE, VERMELHO, AMARELO]

# Relogio para controle de FPS
clock = pygame.time.Clock()

# Gravidade inicial (Terra)
selected_planet = "Terra"
gravidade = 9.8 / 10  # Ajustado para a escala do jogo

# Planetas e suas gravidades (m/s2 convertidos para escala do jogo)
planetas = {
   "Lua": 1.6 / 10,
   "Mercurio": 3.7 / 10,
   "Venus": 8.9 / 10,
   "Terra": 9.8 / 10,
   "Marte": 3.7 / 10,
   "Jupiter": 24.8 / 10,
   "Saturno": 10.4 / 10,
   "Urano": 8.7 / 10,
   "Netuno": 11.2 / 10
}

# Classe para representar uma bola
class Bola:
   def __init__(self, x, y, raio, cor):
       self.x = x
       self.y = y
       self.raio = raio
       self.cor = cor
       self.vel_x = random.uniform(-3, 3)  # Velocidade horizontal aleatoria
       self.vel_y = 0  # Velocidade vertical
       self.restituicao = 0.8  # Quanto da energia e preservada ao quicar

   def atualizar(self):
       # Aplica a gravidade
       self.vel_y += gravidade
       self.x += self.vel_x
       self.y += self.vel_y

       # Se atingir o chao, quica
       if self.y + self.raio > ALTURA:
           self.y = ALTURA - self.raio
           self.vel_y *= -self.restituicao  # Invertemos a direcao e aplicamos amortecimento

       # Se atingir as laterais, inverte a velocidade X
       if self.x - self.raio < 0 or self.x + self.raio > LARGURA:
           self.vel_x *= -self.restituicao

   def desenhar(self, tela):
       pygame.draw.circle(tela, self.cor, (int(self.x), int(self.y)), self.raio)

# Verifica e resolve colisoes entre bolas
def resolver_colisoes(bolas):
   for i in range(len(bolas)):
       for j in range(i + 1, len(bolas)):
           bola1, bola2 = bolas[i], bolas[j]
           dx = bola2.x - bola1.x
           dy = bola2.y - bola1.y
           distancia = math.sqrt(dx**2 + dy**2)

           if distancia < bola1.raio + bola2.raio:  # Se houver colisao
               # Calcula o angulo da colisao
               angulo = math.atan2(dy, dx)

               # Separa as bolas para evitar sobreposicao
               overlap = (bola1.raio + bola2.raio) - distancia
               bola1.x -= math.cos(angulo) * overlap / 2
               bola1.y -= math.sin(angulo) * overlap / 2
               bola2.x += math.cos(angulo) * overlap / 2
               bola2.y += math.sin(angulo) * overlap / 2

               # Velocidade apos a colisao (baseado em conservacao de momento)
               vel1_proj = bola1.vel_x * math.cos(angulo) + bola1.vel_y * math.sin(angulo)
               vel2_proj = bola2.vel_x * math.cos(angulo) + bola2.vel_y * math.sin(angulo)

               bola1.vel_x += (vel2_proj - vel1_proj) * math.cos(angulo)
               bola1.vel_y += (vel2_proj - vel1_proj) * math.sin(angulo)
               bola2.vel_x += (vel1_proj - vel2_proj) * math.cos(angulo)
               bola2.vel_y += (vel1_proj - vel2_proj) * math.sin(angulo)

# Criando multiplas bolas aleatorias
def criar_bolas():
   return [Bola(random.randint(50, LARGURA - 50), random.randint(50, 300), random.randint(10, 45), random.choice(cores)) for _ in range(10)]

bolas = criar_bolas()

# Fonte para exibir texto
fonte = pygame.font.Font(None, 30)
fonte_titulo = pygame.font.Font(None, 40)

# Funcao para desenhar botoes
def desenhar_botao(tela, texto, pos, tamanho, cor_fundo, cor_texto=BRANCO):
   """Desenha um botao na tela com fundo, borda e texto"""
   rect = pygame.Rect(pos[0], pos[1], tamanho[0], tamanho[1])
   pygame.draw.rect(tela, cor_fundo, rect, border_radius=10)

   # Renderiza o texto centralizado
   texto_render = fonte.render(texto, True, cor_texto)
   texto_rect = texto_render.get_rect(center=rect.center)
   tela.blit(texto_render, texto_rect)

   return rect

# Loop do jogo
rodando = True
while rodando:
   tela.fill(PRETO)

   # Captura eventos
   for evento in pygame.event.get():
       if evento.type == pygame.QUIT:
           rodando = False
       elif evento.type == pygame.MOUSEBUTTONDOWN:
           x, y = evento.pos

           # Botao "Jogar de Novo"
           if botao_reset.collidepoint(x, y):
               bolas = criar_bolas()  # Reseta as bolas

           # Botoes "Planetas"
           for i, (planeta, g) in enumerate(planetas.items()):
               if botoes_planetas[i].collidepoint(x, y):
                   gravidade = g  # Set gravity
                   selected_planet = planeta  # Update selected planet
                   bolas = criar_bolas()  # Reset balls

   # Atualiza e resolve colisoes entre bolas
   for bola in bolas:
       bola.atualizar()
   resolver_colisoes(bolas)

   # Desenha as bolas
   for bola in bolas:
       bola.desenhar(tela)

   # Botao de reinicio
   botao_reset = desenhar_botao(tela, "Jogar de Novo", (LARGURA - 160, 20), (160, 40), VERMELHO)

   # Titulo "Planetas"
   texto_planetas = fonte_titulo.render("Escolha um planeta:", True, BRANCO)
   tela.blit(texto_planetas, (50, 70))

   # Draw planet buttons with correct highlighting
   botoes_planetas = []
   for i, (planeta, g) in enumerate(planetas.items()):
       cor_botao = VERDE if planeta == selected_planet else AZUL  # Highlight selected planet
       botao = desenhar_botao(tela, planeta, (50 + (i % 4) * 190, 110 + (i // 4) * 50), (180, 40), cor_botao)
       botoes_planetas.append(botao)

   pygame.display.flip()
   clock.tick(60)

pygame.quit()

[tetris.html]
<!DOCTYPE html>
<html>
<head>
    <title>Modern Tetris</title>
    <style>
        body {
            margin: 0;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }

        #score-board {
            color: white;
            padding: 20px;
            background: #333;
            border-radius: 8px;
        }

        canvas {
            border: 2px solid #333;
            border-radius: 8px;
        }

        .game-over {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="score-board">
            Score: <span id="score">0</span> | Level: <span id="level">1</span>
        </div>
        <canvas id="game" width="300" height="600"></canvas>
    </div>
    <div id="game-over" class="game-over">
        <h2>Game Over!</h2>
        <p>Final Score: <span id="final-score">0</span></p>
        <button onclick="startGame()">Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const gameOverDiv = document.getElementById('game-over');

        let block_size = 30;
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const COLORS = [
            '#FF0D72', '#0DC2FF', '#0DFF72',
            '#F538FF', '#FF8E0D', '#FFE138',
            '#3877FF'
        ];

        let isGameOver = false;
        let dropInterval = 1000;
        let dropCounter = 0;
        let lastTime = 0;
        let level = 1;
        let score = 0;
        let linesCleared = 0;
        let board = [];
        let currentPiece = null;

        let lastTap = 0;
        let touchStartX = 0;
        let touchStartY = 0;

        const PIECES = [
            [[1,1,1,1]],
            [[1,1,1],[0,1,0]],
            [[1,1,1],[1,0,0]],
            [[1,1,1],[0,0,1]],
            [[1,1],[1,1]],
            [[1,1,0],[0,1,1]],
            [[0,1,1],[1,1,0]]
        ];

        function createPiece() {
            const pieceIndex = Math.floor(Math.random() * PIECES.length);
            return {
                shape: PIECES[pieceIndex],
                color: COLORS[pieceIndex],
                x: Math.floor(BOARD_WIDTH / 2) - 1,
                y: 0
            };
        }

        function drawBlock(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.strokeRect(x * BLOCK_SIZE + 1, y * BLOCK_SIZE + 1, BLOCK_SIZE - 3, BLOCK_SIZE - 3);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
        }

        function drawBoard() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    if (board[y][x]) {
                        drawBlock(x, y, board[y][x]);
                    }
                }
            }

            currentPiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        drawBlock(currentPiece.x + x, currentPiece.y + y, currentPiece.color);
                    }
                });
            });
        }

        function moveDown() {
            currentPiece.y++;
            if (collision()) {
                currentPiece.y--;
                merge();
                clearLines();
                currentPiece = createPiece();
                if (collision()) {
                    endGame();
                }
            }
        }

        function collision() {
            return currentPiece.shape.some((row, y) =>
                row.some((value, x) => {
                    if (!value) return false;
                    const newX = currentPiece.x + x;
                    const newY = currentPiece.y + y;
                    return newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT || (newY >= 0 && board[newY][newX]);
                })
            );
        }

        function merge() {
            currentPiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        board[currentPiece.y + y][currentPiece.x + x] = currentPiece.color;
                    }
                });
            });
        }

        function clearLines() {
            for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                if (board[y].every(cell => cell)) {
                    board.splice(y, 1);
                    board.unshift(Array(BOARD_WIDTH).fill(0));
                    score += 100;
                    linesCleared++;
                    scoreElement.textContent = score;

                    if (linesCleared % 5 === 0) {
                        level++;
                        levelElement.textContent = level;
                        dropInterval = Math.max(100, dropInterval - 100);
                    }
                }
            }
        }

        function endGame() {
            isGameOver = true;
            gameOverDiv.style.display = 'block';
            document.getElementById('final-score').textContent = score;
        }

        function update(time = 0) {
            if (isGameOver) return; // Stop the game loop if it's over

            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;

            if (dropCounter > dropInterval) {
                moveDown();
                dropCounter = 0;
            }

            drawBoard();
            requestAnimationFrame(update);
        }

        function startGame() {
            board = Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(0));
            currentPiece = createPiece();
            score = 0;
            level = 1;
            linesCleared = 0;
            dropInterval = 1000;
            isGameOver = false;
            scoreElement.textContent = score;
            levelElement.textContent = level;
            gameOverDiv.style.display = 'none';
            requestAnimationFrame(update);
        }

        document.addEventListener('keydown', event => {
            if (isGameOver) return; // Prevent movement if game is over

            switch (event.keyCode) {
                case 37: currentPiece.x--; if (collision()) currentPiece.x++; break;
                case 39: currentPiece.x++; if (collision()) currentPiece.x--; break;
                case 40: moveDown(); break;
                case 38: rotate(); break;
            }
            drawBoard();
        });

        canvas.addEventListener('touchstart', (e) => {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            lastTap = currentTime;
            if (tapLength < 300 && tapLength > 0) {
                rotate();
            } else {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }
        });

        canvas.addEventListener('touchend', (e) => {
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const diffX = touchEndX - touchStartX;
            const diffY = touchEndY - touchStartY;

            if (Math.abs(diffX) > Math.abs(diffY)) {
                if (diffX > 0) currentPiece.x++;
                else currentPiece.x--;
            } else {
                if (diffY > 0) moveDown();
            }
            drawBoard();
        });

        function rotate() {
            const rotated = currentPiece.shape[0].map((_, i) => currentPiece.shape.map(row => row[i]).reverse());
            const prevShape = currentPiece.shape;
            currentPiece.shape = rotated;
            if (collision()) currentPiece.shape = prevShape;
        }

        function isMobileDevice() {
            return /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function resizeCanvas() {
            if (isMobileDevice()) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                document.body.style.overflow = 'hidden';
            } else {
                canvas.width = 300;
                canvas.height = 600;
            }
            BLOCK_SIZE = Math.min(canvas.width / BOARD_WIDTH, canvas.height / BOARD_HEIGHT);
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        startGame();
    </script>
</body>
</html>

[planetas.py]
import turtle
import math
import random

screen = turtle.Screen()
screen.bgcolor("black")
screen.tracer(0)

def criar_estrelas(num_estrelas):
   estrelas = []
   for _ in range(num_estrelas):
       estrela = turtle.Turtle()
       estrela.shape("circle")
       estrela.color("white")
       estrela.shapesize(random.uniform(0.05, 0.15))
       estrela.penup()
       estrela.goto(random.randint(-800, 800), random.randint(-400, 400))
       estrelas.append(estrela)
   return estrelas

criar_estrelas(300)

sun = turtle.Turtle()
sun.shape("circle")
sun.color("#FFD700")
sun.shapesize(2)

planets = [
   ("Mercurio", "#8B8B83", 0.4, 50, 2),
   ("Venus", "#E6B800", 0.6, 80, 1.5),
   ("Terra", "#0077BE", 0.8, 120, 1.2),
   ("Marte", "#FF4500", 0.7, 160, 1),
   ("Jupiter", "#D2B48C", 1.5, 220, 0.8),
   ("Saturno", "#F4A460", 1.3, 280, 0.6),
   ("Urano", "#40E0D0", 1.1, 340, 0.5),
   ("Netuno", "#0000FF", 1.0, 400, 0.4)
]

planet_turtles = []
for planet in planets:
   name, color, size, distance, speed = planet
   p = turtle.Turtle()
   p.shape("circle")
   p.color(color)
   p.shapesize(size)
   p.penup()
   p.goto(distance, 0)
   p.pendown()
   planet_turtles.append((p, distance, speed, 0))

def move_planets():
   for planet in planet_turtles:
       p, distance, speed, angle = planet
       x = distance * math.cos(math.radians(angle))
       y = distance * math.sin(math.radians(angle))
       p.goto(x, y)
       planet_turtles[planet_turtles.index(planet)] = (p, distance, speed, angle + speed)

while True:
   screen.update()
   move_planets()
   turtle.time.sleep(0.03)

[aquario.py]
import turtle
import random

screen = turtle.Screen()
screen.bgcolor("lightblue")
screen.setup(width=1400, height=900)

def create_fish_shape():
   turtle.begin_poly()
   turtle.forward(30)
   turtle.left(120)
   turtle.forward(30)
   turtle.left(120)
   turtle.forward(30)
   turtle.left(120)
   turtle.end_poly()
   body = turtle.get_poly()

   turtle.begin_poly()
   turtle.forward(30)
   turtle.right(120)
   turtle.forward(30)
   turtle.right(120)
   turtle.forward(30)
   turtle.right(120)
   turtle.end_poly()
   tail = turtle.get_poly()

   screen.addshape("fish_body", body)
   screen.addshape("fish_tail", tail)

def create_fish():

   fish_color = random.choice(["coral", "gold", "firebrick",
                               "magenta", "green", "red"])
   body = turtle.Turtle()
   body.shape("fish_body")
   body.color(fish_color)
   body.penup()
   body.speed(0)
   body.setpos(random.randint(-380, 380), random.randint(-280, 280))
   body.setheading(random.randint(0, 360))

   tail = turtle.Turtle()
   tail.shape("fish_tail")
   tail.color(fish_color)
   tail.penup()
   tail.speed(0)
   tail.setpos(body.pos())
   tail.setheading(body.heading())

   return body, tail

create_fish_shape()

peixes = [create_fish() for _ in range(30)]

while True:
   for body, tail in peixes:
       if random.random() < 0.1:
           turn = random.randint(-70, 70)
           body.left(turn)
           tail.left(turn)

       body.forward(10)
       tail.forward(10)

       x, y = body.pos()
       if abs(x) > 700 or abs(y) > 450:
           body.setheading(body.heading() + 90)
           tail.setheading(tail.heading() + 90)


[relogio.py]
import os
import time
from typing import Dict, List

CURSOR_UP = '\033[A'
digits = {
   '0': '  oooo   o    o o      o o      o  o    o   oooo  ',
   '1': '   o    oo     o     o     o     o     ooo  ',
   '2': ' oooooo o      o      o    o    o  o     ooooooo ',
   '3': ' oooooo        o   oooo        o        o  oooooo ',
   '4': 'o      o o      o  ooooooo        o        o        o',
   '5': 'ooooooo o        ooooooo        o        o ooooooo ',
   '6': ' oooooo o        o ooooo o      o o      o  oooooo ',
   '7': 'ooooooo       o      o     o      o     o      o  ',
   '8': ' oooooo o      o  oooooo o      o o      o  oooooo ',
   '9': ' oooooo o      o  ooooooo        o        o  oooooo ',
   ':': '       o         o         '
}

def get_time_rows(time_str: str) -> List[str]:
   """Generate the rows for the current time."""
   rows = []
   for row in range(6):
       current_row = '  '
       for char in time_str:
           current_row += digits[char][row] + '  '  # Increase spacing
       rows.append(current_row)
   return rows

# Initial setup
prev_time = ''
first_run = True

while True:
   current_time = time.strftime("%H:%M:%S")

   # Only update if time has changed
   if current_time != prev_time:
       time_rows = get_time_rows(current_time)

       # Move cursor up to overwrite previous output
       if not first_run:
           for _ in range(6):
               print(CURSOR_UP, end='')

       # Print new time
       for row in time_rows:
           print(row)

       prev_time = current_time
       first_run = False

   time.sleep(0.1)

[relogio_analogico.py]
import pygame
import math
import datetime

# Inicializa o Pygame
pygame.init()

# Configuracoes do relogio
LARGURA, ALTURA = 500, 500
CENTRO = (LARGURA // 2, ALTURA // 2)
RAIO = 200  # Raio do relogio
COR_FUNDO = (20, 20, 30)  # Azul escuro elegante
COR_BORDA = (240, 240, 240)  # Borda branca
COR_NUMEROS = (200, 200, 200)  # Cinza claro
COR_PONTEIRO_H = (255, 100, 100)  # Vermelho suave
COR_PONTEIRO_M = (100, 255, 100)  # Verde claro
COR_PONTEIRO_S = (100, 100, 255)  # Azul claro

# Criacao da tela
tela = pygame.display.set_mode((LARGURA, ALTURA))
pygame.display.set_caption("Relogio Analogico Minimalista")
clock = pygame.time.Clock()

# Funcao para desenhar ponteiros
def desenha_ponteiro(tela, angulo, comprimento, cor, largura=4):
   """Desenha um ponteiro do relogio."""
   angulo_rad = math.radians(angulo - 90)  # Ajusta o angulo para comecar do topo
   ponta_x = CENTRO[0] + comprimento * math.cos(angulo_rad)
   ponta_y = CENTRO[1] + comprimento * math.sin(angulo_rad)
   pygame.draw.line(tela, cor, CENTRO, (ponta_x, ponta_y), largura)

# Funcao principal do jogo
rodando = True
while rodando:
   tela.fill(COR_FUNDO)

   # Eventos do Pygame
   for event in pygame.event.get():
       if event.type == pygame.QUIT:
           rodando = False

   # Obtem o horario atual
   agora = datetime.datetime.now()
   segundos = agora.second
   minutos = agora.minute + segundos / 60  # Minutos suaves
   horas = agora.hour % 12 + minutos / 60  # Horas suaves

   # Converte para angulos (360? para 60 unidades)
   ang_h = horas * 30  # 360?/12h = 30? por hora
   ang_m = minutos * 6  # 360?/60min = 6? por minuto
   ang_s = segundos * 6  # 360?/60s = 6? por segundo

   # Desenha o circulo do relogio
   pygame.draw.circle(tela, COR_BORDA, CENTRO, RAIO, 8)  # Contorno do relogio

   # Desenha os numeros do relogio
   for i in range(1, 13):
       ang_num = math.radians(i * 30 - 90)
       num_x = CENTRO[0] + (RAIO - 30) * math.cos(ang_num)
       num_y = CENTRO[1] + (RAIO - 30) * math.sin(ang_num)
       fonte = pygame.font.Font(None, 40)
       texto = fonte.render(str(i), True, COR_NUMEROS)
       tela.blit(texto, (num_x - 10, num_y - 15))

   # Desenha os ponteiros
   desenha_ponteiro(tela, ang_h, RAIO * 0.5, COR_PONTEIRO_H, 8)  # Horas
   desenha_ponteiro(tela, ang_m, RAIO * 0.7, COR_PONTEIRO_M, 6)  # Minutos
   desenha_ponteiro(tela, ang_s, RAIO * 0.9, COR_PONTEIRO_S, 2)  # Segundos

   # Desenha o centro do relogio
   pygame.draw.circle(tela, (255, 255, 255), CENTRO, 8)  # Pequeno circulo no centro

   pygame.display.flip()
   clock.tick(30)  # Suaviza a animacao

pygame.quit()